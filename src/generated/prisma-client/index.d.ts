// Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  charity: (where?: CharityWhereInput) => Promise<boolean>;
  circle: (where?: CircleWhereInput) => Promise<boolean>;
  circleInvite: (where?: CircleInviteWhereInput) => Promise<boolean>;
  circleJoinRequest: (where?: CircleJoinRequestWhereInput) => Promise<boolean>;
  donation: (where?: DonationWhereInput) => Promise<boolean>;
  dot: (where?: DotWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  funds: (where?: FundsWhereInput) => Promise<boolean>;
  halo: (where?: HaloWhereInput) => Promise<boolean>;
  identity: (where?: IdentityWhereInput) => Promise<boolean>;
  loop: (where?: LoopWhereInput) => Promise<boolean>;
  preferences: (where?: PreferencesWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  charity: (where: CharityWhereUniqueInput) => CharityNullablePromise;
  charities: (args?: {
    where?: CharityWhereInput;
    orderBy?: CharityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Charity>;
  charitiesConnection: (args?: {
    where?: CharityWhereInput;
    orderBy?: CharityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CharityConnectionPromise;
  circle: (where: CircleWhereUniqueInput) => CircleNullablePromise;
  circles: (args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Circle>;
  circlesConnection: (args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CircleConnectionPromise;
  circleInvite: (
    where: CircleInviteWhereUniqueInput
  ) => CircleInviteNullablePromise;
  circleInvites: (args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CircleInvite>;
  circleInvitesConnection: (args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CircleInviteConnectionPromise;
  circleJoinRequest: (
    where: CircleJoinRequestWhereUniqueInput
  ) => CircleJoinRequestNullablePromise;
  circleJoinRequests: (args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CircleJoinRequest>;
  circleJoinRequestsConnection: (args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CircleJoinRequestConnectionPromise;
  donation: (where: DonationWhereUniqueInput) => DonationNullablePromise;
  donations: (args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Donation>;
  donationsConnection: (args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DonationConnectionPromise;
  dot: (where: DotWhereUniqueInput) => DotNullablePromise;
  dots: (args?: {
    where?: DotWhereInput;
    orderBy?: DotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Dot>;
  dotsConnection: (args?: {
    where?: DotWhereInput;
    orderBy?: DotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DotConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  funds: (where: FundsWhereUniqueInput) => FundsNullablePromise;
  fundses: (args?: {
    where?: FundsWhereInput;
    orderBy?: FundsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Funds>;
  fundsesConnection: (args?: {
    where?: FundsWhereInput;
    orderBy?: FundsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FundsConnectionPromise;
  halo: (where: HaloWhereUniqueInput) => HaloNullablePromise;
  haloes: (args?: {
    where?: HaloWhereInput;
    orderBy?: HaloOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Halo>;
  haloesConnection: (args?: {
    where?: HaloWhereInput;
    orderBy?: HaloOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HaloConnectionPromise;
  identity: (where: IdentityWhereUniqueInput) => IdentityNullablePromise;
  identities: (args?: {
    where?: IdentityWhereInput;
    orderBy?: IdentityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Identity>;
  identitiesConnection: (args?: {
    where?: IdentityWhereInput;
    orderBy?: IdentityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IdentityConnectionPromise;
  loop: (where: LoopWhereUniqueInput) => LoopNullablePromise;
  loops: (args?: {
    where?: LoopWhereInput;
    orderBy?: LoopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Loop>;
  loopsConnection: (args?: {
    where?: LoopWhereInput;
    orderBy?: LoopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LoopConnectionPromise;
  preferences: (
    where: PreferencesWhereUniqueInput
  ) => PreferencesNullablePromise;
  preferenceses: (args?: {
    where?: PreferencesWhereInput;
    orderBy?: PreferencesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Preferences>;
  preferencesesConnection: (args?: {
    where?: PreferencesWhereInput;
    orderBy?: PreferencesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PreferencesConnectionPromise;
  transaction: (
    where: TransactionWhereUniqueInput
  ) => TransactionNullablePromise;
  transactions: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Transaction>;
  transactionsConnection: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TransactionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCharity: (data: CharityCreateInput) => CharityPromise;
  updateCharity: (args: {
    data: CharityUpdateInput;
    where: CharityWhereUniqueInput;
  }) => CharityPromise;
  updateManyCharities: (args: {
    data: CharityUpdateManyMutationInput;
    where?: CharityWhereInput;
  }) => BatchPayloadPromise;
  upsertCharity: (args: {
    where: CharityWhereUniqueInput;
    create: CharityCreateInput;
    update: CharityUpdateInput;
  }) => CharityPromise;
  deleteCharity: (where: CharityWhereUniqueInput) => CharityPromise;
  deleteManyCharities: (where?: CharityWhereInput) => BatchPayloadPromise;
  createCircle: (data: CircleCreateInput) => CirclePromise;
  updateCircle: (args: {
    data: CircleUpdateInput;
    where: CircleWhereUniqueInput;
  }) => CirclePromise;
  updateManyCircles: (args: {
    data: CircleUpdateManyMutationInput;
    where?: CircleWhereInput;
  }) => BatchPayloadPromise;
  upsertCircle: (args: {
    where: CircleWhereUniqueInput;
    create: CircleCreateInput;
    update: CircleUpdateInput;
  }) => CirclePromise;
  deleteCircle: (where: CircleWhereUniqueInput) => CirclePromise;
  deleteManyCircles: (where?: CircleWhereInput) => BatchPayloadPromise;
  createCircleInvite: (data: CircleInviteCreateInput) => CircleInvitePromise;
  updateCircleInvite: (args: {
    data: CircleInviteUpdateInput;
    where: CircleInviteWhereUniqueInput;
  }) => CircleInvitePromise;
  upsertCircleInvite: (args: {
    where: CircleInviteWhereUniqueInput;
    create: CircleInviteCreateInput;
    update: CircleInviteUpdateInput;
  }) => CircleInvitePromise;
  deleteCircleInvite: (
    where: CircleInviteWhereUniqueInput
  ) => CircleInvitePromise;
  deleteManyCircleInvites: (
    where?: CircleInviteWhereInput
  ) => BatchPayloadPromise;
  createCircleJoinRequest: (
    data: CircleJoinRequestCreateInput
  ) => CircleJoinRequestPromise;
  updateCircleJoinRequest: (args: {
    data: CircleJoinRequestUpdateInput;
    where: CircleJoinRequestWhereUniqueInput;
  }) => CircleJoinRequestPromise;
  upsertCircleJoinRequest: (args: {
    where: CircleJoinRequestWhereUniqueInput;
    create: CircleJoinRequestCreateInput;
    update: CircleJoinRequestUpdateInput;
  }) => CircleJoinRequestPromise;
  deleteCircleJoinRequest: (
    where: CircleJoinRequestWhereUniqueInput
  ) => CircleJoinRequestPromise;
  deleteManyCircleJoinRequests: (
    where?: CircleJoinRequestWhereInput
  ) => BatchPayloadPromise;
  createDonation: (data: DonationCreateInput) => DonationPromise;
  updateDonation: (args: {
    data: DonationUpdateInput;
    where: DonationWhereUniqueInput;
  }) => DonationPromise;
  updateManyDonations: (args: {
    data: DonationUpdateManyMutationInput;
    where?: DonationWhereInput;
  }) => BatchPayloadPromise;
  upsertDonation: (args: {
    where: DonationWhereUniqueInput;
    create: DonationCreateInput;
    update: DonationUpdateInput;
  }) => DonationPromise;
  deleteDonation: (where: DonationWhereUniqueInput) => DonationPromise;
  deleteManyDonations: (where?: DonationWhereInput) => BatchPayloadPromise;
  createDot: (data: DotCreateInput) => DotPromise;
  updateDot: (args: {
    data: DotUpdateInput;
    where: DotWhereUniqueInput;
  }) => DotPromise;
  updateManyDots: (args: {
    data: DotUpdateManyMutationInput;
    where?: DotWhereInput;
  }) => BatchPayloadPromise;
  upsertDot: (args: {
    where: DotWhereUniqueInput;
    create: DotCreateInput;
    update: DotUpdateInput;
  }) => DotPromise;
  deleteDot: (where: DotWhereUniqueInput) => DotPromise;
  deleteManyDots: (where?: DotWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createFunds: (data: FundsCreateInput) => FundsPromise;
  updateFunds: (args: {
    data: FundsUpdateInput;
    where: FundsWhereUniqueInput;
  }) => FundsPromise;
  updateManyFundses: (args: {
    data: FundsUpdateManyMutationInput;
    where?: FundsWhereInput;
  }) => BatchPayloadPromise;
  upsertFunds: (args: {
    where: FundsWhereUniqueInput;
    create: FundsCreateInput;
    update: FundsUpdateInput;
  }) => FundsPromise;
  deleteFunds: (where: FundsWhereUniqueInput) => FundsPromise;
  deleteManyFundses: (where?: FundsWhereInput) => BatchPayloadPromise;
  createHalo: (data: HaloCreateInput) => HaloPromise;
  updateHalo: (args: {
    data: HaloUpdateInput;
    where: HaloWhereUniqueInput;
  }) => HaloPromise;
  updateManyHaloes: (args: {
    data: HaloUpdateManyMutationInput;
    where?: HaloWhereInput;
  }) => BatchPayloadPromise;
  upsertHalo: (args: {
    where: HaloWhereUniqueInput;
    create: HaloCreateInput;
    update: HaloUpdateInput;
  }) => HaloPromise;
  deleteHalo: (where: HaloWhereUniqueInput) => HaloPromise;
  deleteManyHaloes: (where?: HaloWhereInput) => BatchPayloadPromise;
  createIdentity: (data: IdentityCreateInput) => IdentityPromise;
  updateIdentity: (args: {
    data: IdentityUpdateInput;
    where: IdentityWhereUniqueInput;
  }) => IdentityPromise;
  updateManyIdentities: (args: {
    data: IdentityUpdateManyMutationInput;
    where?: IdentityWhereInput;
  }) => BatchPayloadPromise;
  upsertIdentity: (args: {
    where: IdentityWhereUniqueInput;
    create: IdentityCreateInput;
    update: IdentityUpdateInput;
  }) => IdentityPromise;
  deleteIdentity: (where: IdentityWhereUniqueInput) => IdentityPromise;
  deleteManyIdentities: (where?: IdentityWhereInput) => BatchPayloadPromise;
  createLoop: (data: LoopCreateInput) => LoopPromise;
  updateLoop: (args: {
    data: LoopUpdateInput;
    where: LoopWhereUniqueInput;
  }) => LoopPromise;
  updateManyLoops: (args: {
    data: LoopUpdateManyMutationInput;
    where?: LoopWhereInput;
  }) => BatchPayloadPromise;
  upsertLoop: (args: {
    where: LoopWhereUniqueInput;
    create: LoopCreateInput;
    update: LoopUpdateInput;
  }) => LoopPromise;
  deleteLoop: (where: LoopWhereUniqueInput) => LoopPromise;
  deleteManyLoops: (where?: LoopWhereInput) => BatchPayloadPromise;
  createPreferences: (data: PreferencesCreateInput) => PreferencesPromise;
  updatePreferences: (args: {
    data: PreferencesUpdateInput;
    where: PreferencesWhereUniqueInput;
  }) => PreferencesPromise;
  updateManyPreferenceses: (args: {
    data: PreferencesUpdateManyMutationInput;
    where?: PreferencesWhereInput;
  }) => BatchPayloadPromise;
  upsertPreferences: (args: {
    where: PreferencesWhereUniqueInput;
    create: PreferencesCreateInput;
    update: PreferencesUpdateInput;
  }) => PreferencesPromise;
  deletePreferences: (where: PreferencesWhereUniqueInput) => PreferencesPromise;
  deleteManyPreferenceses: (
    where?: PreferencesWhereInput
  ) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (args: {
    data: TransactionUpdateInput;
    where: TransactionWhereUniqueInput;
  }) => TransactionPromise;
  updateManyTransactions: (args: {
    data: TransactionUpdateManyMutationInput;
    where?: TransactionWhereInput;
  }) => BatchPayloadPromise;
  upsertTransaction: (args: {
    where: TransactionWhereUniqueInput;
    create: TransactionCreateInput;
    update: TransactionUpdateInput;
  }) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  charity: (
    where?: CharitySubscriptionWhereInput
  ) => CharitySubscriptionPayloadSubscription;
  circle: (
    where?: CircleSubscriptionWhereInput
  ) => CircleSubscriptionPayloadSubscription;
  circleInvite: (
    where?: CircleInviteSubscriptionWhereInput
  ) => CircleInviteSubscriptionPayloadSubscription;
  circleJoinRequest: (
    where?: CircleJoinRequestSubscriptionWhereInput
  ) => CircleJoinRequestSubscriptionPayloadSubscription;
  donation: (
    where?: DonationSubscriptionWhereInput
  ) => DonationSubscriptionPayloadSubscription;
  dot: (
    where?: DotSubscriptionWhereInput
  ) => DotSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  funds: (
    where?: FundsSubscriptionWhereInput
  ) => FundsSubscriptionPayloadSubscription;
  halo: (
    where?: HaloSubscriptionWhereInput
  ) => HaloSubscriptionPayloadSubscription;
  identity: (
    where?: IdentitySubscriptionWhereInput
  ) => IdentitySubscriptionPayloadSubscription;
  loop: (
    where?: LoopSubscriptionWhereInput
  ) => LoopSubscriptionPayloadSubscription;
  preferences: (
    where?: PreferencesSubscriptionWhereInput
  ) => PreferencesSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CharityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "acronym_ASC"
  | "acronym_DESC"
  | "bannerCredit_ASC"
  | "bannerCredit_DESC"
  | "connectedAccountID_ASC"
  | "connectedAccountID_DESC"
  | "ein_ASC"
  | "ein_DESC"
  | "expensesAdministrative_ASC"
  | "expensesAdministrative_DESC"
  | "expensesFundraising_ASC"
  | "expensesFundraising_DESC"
  | "expensesOther_ASC"
  | "expensesOther_DESC"
  | "expensesProgram_ASC"
  | "expensesProgram_DESC"
  | "expensesUpdated_ASC"
  | "expensesUpdated_DESC"
  | "location_ASC"
  | "location_DESC"
  | "mission_ASC"
  | "mission_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "website_ASC"
  | "website_DESC";

export type IdentityProvider = "FACEBOOK" | "GOOGLE";

export type DotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "action_ASC"
  | "action_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "total_ASC"
  | "total_DESC";

export type PreferencesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "allowDonationEmails_ASC"
  | "allowDonationEmails_DESC"
  | "publicProfile_ASC"
  | "publicProfile_DESC";

export type CircleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "open_ASC"
  | "open_DESC";

export type FundsOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "amountAdded_ASC"
  | "amountAdded_DESC"
  | "amountNet_ASC"
  | "amountNet_DESC"
  | "chargeID_ASC"
  | "chargeID_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "email_ASC"
  | "email_DESC"
  | "nameFirst_ASC"
  | "nameFirst_DESC"
  | "nameLast_ASC"
  | "nameLast_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "securityToken_ASC"
  | "securityToken_DESC"
  | "username_ASC"
  | "username_DESC";

export type LoopOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "count_ASC"
  | "count_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "goal_ASC"
  | "goal_DESC"
  | "multiplier_ASC"
  | "multiplier_DESC"
  | "specialEvent_ASC"
  | "specialEvent_DESC"
  | "specialEventDescription_ASC"
  | "specialEventDescription_DESC"
  | "specialEventName_ASC"
  | "specialEventName_DESC"
  | "sponsorName_ASC"
  | "sponsorName_DESC"
  | "sponsorWebsite_ASC"
  | "sponsorWebsite_DESC"
  | "startDate_ASC"
  | "startDate_DESC";

export type DonationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "batchKey_ASC"
  | "batchKey_DESC"
  | "subBalance_ASC"
  | "subBalance_DESC"
  | "transferID_ASC"
  | "transferID_DESC";

export type CircleJoinRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CircleInviteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HaloOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "key_ASC"
  | "key_DESC"
  | "tier_ASC"
  | "tier_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "balance_ASC"
  | "balance_DESC";

export type IdentityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "provider_ASC"
  | "provider_DESC"
  | "providerID_ASC"
  | "providerID_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface CircleUpdateOneRequiredWithoutInvitesInput {
  create?: Maybe<CircleCreateWithoutInvitesInput>;
  update?: Maybe<CircleUpdateWithoutInvitesDataInput>;
  upsert?: Maybe<CircleUpsertWithoutInvitesInput>;
  connect?: Maybe<CircleWhereUniqueInput>;
}

export type CharityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  ein?: Maybe<String>;
}>;

export interface CircleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  open?: Maybe<Boolean>;
  open_not?: Maybe<Boolean>;
  AND?: Maybe<CircleScalarWhereInput[] | CircleScalarWhereInput>;
  OR?: Maybe<CircleScalarWhereInput[] | CircleScalarWhereInput>;
  NOT?: Maybe<CircleScalarWhereInput[] | CircleScalarWhereInput>;
}

export interface LoopWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  count?: Maybe<Int>;
  count_not?: Maybe<Int>;
  count_in?: Maybe<Int[] | Int>;
  count_not_in?: Maybe<Int[] | Int>;
  count_lt?: Maybe<Int>;
  count_lte?: Maybe<Int>;
  count_gt?: Maybe<Int>;
  count_gte?: Maybe<Int>;
  event?: Maybe<EventWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<LoopWhereInput[] | LoopWhereInput>;
  OR?: Maybe<LoopWhereInput[] | LoopWhereInput>;
  NOT?: Maybe<LoopWhereInput[] | LoopWhereInput>;
}

export interface CircleUpdateManyWithWhereNestedInput {
  where: CircleScalarWhereInput;
  data: CircleUpdateManyDataInput;
}

export interface TransactionWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  balance?: Maybe<Int>;
  balance_not?: Maybe<Int>;
  balance_in?: Maybe<Int[] | Int>;
  balance_not_in?: Maybe<Int[] | Int>;
  balance_lt?: Maybe<Int>;
  balance_lte?: Maybe<Int>;
  balance_gt?: Maybe<Int>;
  balance_gte?: Maybe<Int>;
  donations_every?: Maybe<DonationWhereInput>;
  donations_some?: Maybe<DonationWhereInput>;
  donations_none?: Maybe<DonationWhereInput>;
  funds?: Maybe<FundsWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  OR?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  NOT?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
}

export interface CircleUpdateManyDataInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
}

export interface FundsWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  amountAdded?: Maybe<Int>;
  amountAdded_not?: Maybe<Int>;
  amountAdded_in?: Maybe<Int[] | Int>;
  amountAdded_not_in?: Maybe<Int[] | Int>;
  amountAdded_lt?: Maybe<Int>;
  amountAdded_lte?: Maybe<Int>;
  amountAdded_gt?: Maybe<Int>;
  amountAdded_gte?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  amountNet_not?: Maybe<Int>;
  amountNet_in?: Maybe<Int[] | Int>;
  amountNet_not_in?: Maybe<Int[] | Int>;
  amountNet_lt?: Maybe<Int>;
  amountNet_lte?: Maybe<Int>;
  amountNet_gt?: Maybe<Int>;
  amountNet_gte?: Maybe<Int>;
  chargeID?: Maybe<String>;
  chargeID_not?: Maybe<String>;
  chargeID_in?: Maybe<String[] | String>;
  chargeID_not_in?: Maybe<String[] | String>;
  chargeID_lt?: Maybe<String>;
  chargeID_lte?: Maybe<String>;
  chargeID_gt?: Maybe<String>;
  chargeID_gte?: Maybe<String>;
  chargeID_contains?: Maybe<String>;
  chargeID_not_contains?: Maybe<String>;
  chargeID_starts_with?: Maybe<String>;
  chargeID_not_starts_with?: Maybe<String>;
  chargeID_ends_with?: Maybe<String>;
  chargeID_not_ends_with?: Maybe<String>;
  donations_every?: Maybe<DonationWhereInput>;
  donations_some?: Maybe<DonationWhereInput>;
  donations_none?: Maybe<DonationWhereInput>;
  transaction?: Maybe<TransactionWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<FundsWhereInput[] | FundsWhereInput>;
  OR?: Maybe<FundsWhereInput[] | FundsWhereInput>;
  NOT?: Maybe<FundsWhereInput[] | FundsWhereInput>;
}

export interface FundsUpdateWithoutDonationsDataInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutFundsInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutFundsInput>;
}

export interface UserCreateOneWithoutDotsInput {
  create?: Maybe<UserCreateWithoutDotsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TransactionUpdateOneRequiredWithoutFundsInput {
  create?: Maybe<TransactionCreateWithoutFundsInput>;
  update?: Maybe<TransactionUpdateWithoutFundsDataInput>;
  upsert?: Maybe<TransactionUpsertWithoutFundsInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface DotUpdateManyWithoutUserInput {
  create?: Maybe<DotCreateWithoutUserInput[] | DotCreateWithoutUserInput>;
  delete?: Maybe<DotWhereUniqueInput[] | DotWhereUniqueInput>;
  connect?: Maybe<DotWhereUniqueInput[] | DotWhereUniqueInput>;
  set?: Maybe<DotWhereUniqueInput[] | DotWhereUniqueInput>;
  disconnect?: Maybe<DotWhereUniqueInput[] | DotWhereUniqueInput>;
  update?: Maybe<
    | DotUpdateWithWhereUniqueWithoutUserInput[]
    | DotUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | DotUpsertWithWhereUniqueWithoutUserInput[]
    | DotUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<DotScalarWhereInput[] | DotScalarWhereInput>;
  updateMany?: Maybe<
    DotUpdateManyWithWhereNestedInput[] | DotUpdateManyWithWhereNestedInput
  >;
}

export interface TransactionUpdateWithoutFundsDataInput {
  balance?: Maybe<Int>;
  donations?: Maybe<DonationUpdateManyWithoutTransactionInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TransactionWhereInput>;
  AND?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  OR?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
}

export interface DonationUpdateManyWithoutTransactionInput {
  create?: Maybe<
    | DonationCreateWithoutTransactionInput[]
    | DonationCreateWithoutTransactionInput
  >;
  delete?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  connect?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  set?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  disconnect?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  update?: Maybe<
    | DonationUpdateWithWhereUniqueWithoutTransactionInput[]
    | DonationUpdateWithWhereUniqueWithoutTransactionInput
  >;
  upsert?: Maybe<
    | DonationUpsertWithWhereUniqueWithoutTransactionInput[]
    | DonationUpsertWithWhereUniqueWithoutTransactionInput
  >;
  deleteMany?: Maybe<DonationScalarWhereInput[] | DonationScalarWhereInput>;
  updateMany?: Maybe<
    | DonationUpdateManyWithWhereNestedInput[]
    | DonationUpdateManyWithWhereNestedInput
  >;
}

export interface LoopSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LoopWhereInput>;
  AND?: Maybe<LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput>;
  OR?: Maybe<LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput>;
  NOT?: Maybe<LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput>;
}

export interface DonationUpdateWithWhereUniqueWithoutTransactionInput {
  where: DonationWhereUniqueInput;
  data: DonationUpdateWithoutTransactionDataInput;
}

export interface IdentitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IdentityWhereInput>;
  AND?: Maybe<
    IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput
  >;
  OR?: Maybe<IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput>;
  NOT?: Maybe<
    IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput
  >;
}

export interface DonationUpdateWithoutTransactionDataInput {
  amount?: Maybe<Int>;
  batchKey?: Maybe<String>;
  subBalance?: Maybe<Int>;
  transferID?: Maybe<String>;
  event?: Maybe<EventUpdateOneWithoutDonationsInput>;
  source?: Maybe<FundsUpdateOneWithoutDonationsInput>;
}

export interface CircleInviteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  circle?: Maybe<CircleWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<CircleInviteWhereInput[] | CircleInviteWhereInput>;
  OR?: Maybe<CircleInviteWhereInput[] | CircleInviteWhereInput>;
  NOT?: Maybe<CircleInviteWhereInput[] | CircleInviteWhereInput>;
}

export interface EventUpdateOneWithoutDonationsInput {
  create?: Maybe<EventCreateWithoutDonationsInput>;
  update?: Maybe<EventUpdateWithoutDonationsDataInput>;
  upsert?: Maybe<EventUpsertWithoutDonationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface EventUpdateWithoutDonationsDataInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  charity?: Maybe<CharityUpdateOneRequiredWithoutEventsInput>;
}

export interface CircleJoinRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  circle?: Maybe<CircleWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<CircleJoinRequestWhereInput[] | CircleJoinRequestWhereInput>;
  OR?: Maybe<CircleJoinRequestWhereInput[] | CircleJoinRequestWhereInput>;
  NOT?: Maybe<CircleJoinRequestWhereInput[] | CircleJoinRequestWhereInput>;
}

export interface CharityUpdateOneRequiredWithoutEventsInput {
  create?: Maybe<CharityCreateWithoutEventsInput>;
  update?: Maybe<CharityUpdateWithoutEventsDataInput>;
  upsert?: Maybe<CharityUpsertWithoutEventsInput>;
  connect?: Maybe<CharityWhereUniqueInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameFirst_not?: Maybe<String>;
  nameFirst_in?: Maybe<String[] | String>;
  nameFirst_not_in?: Maybe<String[] | String>;
  nameFirst_lt?: Maybe<String>;
  nameFirst_lte?: Maybe<String>;
  nameFirst_gt?: Maybe<String>;
  nameFirst_gte?: Maybe<String>;
  nameFirst_contains?: Maybe<String>;
  nameFirst_not_contains?: Maybe<String>;
  nameFirst_starts_with?: Maybe<String>;
  nameFirst_not_starts_with?: Maybe<String>;
  nameFirst_ends_with?: Maybe<String>;
  nameFirst_not_ends_with?: Maybe<String>;
  nameLast?: Maybe<String>;
  nameLast_not?: Maybe<String>;
  nameLast_in?: Maybe<String[] | String>;
  nameLast_not_in?: Maybe<String[] | String>;
  nameLast_lt?: Maybe<String>;
  nameLast_lte?: Maybe<String>;
  nameLast_gt?: Maybe<String>;
  nameLast_gte?: Maybe<String>;
  nameLast_contains?: Maybe<String>;
  nameLast_not_contains?: Maybe<String>;
  nameLast_starts_with?: Maybe<String>;
  nameLast_not_starts_with?: Maybe<String>;
  nameLast_ends_with?: Maybe<String>;
  nameLast_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  securityToken?: Maybe<Int>;
  securityToken_not?: Maybe<Int>;
  securityToken_in?: Maybe<Int[] | Int>;
  securityToken_not_in?: Maybe<Int[] | Int>;
  securityToken_lt?: Maybe<Int>;
  securityToken_lte?: Maybe<Int>;
  securityToken_gt?: Maybe<Int>;
  securityToken_gte?: Maybe<Int>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  circleJoinRequests_every?: Maybe<CircleJoinRequestWhereInput>;
  circleJoinRequests_some?: Maybe<CircleJoinRequestWhereInput>;
  circleJoinRequests_none?: Maybe<CircleJoinRequestWhereInput>;
  circleInvites_every?: Maybe<CircleInviteWhereInput>;
  circleInvites_some?: Maybe<CircleInviteWhereInput>;
  circleInvites_none?: Maybe<CircleInviteWhereInput>;
  circles_every?: Maybe<CircleWhereInput>;
  circles_some?: Maybe<CircleWhereInput>;
  circles_none?: Maybe<CircleWhereInput>;
  circlesOwned_every?: Maybe<CircleWhereInput>;
  circlesOwned_some?: Maybe<CircleWhereInput>;
  circlesOwned_none?: Maybe<CircleWhereInput>;
  dots_every?: Maybe<DotWhereInput>;
  dots_some?: Maybe<DotWhereInput>;
  dots_none?: Maybe<DotWhereInput>;
  followedCharities_every?: Maybe<CharityWhereInput>;
  followedCharities_some?: Maybe<CharityWhereInput>;
  followedCharities_none?: Maybe<CharityWhereInput>;
  halos_every?: Maybe<HaloWhereInput>;
  halos_some?: Maybe<HaloWhereInput>;
  halos_none?: Maybe<HaloWhereInput>;
  identity?: Maybe<IdentityWhereInput>;
  loops_every?: Maybe<LoopWhereInput>;
  loops_some?: Maybe<LoopWhereInput>;
  loops_none?: Maybe<LoopWhereInput>;
  preferences?: Maybe<PreferencesWhereInput>;
  transactions_every?: Maybe<TransactionWhereInput>;
  transactions_some?: Maybe<TransactionWhereInput>;
  transactions_none?: Maybe<TransactionWhereInput>;
  funds_every?: Maybe<FundsWhereInput>;
  funds_some?: Maybe<FundsWhereInput>;
  funds_none?: Maybe<FundsWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CharityUpdateWithoutEventsDataInput {
  acronym?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  followers?: Maybe<UserUpdateManyWithoutFollowedCharitiesInput>;
}

export interface DonationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DonationWhereInput>;
  AND?: Maybe<
    DonationSubscriptionWhereInput[] | DonationSubscriptionWhereInput
  >;
  OR?: Maybe<DonationSubscriptionWhereInput[] | DonationSubscriptionWhereInput>;
  NOT?: Maybe<
    DonationSubscriptionWhereInput[] | DonationSubscriptionWhereInput
  >;
}

export interface UserUpdateManyWithoutFollowedCharitiesInput {
  create?: Maybe<
    | UserCreateWithoutFollowedCharitiesInput[]
    | UserCreateWithoutFollowedCharitiesInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput[]
    | UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput[]
    | UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface CircleInviteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CircleInviteWhereInput>;
  AND?: Maybe<
    CircleInviteSubscriptionWhereInput[] | CircleInviteSubscriptionWhereInput
  >;
  OR?: Maybe<
    CircleInviteSubscriptionWhereInput[] | CircleInviteSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CircleInviteSubscriptionWhereInput[] | CircleInviteSubscriptionWhereInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFollowedCharitiesDataInput;
}

export interface CharitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CharityWhereInput>;
  AND?: Maybe<CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput>;
  OR?: Maybe<CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput>;
  NOT?: Maybe<CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput>;
}

export interface UserUpdateWithoutFollowedCharitiesDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
}

export interface CircleJoinRequestUpdateManyWithoutUserInput {
  create?: Maybe<
    | CircleJoinRequestCreateWithoutUserInput[]
    | CircleJoinRequestCreateWithoutUserInput
  >;
  delete?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  connect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  set?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  update?: Maybe<
    | CircleJoinRequestUpdateWithWhereUniqueWithoutUserInput[]
    | CircleJoinRequestUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CircleJoinRequestUpsertWithWhereUniqueWithoutUserInput[]
    | CircleJoinRequestUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput
  >;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface CircleJoinRequestUpdateWithWhereUniqueWithoutUserInput {
  where: CircleJoinRequestWhereUniqueInput;
  data: CircleJoinRequestUpdateWithoutUserDataInput;
}

export interface TransactionUpdateInput {
  balance?: Maybe<Int>;
  donations?: Maybe<DonationUpdateManyWithoutTransactionInput>;
  funds?: Maybe<FundsUpdateOneWithoutTransactionInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
}

export interface CircleJoinRequestUpdateWithoutUserDataInput {
  circle?: Maybe<CircleUpdateOneRequiredWithoutJoinRequestsInput>;
}

export interface TransactionCreateInput {
  id?: Maybe<Int>;
  balance: Int;
  donations?: Maybe<DonationCreateManyWithoutTransactionInput>;
  funds?: Maybe<FundsCreateOneWithoutTransactionInput>;
  user: UserCreateOneWithoutTransactionsInput;
}

export interface CircleUpdateOneRequiredWithoutJoinRequestsInput {
  create?: Maybe<CircleCreateWithoutJoinRequestsInput>;
  update?: Maybe<CircleUpdateWithoutJoinRequestsDataInput>;
  upsert?: Maybe<CircleUpsertWithoutJoinRequestsInput>;
  connect?: Maybe<CircleWhereUniqueInput>;
}

export interface UserUpsertWithoutPreferencesInput {
  update: UserUpdateWithoutPreferencesDataInput;
  create: UserCreateWithoutPreferencesInput;
}

export interface CircleUpdateWithoutJoinRequestsDataInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
  invites?: Maybe<CircleInviteUpdateManyWithoutCircleInput>;
  members?: Maybe<UserUpdateManyWithoutCirclesInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutCirclesOwnedInput>;
}

export interface UserUpdateWithoutPreferencesDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface CircleInviteUpdateManyWithoutCircleInput {
  create?: Maybe<
    | CircleInviteCreateWithoutCircleInput[]
    | CircleInviteCreateWithoutCircleInput
  >;
  delete?: Maybe<CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput>;
  connect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
  set?: Maybe<CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput>;
  disconnect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
  update?: Maybe<
    | CircleInviteUpdateWithWhereUniqueWithoutCircleInput[]
    | CircleInviteUpdateWithWhereUniqueWithoutCircleInput
  >;
  upsert?: Maybe<
    | CircleInviteUpsertWithWhereUniqueWithoutCircleInput[]
    | CircleInviteUpsertWithWhereUniqueWithoutCircleInput
  >;
  deleteMany?: Maybe<
    CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput
  >;
}

export interface PreferencesUpdateInput {
  allowDonationEmails?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneRequiredWithoutPreferencesInput>;
}

export interface CircleInviteUpdateWithWhereUniqueWithoutCircleInput {
  where: CircleInviteWhereUniqueInput;
  data: CircleInviteUpdateWithoutCircleDataInput;
}

export interface UserCreateWithoutPreferencesInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface CircleInviteUpdateWithoutCircleDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutCircleInvitesInput>;
}

export interface PreferencesCreateInput {
  id?: Maybe<ID_Input>;
  allowDonationEmails?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
  user: UserCreateOneWithoutPreferencesInput;
}

export interface UserUpdateOneRequiredWithoutCircleInvitesInput {
  create?: Maybe<UserCreateWithoutCircleInvitesInput>;
  update?: Maybe<UserUpdateWithoutCircleInvitesDataInput>;
  upsert?: Maybe<UserUpsertWithoutCircleInvitesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface LoopUpdateManyMutationInput {
  count?: Maybe<Int>;
}

export interface UserUpdateWithoutCircleInvitesDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface UserUpdateWithoutLoopsDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface CircleUpdateManyWithoutMembersInput {
  create?: Maybe<
    CircleCreateWithoutMembersInput[] | CircleCreateWithoutMembersInput
  >;
  delete?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  connect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  set?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  disconnect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  update?: Maybe<
    | CircleUpdateWithWhereUniqueWithoutMembersInput[]
    | CircleUpdateWithWhereUniqueWithoutMembersInput
  >;
  upsert?: Maybe<
    | CircleUpsertWithWhereUniqueWithoutMembersInput[]
    | CircleUpsertWithWhereUniqueWithoutMembersInput
  >;
  deleteMany?: Maybe<CircleScalarWhereInput[] | CircleScalarWhereInput>;
  updateMany?: Maybe<
    | CircleUpdateManyWithWhereNestedInput[]
    | CircleUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateOneRequiredWithoutLoopsInput {
  create?: Maybe<UserCreateWithoutLoopsInput>;
  update?: Maybe<UserUpdateWithoutLoopsDataInput>;
  upsert?: Maybe<UserUpsertWithoutLoopsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleUpdateWithWhereUniqueWithoutMembersInput {
  where: CircleWhereUniqueInput;
  data: CircleUpdateWithoutMembersDataInput;
}

export interface UserCreateWithoutLoopsInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface CircleUpdateWithoutMembersDataInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteUpdateManyWithoutCircleInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutCirclesOwnedInput>;
}

export interface UserCreateOneWithoutLoopsInput {
  create?: Maybe<UserCreateWithoutLoopsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleJoinRequestUpdateManyWithoutCircleInput {
  create?: Maybe<
    | CircleJoinRequestCreateWithoutCircleInput[]
    | CircleJoinRequestCreateWithoutCircleInput
  >;
  delete?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  connect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  set?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  update?: Maybe<
    | CircleJoinRequestUpdateWithWhereUniqueWithoutCircleInput[]
    | CircleJoinRequestUpdateWithWhereUniqueWithoutCircleInput
  >;
  upsert?: Maybe<
    | CircleJoinRequestUpsertWithWhereUniqueWithoutCircleInput[]
    | CircleJoinRequestUpsertWithWhereUniqueWithoutCircleInput
  >;
  deleteMany?: Maybe<
    CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput
  >;
}

export interface IdentityUpdateManyMutationInput {
  provider?: Maybe<IdentityProvider>;
  providerID?: Maybe<String>;
}

export interface CircleJoinRequestUpdateWithWhereUniqueWithoutCircleInput {
  where: CircleJoinRequestWhereUniqueInput;
  data: CircleJoinRequestUpdateWithoutCircleDataInput;
}

export interface UserUpsertWithoutIdentityInput {
  update: UserUpdateWithoutIdentityDataInput;
  create: UserCreateWithoutIdentityInput;
}

export interface CircleJoinRequestUpdateWithoutCircleDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutCircleJoinRequestsInput>;
}

export interface UserUpdateOneRequiredWithoutIdentityInput {
  create?: Maybe<UserCreateWithoutIdentityInput>;
  update?: Maybe<UserUpdateWithoutIdentityDataInput>;
  upsert?: Maybe<UserUpsertWithoutIdentityInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutCircleJoinRequestsInput {
  create?: Maybe<UserCreateWithoutCircleJoinRequestsInput>;
  update?: Maybe<UserUpdateWithoutCircleJoinRequestsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCircleJoinRequestsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface IdentityUpdateInput {
  provider?: Maybe<IdentityProvider>;
  providerID?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutIdentityInput>;
}

export interface UserUpdateWithoutCircleJoinRequestsDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface UserCreateOneWithoutIdentityInput {
  create?: Maybe<UserCreateWithoutIdentityInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleInviteUpdateManyWithoutUserInput {
  create?: Maybe<
    CircleInviteCreateWithoutUserInput[] | CircleInviteCreateWithoutUserInput
  >;
  delete?: Maybe<CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput>;
  connect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
  set?: Maybe<CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput>;
  disconnect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
  update?: Maybe<
    | CircleInviteUpdateWithWhereUniqueWithoutUserInput[]
    | CircleInviteUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CircleInviteUpsertWithWhereUniqueWithoutUserInput[]
    | CircleInviteUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput
  >;
}

export interface IdentityCreateInput {
  id?: Maybe<ID_Input>;
  provider: IdentityProvider;
  providerID: String;
  user: UserCreateOneWithoutIdentityInput;
}

export interface CircleInviteUpdateWithWhereUniqueWithoutUserInput {
  where: CircleInviteWhereUniqueInput;
  data: CircleInviteUpdateWithoutUserDataInput;
}

export interface UserUpsertWithoutHalosInput {
  update: UserUpdateWithoutHalosDataInput;
  create: UserCreateWithoutHalosInput;
}

export interface CircleInviteUpdateWithoutUserDataInput {
  circle?: Maybe<CircleUpdateOneRequiredWithoutInvitesInput>;
}

export type LoopWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneRequiredWithoutDotsInput {
  create?: Maybe<UserCreateWithoutDotsInput>;
  update?: Maybe<UserUpdateWithoutDotsDataInput>;
  upsert?: Maybe<UserUpsertWithoutDotsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface HaloUpdateInput {
  key?: Maybe<String>;
  tier?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutHalosInput>;
}

export interface CircleUpdateWithoutInvitesDataInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutCircleInput>;
  members?: Maybe<UserUpdateManyWithoutCirclesInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutCirclesOwnedInput>;
}

export type PreferencesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateManyWithoutCirclesInput {
  create?: Maybe<
    UserCreateWithoutCirclesInput[] | UserCreateWithoutCirclesInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutCirclesInput[]
    | UserUpdateWithWhereUniqueWithoutCirclesInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutCirclesInput[]
    | UserUpsertWithWhereUniqueWithoutCirclesInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface HaloCreateInput {
  id?: Maybe<ID_Input>;
  key: String;
  tier?: Maybe<String>;
  user: UserCreateOneWithoutHalosInput;
}

export interface UserUpdateWithWhereUniqueWithoutCirclesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCirclesDataInput;
}

export interface FundsUpdateInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
  donations?: Maybe<DonationUpdateManyWithoutSourceInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutFundsInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutFundsInput>;
}

export interface UserUpdateWithoutCirclesDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface FundsCreateInput {
  id?: Maybe<ID_Input>;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
  donations?: Maybe<DonationCreateManyWithoutSourceInput>;
  transaction: TransactionCreateOneWithoutFundsInput;
  user: UserCreateOneWithoutFundsInput;
}

export interface CircleUpdateManyWithoutOwnerInput {
  create?: Maybe<
    CircleCreateWithoutOwnerInput[] | CircleCreateWithoutOwnerInput
  >;
  delete?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  connect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  set?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  disconnect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  update?: Maybe<
    | CircleUpdateWithWhereUniqueWithoutOwnerInput[]
    | CircleUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | CircleUpsertWithWhereUniqueWithoutOwnerInput[]
    | CircleUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<CircleScalarWhereInput[] | CircleScalarWhereInput>;
  updateMany?: Maybe<
    | CircleUpdateManyWithWhereNestedInput[]
    | CircleUpdateManyWithWhereNestedInput
  >;
}

export interface EventUpdateInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  charity?: Maybe<CharityUpdateOneRequiredWithoutEventsInput>;
  donations?: Maybe<DonationUpdateManyWithoutEventInput>;
}

export interface CircleUpdateWithWhereUniqueWithoutOwnerInput {
  where: CircleWhereUniqueInput;
  data: CircleUpdateWithoutOwnerDataInput;
}

export interface DotUpdateManyMutationInput {
  action?: Maybe<String>;
  amount?: Maybe<Int>;
  total?: Maybe<Int>;
}

export interface CircleUpdateWithoutOwnerDataInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteUpdateManyWithoutCircleInput>;
  members?: Maybe<UserUpdateManyWithoutCirclesInput>;
}

export interface UserUpdateWithoutDotsDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface CircleUpsertWithWhereUniqueWithoutOwnerInput {
  where: CircleWhereUniqueInput;
  update: CircleUpdateWithoutOwnerDataInput;
  create: CircleCreateWithoutOwnerInput;
}

export interface CharityCreateInput {
  id?: Maybe<ID_Input>;
  acronym?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein: String;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
  events?: Maybe<EventCreateManyWithoutCharityInput>;
  followers?: Maybe<UserCreateManyWithoutFollowedCharitiesInput>;
}

export interface PreferencesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  allowDonationEmails?: Maybe<Boolean>;
  allowDonationEmails_not?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
  publicProfile_not?: Maybe<Boolean>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<PreferencesWhereInput[] | PreferencesWhereInput>;
  OR?: Maybe<PreferencesWhereInput[] | PreferencesWhereInput>;
  NOT?: Maybe<PreferencesWhereInput[] | PreferencesWhereInput>;
}

export interface EventCreateWithoutCharityInput {
  id?: Maybe<ID_Input>;
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate: DateTimeInput;
  donations?: Maybe<DonationCreateManyWithoutEventInput>;
}

export interface DonationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  batchKey?: Maybe<String>;
  batchKey_not?: Maybe<String>;
  batchKey_in?: Maybe<String[] | String>;
  batchKey_not_in?: Maybe<String[] | String>;
  batchKey_lt?: Maybe<String>;
  batchKey_lte?: Maybe<String>;
  batchKey_gt?: Maybe<String>;
  batchKey_gte?: Maybe<String>;
  batchKey_contains?: Maybe<String>;
  batchKey_not_contains?: Maybe<String>;
  batchKey_starts_with?: Maybe<String>;
  batchKey_not_starts_with?: Maybe<String>;
  batchKey_ends_with?: Maybe<String>;
  batchKey_not_ends_with?: Maybe<String>;
  subBalance?: Maybe<Int>;
  subBalance_not?: Maybe<Int>;
  subBalance_in?: Maybe<Int[] | Int>;
  subBalance_not_in?: Maybe<Int[] | Int>;
  subBalance_lt?: Maybe<Int>;
  subBalance_lte?: Maybe<Int>;
  subBalance_gt?: Maybe<Int>;
  subBalance_gte?: Maybe<Int>;
  transferID?: Maybe<String>;
  transferID_not?: Maybe<String>;
  transferID_in?: Maybe<String[] | String>;
  transferID_not_in?: Maybe<String[] | String>;
  transferID_lt?: Maybe<String>;
  transferID_lte?: Maybe<String>;
  transferID_gt?: Maybe<String>;
  transferID_gte?: Maybe<String>;
  transferID_contains?: Maybe<String>;
  transferID_not_contains?: Maybe<String>;
  transferID_starts_with?: Maybe<String>;
  transferID_not_starts_with?: Maybe<String>;
  transferID_ends_with?: Maybe<String>;
  transferID_not_ends_with?: Maybe<String>;
  event?: Maybe<EventWhereInput>;
  source?: Maybe<FundsWhereInput>;
  transaction?: Maybe<TransactionWhereInput>;
  AND?: Maybe<DonationWhereInput[] | DonationWhereInput>;
  OR?: Maybe<DonationWhereInput[] | DonationWhereInput>;
  NOT?: Maybe<DonationWhereInput[] | DonationWhereInput>;
}

export interface DonationCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  amount: Int;
  batchKey: String;
  subBalance: Int;
  transferID: String;
  source?: Maybe<FundsCreateOneWithoutDonationsInput>;
  transaction: TransactionCreateOneWithoutDonationsInput;
}

export interface IdentityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  provider?: Maybe<IdentityProvider>;
  provider_not?: Maybe<IdentityProvider>;
  provider_in?: Maybe<IdentityProvider[] | IdentityProvider>;
  provider_not_in?: Maybe<IdentityProvider[] | IdentityProvider>;
  providerID?: Maybe<String>;
  providerID_not?: Maybe<String>;
  providerID_in?: Maybe<String[] | String>;
  providerID_not_in?: Maybe<String[] | String>;
  providerID_lt?: Maybe<String>;
  providerID_lte?: Maybe<String>;
  providerID_gt?: Maybe<String>;
  providerID_gte?: Maybe<String>;
  providerID_contains?: Maybe<String>;
  providerID_not_contains?: Maybe<String>;
  providerID_starts_with?: Maybe<String>;
  providerID_not_starts_with?: Maybe<String>;
  providerID_ends_with?: Maybe<String>;
  providerID_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<IdentityWhereInput[] | IdentityWhereInput>;
  OR?: Maybe<IdentityWhereInput[] | IdentityWhereInput>;
  NOT?: Maybe<IdentityWhereInput[] | IdentityWhereInput>;
}

export interface FundsCreateWithoutDonationsInput {
  id?: Maybe<ID_Input>;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
  transaction: TransactionCreateOneWithoutFundsInput;
  user: UserCreateOneWithoutFundsInput;
}

export interface HaloWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  tier?: Maybe<String>;
  tier_not?: Maybe<String>;
  tier_in?: Maybe<String[] | String>;
  tier_not_in?: Maybe<String[] | String>;
  tier_lt?: Maybe<String>;
  tier_lte?: Maybe<String>;
  tier_gt?: Maybe<String>;
  tier_gte?: Maybe<String>;
  tier_contains?: Maybe<String>;
  tier_not_contains?: Maybe<String>;
  tier_starts_with?: Maybe<String>;
  tier_not_starts_with?: Maybe<String>;
  tier_ends_with?: Maybe<String>;
  tier_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<HaloWhereInput[] | HaloWhereInput>;
  OR?: Maybe<HaloWhereInput[] | HaloWhereInput>;
  NOT?: Maybe<HaloWhereInput[] | HaloWhereInput>;
}

export interface TransactionCreateWithoutFundsInput {
  id?: Maybe<Int>;
  balance: Int;
  donations?: Maybe<DonationCreateManyWithoutTransactionInput>;
  user: UserCreateOneWithoutTransactionsInput;
}

export interface DotUpdateWithWhereUniqueWithoutUserInput {
  where: DotWhereUniqueInput;
  data: DotUpdateWithoutUserDataInput;
}

export interface DonationCreateWithoutTransactionInput {
  id?: Maybe<ID_Input>;
  amount: Int;
  batchKey: String;
  subBalance: Int;
  transferID: String;
  event?: Maybe<EventCreateOneWithoutDonationsInput>;
  source?: Maybe<FundsCreateOneWithoutDonationsInput>;
}

export interface DotUpdateWithoutUserDataInput {
  action?: Maybe<String>;
  amount?: Maybe<Int>;
  total?: Maybe<Int>;
}

export interface EventCreateWithoutDonationsInput {
  id?: Maybe<ID_Input>;
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate: DateTimeInput;
  charity: CharityCreateOneWithoutEventsInput;
}

export interface DotUpsertWithWhereUniqueWithoutUserInput {
  where: DotWhereUniqueInput;
  update: DotUpdateWithoutUserDataInput;
  create: DotCreateWithoutUserInput;
}

export interface CharityCreateWithoutEventsInput {
  id?: Maybe<ID_Input>;
  acronym?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein: String;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
  followers?: Maybe<UserCreateManyWithoutFollowedCharitiesInput>;
}

export interface DotScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  action?: Maybe<String>;
  action_not?: Maybe<String>;
  action_in?: Maybe<String[] | String>;
  action_not_in?: Maybe<String[] | String>;
  action_lt?: Maybe<String>;
  action_lte?: Maybe<String>;
  action_gt?: Maybe<String>;
  action_gte?: Maybe<String>;
  action_contains?: Maybe<String>;
  action_not_contains?: Maybe<String>;
  action_starts_with?: Maybe<String>;
  action_not_starts_with?: Maybe<String>;
  action_ends_with?: Maybe<String>;
  action_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  total?: Maybe<Int>;
  total_not?: Maybe<Int>;
  total_in?: Maybe<Int[] | Int>;
  total_not_in?: Maybe<Int[] | Int>;
  total_lt?: Maybe<Int>;
  total_lte?: Maybe<Int>;
  total_gt?: Maybe<Int>;
  total_gte?: Maybe<Int>;
  AND?: Maybe<DotScalarWhereInput[] | DotScalarWhereInput>;
  OR?: Maybe<DotScalarWhereInput[] | DotScalarWhereInput>;
  NOT?: Maybe<DotScalarWhereInput[] | DotScalarWhereInput>;
}

export interface UserCreateWithoutFollowedCharitiesInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface DotUpdateManyWithWhereNestedInput {
  where: DotScalarWhereInput;
  data: DotUpdateManyDataInput;
}

export interface CircleJoinRequestCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  circle: CircleCreateOneWithoutJoinRequestsInput;
}

export interface DotUpdateManyDataInput {
  action?: Maybe<String>;
  amount?: Maybe<Int>;
  total?: Maybe<Int>;
}

export interface CircleCreateWithoutJoinRequestsInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  name: String;
  open?: Maybe<Boolean>;
  invites?: Maybe<CircleInviteCreateManyWithoutCircleInput>;
  members?: Maybe<UserCreateManyWithoutCirclesInput>;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface CharityUpdateManyWithoutFollowersInput {
  create?: Maybe<
    CharityCreateWithoutFollowersInput[] | CharityCreateWithoutFollowersInput
  >;
  delete?: Maybe<CharityWhereUniqueInput[] | CharityWhereUniqueInput>;
  connect?: Maybe<CharityWhereUniqueInput[] | CharityWhereUniqueInput>;
  set?: Maybe<CharityWhereUniqueInput[] | CharityWhereUniqueInput>;
  disconnect?: Maybe<CharityWhereUniqueInput[] | CharityWhereUniqueInput>;
  update?: Maybe<
    | CharityUpdateWithWhereUniqueWithoutFollowersInput[]
    | CharityUpdateWithWhereUniqueWithoutFollowersInput
  >;
  upsert?: Maybe<
    | CharityUpsertWithWhereUniqueWithoutFollowersInput[]
    | CharityUpsertWithWhereUniqueWithoutFollowersInput
  >;
  deleteMany?: Maybe<CharityScalarWhereInput[] | CharityScalarWhereInput>;
  updateMany?: Maybe<
    | CharityUpdateManyWithWhereNestedInput[]
    | CharityUpdateManyWithWhereNestedInput
  >;
}

export interface CircleInviteCreateWithoutCircleInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutCircleInvitesInput;
}

export interface CharityUpdateWithWhereUniqueWithoutFollowersInput {
  where: CharityWhereUniqueInput;
  data: CharityUpdateWithoutFollowersDataInput;
}

export interface UserCreateWithoutCircleInvitesInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface CharityUpdateWithoutFollowersDataInput {
  acronym?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  events?: Maybe<EventUpdateManyWithoutCharityInput>;
}

export interface CircleCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  name: String;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestCreateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteCreateManyWithoutCircleInput>;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface CharityUpsertWithWhereUniqueWithoutFollowersInput {
  where: CharityWhereUniqueInput;
  update: CharityUpdateWithoutFollowersDataInput;
  create: CharityCreateWithoutFollowersInput;
}

export interface CircleJoinRequestCreateWithoutCircleInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutCircleJoinRequestsInput;
}

export interface CharityScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  acronym?: Maybe<String>;
  acronym_not?: Maybe<String>;
  acronym_in?: Maybe<String[] | String>;
  acronym_not_in?: Maybe<String[] | String>;
  acronym_lt?: Maybe<String>;
  acronym_lte?: Maybe<String>;
  acronym_gt?: Maybe<String>;
  acronym_gte?: Maybe<String>;
  acronym_contains?: Maybe<String>;
  acronym_not_contains?: Maybe<String>;
  acronym_starts_with?: Maybe<String>;
  acronym_not_starts_with?: Maybe<String>;
  acronym_ends_with?: Maybe<String>;
  acronym_not_ends_with?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  bannerCredit_not?: Maybe<String>;
  bannerCredit_in?: Maybe<String[] | String>;
  bannerCredit_not_in?: Maybe<String[] | String>;
  bannerCredit_lt?: Maybe<String>;
  bannerCredit_lte?: Maybe<String>;
  bannerCredit_gt?: Maybe<String>;
  bannerCredit_gte?: Maybe<String>;
  bannerCredit_contains?: Maybe<String>;
  bannerCredit_not_contains?: Maybe<String>;
  bannerCredit_starts_with?: Maybe<String>;
  bannerCredit_not_starts_with?: Maybe<String>;
  bannerCredit_ends_with?: Maybe<String>;
  bannerCredit_not_ends_with?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  connectedAccountID_not?: Maybe<String>;
  connectedAccountID_in?: Maybe<String[] | String>;
  connectedAccountID_not_in?: Maybe<String[] | String>;
  connectedAccountID_lt?: Maybe<String>;
  connectedAccountID_lte?: Maybe<String>;
  connectedAccountID_gt?: Maybe<String>;
  connectedAccountID_gte?: Maybe<String>;
  connectedAccountID_contains?: Maybe<String>;
  connectedAccountID_not_contains?: Maybe<String>;
  connectedAccountID_starts_with?: Maybe<String>;
  connectedAccountID_not_starts_with?: Maybe<String>;
  connectedAccountID_ends_with?: Maybe<String>;
  connectedAccountID_not_ends_with?: Maybe<String>;
  ein?: Maybe<String>;
  ein_not?: Maybe<String>;
  ein_in?: Maybe<String[] | String>;
  ein_not_in?: Maybe<String[] | String>;
  ein_lt?: Maybe<String>;
  ein_lte?: Maybe<String>;
  ein_gt?: Maybe<String>;
  ein_gte?: Maybe<String>;
  ein_contains?: Maybe<String>;
  ein_not_contains?: Maybe<String>;
  ein_starts_with?: Maybe<String>;
  ein_not_starts_with?: Maybe<String>;
  ein_ends_with?: Maybe<String>;
  ein_not_ends_with?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesAdministrative_not?: Maybe<Float>;
  expensesAdministrative_in?: Maybe<Float[] | Float>;
  expensesAdministrative_not_in?: Maybe<Float[] | Float>;
  expensesAdministrative_lt?: Maybe<Float>;
  expensesAdministrative_lte?: Maybe<Float>;
  expensesAdministrative_gt?: Maybe<Float>;
  expensesAdministrative_gte?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesFundraising_not?: Maybe<Float>;
  expensesFundraising_in?: Maybe<Float[] | Float>;
  expensesFundraising_not_in?: Maybe<Float[] | Float>;
  expensesFundraising_lt?: Maybe<Float>;
  expensesFundraising_lte?: Maybe<Float>;
  expensesFundraising_gt?: Maybe<Float>;
  expensesFundraising_gte?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesOther_not?: Maybe<Float>;
  expensesOther_in?: Maybe<Float[] | Float>;
  expensesOther_not_in?: Maybe<Float[] | Float>;
  expensesOther_lt?: Maybe<Float>;
  expensesOther_lte?: Maybe<Float>;
  expensesOther_gt?: Maybe<Float>;
  expensesOther_gte?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesProgram_not?: Maybe<Float>;
  expensesProgram_in?: Maybe<Float[] | Float>;
  expensesProgram_not_in?: Maybe<Float[] | Float>;
  expensesProgram_lt?: Maybe<Float>;
  expensesProgram_lte?: Maybe<Float>;
  expensesProgram_gt?: Maybe<Float>;
  expensesProgram_gte?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  expensesUpdated_not?: Maybe<String>;
  expensesUpdated_in?: Maybe<String[] | String>;
  expensesUpdated_not_in?: Maybe<String[] | String>;
  expensesUpdated_lt?: Maybe<String>;
  expensesUpdated_lte?: Maybe<String>;
  expensesUpdated_gt?: Maybe<String>;
  expensesUpdated_gte?: Maybe<String>;
  expensesUpdated_contains?: Maybe<String>;
  expensesUpdated_not_contains?: Maybe<String>;
  expensesUpdated_starts_with?: Maybe<String>;
  expensesUpdated_not_starts_with?: Maybe<String>;
  expensesUpdated_ends_with?: Maybe<String>;
  expensesUpdated_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  mission?: Maybe<String>;
  mission_not?: Maybe<String>;
  mission_in?: Maybe<String[] | String>;
  mission_not_in?: Maybe<String[] | String>;
  mission_lt?: Maybe<String>;
  mission_lte?: Maybe<String>;
  mission_gt?: Maybe<String>;
  mission_gte?: Maybe<String>;
  mission_contains?: Maybe<String>;
  mission_not_contains?: Maybe<String>;
  mission_starts_with?: Maybe<String>;
  mission_not_starts_with?: Maybe<String>;
  mission_ends_with?: Maybe<String>;
  mission_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  AND?: Maybe<CharityScalarWhereInput[] | CharityScalarWhereInput>;
  OR?: Maybe<CharityScalarWhereInput[] | CharityScalarWhereInput>;
  NOT?: Maybe<CharityScalarWhereInput[] | CharityScalarWhereInput>;
}

export interface UserCreateWithoutCircleJoinRequestsInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface CharityUpdateManyWithWhereNestedInput {
  where: CharityScalarWhereInput;
  data: CharityUpdateManyDataInput;
}

export interface CircleInviteCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  circle: CircleCreateOneWithoutInvitesInput;
}

export interface CharityUpdateManyDataInput {
  acronym?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
}

export interface CircleCreateWithoutInvitesInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  name: String;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestCreateManyWithoutCircleInput>;
  members?: Maybe<UserCreateManyWithoutCirclesInput>;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface HaloUpdateManyWithoutUserInput {
  create?: Maybe<HaloCreateWithoutUserInput[] | HaloCreateWithoutUserInput>;
  delete?: Maybe<HaloWhereUniqueInput[] | HaloWhereUniqueInput>;
  connect?: Maybe<HaloWhereUniqueInput[] | HaloWhereUniqueInput>;
  set?: Maybe<HaloWhereUniqueInput[] | HaloWhereUniqueInput>;
  disconnect?: Maybe<HaloWhereUniqueInput[] | HaloWhereUniqueInput>;
  update?: Maybe<
    | HaloUpdateWithWhereUniqueWithoutUserInput[]
    | HaloUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | HaloUpsertWithWhereUniqueWithoutUserInput[]
    | HaloUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<HaloScalarWhereInput[] | HaloScalarWhereInput>;
  updateMany?: Maybe<
    HaloUpdateManyWithWhereNestedInput[] | HaloUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateWithoutCirclesInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface HaloUpdateWithWhereUniqueWithoutUserInput {
  where: HaloWhereUniqueInput;
  data: HaloUpdateWithoutUserDataInput;
}

export interface CircleCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  name: String;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestCreateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteCreateManyWithoutCircleInput>;
  members?: Maybe<UserCreateManyWithoutCirclesInput>;
}

export interface HaloUpdateWithoutUserDataInput {
  key?: Maybe<String>;
  tier?: Maybe<String>;
}

export interface DotCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  action: String;
  amount: Int;
  total: Int;
}

export interface HaloUpsertWithWhereUniqueWithoutUserInput {
  where: HaloWhereUniqueInput;
  update: HaloUpdateWithoutUserDataInput;
  create: HaloCreateWithoutUserInput;
}

export interface CharityCreateWithoutFollowersInput {
  id?: Maybe<ID_Input>;
  acronym?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein: String;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
  events?: Maybe<EventCreateManyWithoutCharityInput>;
}

export interface HaloScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  tier?: Maybe<String>;
  tier_not?: Maybe<String>;
  tier_in?: Maybe<String[] | String>;
  tier_not_in?: Maybe<String[] | String>;
  tier_lt?: Maybe<String>;
  tier_lte?: Maybe<String>;
  tier_gt?: Maybe<String>;
  tier_gte?: Maybe<String>;
  tier_contains?: Maybe<String>;
  tier_not_contains?: Maybe<String>;
  tier_starts_with?: Maybe<String>;
  tier_not_starts_with?: Maybe<String>;
  tier_ends_with?: Maybe<String>;
  tier_not_ends_with?: Maybe<String>;
  AND?: Maybe<HaloScalarWhereInput[] | HaloScalarWhereInput>;
  OR?: Maybe<HaloScalarWhereInput[] | HaloScalarWhereInput>;
  NOT?: Maybe<HaloScalarWhereInput[] | HaloScalarWhereInput>;
}

export interface HaloCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  key: String;
  tier?: Maybe<String>;
}

export interface HaloUpdateManyWithWhereNestedInput {
  where: HaloScalarWhereInput;
  data: HaloUpdateManyDataInput;
}

export interface IdentityCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  provider: IdentityProvider;
  providerID: String;
}

export interface HaloUpdateManyDataInput {
  key?: Maybe<String>;
  tier?: Maybe<String>;
}

export interface LoopCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  count: Int;
  event: EventCreateOneInput;
}

export interface IdentityUpdateOneRequiredWithoutUserInput {
  create?: Maybe<IdentityCreateWithoutUserInput>;
  update?: Maybe<IdentityUpdateWithoutUserDataInput>;
  upsert?: Maybe<IdentityUpsertWithoutUserInput>;
  connect?: Maybe<IdentityWhereUniqueInput>;
}

export interface EventCreateInput {
  id?: Maybe<ID_Input>;
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate: DateTimeInput;
  charity: CharityCreateOneWithoutEventsInput;
  donations?: Maybe<DonationCreateManyWithoutEventInput>;
}

export interface IdentityUpdateWithoutUserDataInput {
  provider?: Maybe<IdentityProvider>;
  providerID?: Maybe<String>;
}

export interface PreferencesCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  allowDonationEmails?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
}

export interface IdentityUpsertWithoutUserInput {
  update: IdentityUpdateWithoutUserDataInput;
  create: IdentityCreateWithoutUserInput;
}

export interface TransactionCreateWithoutUserInput {
  id?: Maybe<Int>;
  balance: Int;
  donations?: Maybe<DonationCreateManyWithoutTransactionInput>;
  funds?: Maybe<FundsCreateOneWithoutTransactionInput>;
}

export interface LoopUpdateManyWithoutUserInput {
  create?: Maybe<LoopCreateWithoutUserInput[] | LoopCreateWithoutUserInput>;
  delete?: Maybe<LoopWhereUniqueInput[] | LoopWhereUniqueInput>;
  connect?: Maybe<LoopWhereUniqueInput[] | LoopWhereUniqueInput>;
  set?: Maybe<LoopWhereUniqueInput[] | LoopWhereUniqueInput>;
  disconnect?: Maybe<LoopWhereUniqueInput[] | LoopWhereUniqueInput>;
  update?: Maybe<
    | LoopUpdateWithWhereUniqueWithoutUserInput[]
    | LoopUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | LoopUpsertWithWhereUniqueWithoutUserInput[]
    | LoopUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<LoopScalarWhereInput[] | LoopScalarWhereInput>;
  updateMany?: Maybe<
    LoopUpdateManyWithWhereNestedInput[] | LoopUpdateManyWithWhereNestedInput
  >;
}

export interface FundsCreateWithoutTransactionInput {
  id?: Maybe<ID_Input>;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
  donations?: Maybe<DonationCreateManyWithoutSourceInput>;
  user: UserCreateOneWithoutFundsInput;
}

export interface LoopUpdateWithWhereUniqueWithoutUserInput {
  where: LoopWhereUniqueInput;
  data: LoopUpdateWithoutUserDataInput;
}

export interface DonationCreateWithoutSourceInput {
  id?: Maybe<ID_Input>;
  amount: Int;
  batchKey: String;
  subBalance: Int;
  transferID: String;
  event?: Maybe<EventCreateOneWithoutDonationsInput>;
  transaction: TransactionCreateOneWithoutDonationsInput;
}

export interface LoopUpdateWithoutUserDataInput {
  count?: Maybe<Int>;
  event?: Maybe<EventUpdateOneRequiredInput>;
}

export interface TransactionCreateWithoutDonationsInput {
  id?: Maybe<Int>;
  balance: Int;
  funds?: Maybe<FundsCreateOneWithoutTransactionInput>;
  user: UserCreateOneWithoutTransactionsInput;
}

export interface EventUpdateOneRequiredInput {
  create?: Maybe<EventCreateInput>;
  update?: Maybe<EventUpdateDataInput>;
  upsert?: Maybe<EventUpsertNestedInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface UserCreateWithoutTransactionsInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface EventUpdateDataInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  charity?: Maybe<CharityUpdateOneRequiredWithoutEventsInput>;
  donations?: Maybe<DonationUpdateManyWithoutEventInput>;
}

export interface FundsCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
  donations?: Maybe<DonationCreateManyWithoutSourceInput>;
  transaction: TransactionCreateOneWithoutFundsInput;
}

export interface EventUpsertNestedInput {
  update: EventUpdateDataInput;
  create: EventCreateInput;
}

export interface UserCreateWithoutFundsInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface LoopUpsertWithWhereUniqueWithoutUserInput {
  where: LoopWhereUniqueInput;
  update: LoopUpdateWithoutUserDataInput;
  create: LoopCreateWithoutUserInput;
}

export interface UserCreateWithoutCirclesOwnedInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface LoopScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  count?: Maybe<Int>;
  count_not?: Maybe<Int>;
  count_in?: Maybe<Int[] | Int>;
  count_not_in?: Maybe<Int[] | Int>;
  count_lt?: Maybe<Int>;
  count_lte?: Maybe<Int>;
  count_gt?: Maybe<Int>;
  count_gte?: Maybe<Int>;
  AND?: Maybe<LoopScalarWhereInput[] | LoopScalarWhereInput>;
  OR?: Maybe<LoopScalarWhereInput[] | LoopScalarWhereInput>;
  NOT?: Maybe<LoopScalarWhereInput[] | LoopScalarWhereInput>;
}

export interface EventUpdateManyWithoutCharityInput {
  create?: Maybe<
    EventCreateWithoutCharityInput[] | EventCreateWithoutCharityInput
  >;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutCharityInput[]
    | EventUpdateWithWhereUniqueWithoutCharityInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutCharityInput[]
    | EventUpsertWithWhereUniqueWithoutCharityInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface LoopUpdateManyWithWhereNestedInput {
  where: LoopScalarWhereInput;
  data: LoopUpdateManyDataInput;
}

export interface EventUpdateWithoutCharityDataInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  donations?: Maybe<DonationUpdateManyWithoutEventInput>;
}

export interface LoopUpdateManyDataInput {
  count?: Maybe<Int>;
}

export interface DonationUpdateWithWhereUniqueWithoutEventInput {
  where: DonationWhereUniqueInput;
  data: DonationUpdateWithoutEventDataInput;
}

export interface PreferencesUpdateOneRequiredWithoutUserInput {
  create?: Maybe<PreferencesCreateWithoutUserInput>;
  update?: Maybe<PreferencesUpdateWithoutUserDataInput>;
  upsert?: Maybe<PreferencesUpsertWithoutUserInput>;
  connect?: Maybe<PreferencesWhereUniqueInput>;
}

export interface FundsUpdateOneWithoutDonationsInput {
  create?: Maybe<FundsCreateWithoutDonationsInput>;
  update?: Maybe<FundsUpdateWithoutDonationsDataInput>;
  upsert?: Maybe<FundsUpsertWithoutDonationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FundsWhereUniqueInput>;
}

export interface PreferencesUpdateWithoutUserDataInput {
  allowDonationEmails?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
}

export interface PreferencesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PreferencesWhereInput>;
  AND?: Maybe<
    PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput
  >;
  OR?: Maybe<
    PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput
  >;
}

export interface PreferencesUpsertWithoutUserInput {
  update: PreferencesUpdateWithoutUserDataInput;
  create: PreferencesCreateWithoutUserInput;
}

export interface HaloSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HaloWhereInput>;
  AND?: Maybe<HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput>;
  OR?: Maybe<HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput>;
  NOT?: Maybe<HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput>;
}

export interface TransactionUpdateManyWithoutUserInput {
  create?: Maybe<
    TransactionCreateWithoutUserInput[] | TransactionCreateWithoutUserInput
  >;
  delete?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  set?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  disconnect?: Maybe<
    TransactionWhereUniqueInput[] | TransactionWhereUniqueInput
  >;
  update?: Maybe<
    | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    | TransactionUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    | TransactionUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    TransactionScalarWhereInput[] | TransactionScalarWhereInput
  >;
  updateMany?: Maybe<
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput
  >;
}

export interface CircleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  open?: Maybe<Boolean>;
  open_not?: Maybe<Boolean>;
  joinRequests_every?: Maybe<CircleJoinRequestWhereInput>;
  joinRequests_some?: Maybe<CircleJoinRequestWhereInput>;
  joinRequests_none?: Maybe<CircleJoinRequestWhereInput>;
  invites_every?: Maybe<CircleInviteWhereInput>;
  invites_some?: Maybe<CircleInviteWhereInput>;
  invites_none?: Maybe<CircleInviteWhereInput>;
  members_every?: Maybe<UserWhereInput>;
  members_some?: Maybe<UserWhereInput>;
  members_none?: Maybe<UserWhereInput>;
  owner?: Maybe<UserWhereInput>;
  AND?: Maybe<CircleWhereInput[] | CircleWhereInput>;
  OR?: Maybe<CircleWhereInput[] | CircleWhereInput>;
  NOT?: Maybe<CircleWhereInput[] | CircleWhereInput>;
}

export interface TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutUserDataInput;
}

export interface CharityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  acronym?: Maybe<String>;
  acronym_not?: Maybe<String>;
  acronym_in?: Maybe<String[] | String>;
  acronym_not_in?: Maybe<String[] | String>;
  acronym_lt?: Maybe<String>;
  acronym_lte?: Maybe<String>;
  acronym_gt?: Maybe<String>;
  acronym_gte?: Maybe<String>;
  acronym_contains?: Maybe<String>;
  acronym_not_contains?: Maybe<String>;
  acronym_starts_with?: Maybe<String>;
  acronym_not_starts_with?: Maybe<String>;
  acronym_ends_with?: Maybe<String>;
  acronym_not_ends_with?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  bannerCredit_not?: Maybe<String>;
  bannerCredit_in?: Maybe<String[] | String>;
  bannerCredit_not_in?: Maybe<String[] | String>;
  bannerCredit_lt?: Maybe<String>;
  bannerCredit_lte?: Maybe<String>;
  bannerCredit_gt?: Maybe<String>;
  bannerCredit_gte?: Maybe<String>;
  bannerCredit_contains?: Maybe<String>;
  bannerCredit_not_contains?: Maybe<String>;
  bannerCredit_starts_with?: Maybe<String>;
  bannerCredit_not_starts_with?: Maybe<String>;
  bannerCredit_ends_with?: Maybe<String>;
  bannerCredit_not_ends_with?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  connectedAccountID_not?: Maybe<String>;
  connectedAccountID_in?: Maybe<String[] | String>;
  connectedAccountID_not_in?: Maybe<String[] | String>;
  connectedAccountID_lt?: Maybe<String>;
  connectedAccountID_lte?: Maybe<String>;
  connectedAccountID_gt?: Maybe<String>;
  connectedAccountID_gte?: Maybe<String>;
  connectedAccountID_contains?: Maybe<String>;
  connectedAccountID_not_contains?: Maybe<String>;
  connectedAccountID_starts_with?: Maybe<String>;
  connectedAccountID_not_starts_with?: Maybe<String>;
  connectedAccountID_ends_with?: Maybe<String>;
  connectedAccountID_not_ends_with?: Maybe<String>;
  ein?: Maybe<String>;
  ein_not?: Maybe<String>;
  ein_in?: Maybe<String[] | String>;
  ein_not_in?: Maybe<String[] | String>;
  ein_lt?: Maybe<String>;
  ein_lte?: Maybe<String>;
  ein_gt?: Maybe<String>;
  ein_gte?: Maybe<String>;
  ein_contains?: Maybe<String>;
  ein_not_contains?: Maybe<String>;
  ein_starts_with?: Maybe<String>;
  ein_not_starts_with?: Maybe<String>;
  ein_ends_with?: Maybe<String>;
  ein_not_ends_with?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesAdministrative_not?: Maybe<Float>;
  expensesAdministrative_in?: Maybe<Float[] | Float>;
  expensesAdministrative_not_in?: Maybe<Float[] | Float>;
  expensesAdministrative_lt?: Maybe<Float>;
  expensesAdministrative_lte?: Maybe<Float>;
  expensesAdministrative_gt?: Maybe<Float>;
  expensesAdministrative_gte?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesFundraising_not?: Maybe<Float>;
  expensesFundraising_in?: Maybe<Float[] | Float>;
  expensesFundraising_not_in?: Maybe<Float[] | Float>;
  expensesFundraising_lt?: Maybe<Float>;
  expensesFundraising_lte?: Maybe<Float>;
  expensesFundraising_gt?: Maybe<Float>;
  expensesFundraising_gte?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesOther_not?: Maybe<Float>;
  expensesOther_in?: Maybe<Float[] | Float>;
  expensesOther_not_in?: Maybe<Float[] | Float>;
  expensesOther_lt?: Maybe<Float>;
  expensesOther_lte?: Maybe<Float>;
  expensesOther_gt?: Maybe<Float>;
  expensesOther_gte?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesProgram_not?: Maybe<Float>;
  expensesProgram_in?: Maybe<Float[] | Float>;
  expensesProgram_not_in?: Maybe<Float[] | Float>;
  expensesProgram_lt?: Maybe<Float>;
  expensesProgram_lte?: Maybe<Float>;
  expensesProgram_gt?: Maybe<Float>;
  expensesProgram_gte?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  expensesUpdated_not?: Maybe<String>;
  expensesUpdated_in?: Maybe<String[] | String>;
  expensesUpdated_not_in?: Maybe<String[] | String>;
  expensesUpdated_lt?: Maybe<String>;
  expensesUpdated_lte?: Maybe<String>;
  expensesUpdated_gt?: Maybe<String>;
  expensesUpdated_gte?: Maybe<String>;
  expensesUpdated_contains?: Maybe<String>;
  expensesUpdated_not_contains?: Maybe<String>;
  expensesUpdated_starts_with?: Maybe<String>;
  expensesUpdated_not_starts_with?: Maybe<String>;
  expensesUpdated_ends_with?: Maybe<String>;
  expensesUpdated_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  mission?: Maybe<String>;
  mission_not?: Maybe<String>;
  mission_in?: Maybe<String[] | String>;
  mission_not_in?: Maybe<String[] | String>;
  mission_lt?: Maybe<String>;
  mission_lte?: Maybe<String>;
  mission_gt?: Maybe<String>;
  mission_gte?: Maybe<String>;
  mission_contains?: Maybe<String>;
  mission_not_contains?: Maybe<String>;
  mission_starts_with?: Maybe<String>;
  mission_not_starts_with?: Maybe<String>;
  mission_ends_with?: Maybe<String>;
  mission_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  events_every?: Maybe<EventWhereInput>;
  events_some?: Maybe<EventWhereInput>;
  events_none?: Maybe<EventWhereInput>;
  followers_every?: Maybe<UserWhereInput>;
  followers_some?: Maybe<UserWhereInput>;
  followers_none?: Maybe<UserWhereInput>;
  AND?: Maybe<CharityWhereInput[] | CharityWhereInput>;
  OR?: Maybe<CharityWhereInput[] | CharityWhereInput>;
  NOT?: Maybe<CharityWhereInput[] | CharityWhereInput>;
}

export interface TransactionUpdateWithoutUserDataInput {
  balance?: Maybe<Int>;
  donations?: Maybe<DonationUpdateManyWithoutTransactionInput>;
  funds?: Maybe<FundsUpdateOneWithoutTransactionInput>;
}

export interface CircleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CircleWhereInput>;
  AND?: Maybe<CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput>;
  OR?: Maybe<CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput>;
  NOT?: Maybe<CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput>;
}

export interface FundsUpdateOneWithoutTransactionInput {
  create?: Maybe<FundsCreateWithoutTransactionInput>;
  update?: Maybe<FundsUpdateWithoutTransactionDataInput>;
  upsert?: Maybe<FundsUpsertWithoutTransactionInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<FundsWhereUniqueInput>;
}

export interface UserUpdateInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface FundsUpdateWithoutTransactionDataInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
  donations?: Maybe<DonationUpdateManyWithoutSourceInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutFundsInput>;
}

export type CircleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface DonationUpdateManyWithoutSourceInput {
  create?: Maybe<
    DonationCreateWithoutSourceInput[] | DonationCreateWithoutSourceInput
  >;
  delete?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  connect?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  set?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  disconnect?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  update?: Maybe<
    | DonationUpdateWithWhereUniqueWithoutSourceInput[]
    | DonationUpdateWithWhereUniqueWithoutSourceInput
  >;
  upsert?: Maybe<
    | DonationUpsertWithWhereUniqueWithoutSourceInput[]
    | DonationUpsertWithWhereUniqueWithoutSourceInput
  >;
  deleteMany?: Maybe<DonationScalarWhereInput[] | DonationScalarWhereInput>;
  updateMany?: Maybe<
    | DonationUpdateManyWithWhereNestedInput[]
    | DonationUpdateManyWithWhereNestedInput
  >;
}

export type CircleInviteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DonationUpdateWithWhereUniqueWithoutSourceInput {
  where: DonationWhereUniqueInput;
  data: DonationUpdateWithoutSourceDataInput;
}

export type CircleJoinRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface DonationUpdateWithoutSourceDataInput {
  amount?: Maybe<Int>;
  batchKey?: Maybe<String>;
  subBalance?: Maybe<Int>;
  transferID?: Maybe<String>;
  event?: Maybe<EventUpdateOneWithoutDonationsInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutDonationsInput>;
}

export type DonationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TransactionUpdateOneRequiredWithoutDonationsInput {
  create?: Maybe<TransactionCreateWithoutDonationsInput>;
  update?: Maybe<TransactionUpdateWithoutDonationsDataInput>;
  upsert?: Maybe<TransactionUpsertWithoutDonationsInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export type DotWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TransactionUpdateWithoutDonationsDataInput {
  balance?: Maybe<Int>;
  funds?: Maybe<FundsUpdateOneWithoutTransactionInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateOneRequiredWithoutTransactionsInput {
  create?: Maybe<UserCreateWithoutTransactionsInput>;
  update?: Maybe<UserUpdateWithoutTransactionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutTransactionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type FundsWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateWithoutTransactionsDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export type HaloWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface FundsUpdateManyWithoutUserInput {
  create?: Maybe<FundsCreateWithoutUserInput[] | FundsCreateWithoutUserInput>;
  delete?: Maybe<FundsWhereUniqueInput[] | FundsWhereUniqueInput>;
  connect?: Maybe<FundsWhereUniqueInput[] | FundsWhereUniqueInput>;
  set?: Maybe<FundsWhereUniqueInput[] | FundsWhereUniqueInput>;
  disconnect?: Maybe<FundsWhereUniqueInput[] | FundsWhereUniqueInput>;
  update?: Maybe<
    | FundsUpdateWithWhereUniqueWithoutUserInput[]
    | FundsUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | FundsUpsertWithWhereUniqueWithoutUserInput[]
    | FundsUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<FundsScalarWhereInput[] | FundsScalarWhereInput>;
  updateMany?: Maybe<
    FundsUpdateManyWithWhereNestedInput[] | FundsUpdateManyWithWhereNestedInput
  >;
}

export type IdentityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  providerID?: Maybe<String>;
}>;

export interface FundsUpdateWithWhereUniqueWithoutUserInput {
  where: FundsWhereUniqueInput;
  data: FundsUpdateWithoutUserDataInput;
}

export interface UserUpdateWithoutHalosDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface FundsUpdateWithoutUserDataInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
  donations?: Maybe<DonationUpdateManyWithoutSourceInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutFundsInput>;
}

export interface UserCreateWithoutHalosInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface FundsUpsertWithWhereUniqueWithoutUserInput {
  where: FundsWhereUniqueInput;
  update: FundsUpdateWithoutUserDataInput;
  create: FundsCreateWithoutUserInput;
}

export interface FundsUpdateManyMutationInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
}

export interface FundsScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  amountAdded?: Maybe<Int>;
  amountAdded_not?: Maybe<Int>;
  amountAdded_in?: Maybe<Int[] | Int>;
  amountAdded_not_in?: Maybe<Int[] | Int>;
  amountAdded_lt?: Maybe<Int>;
  amountAdded_lte?: Maybe<Int>;
  amountAdded_gt?: Maybe<Int>;
  amountAdded_gte?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  amountNet_not?: Maybe<Int>;
  amountNet_in?: Maybe<Int[] | Int>;
  amountNet_not_in?: Maybe<Int[] | Int>;
  amountNet_lt?: Maybe<Int>;
  amountNet_lte?: Maybe<Int>;
  amountNet_gt?: Maybe<Int>;
  amountNet_gte?: Maybe<Int>;
  chargeID?: Maybe<String>;
  chargeID_not?: Maybe<String>;
  chargeID_in?: Maybe<String[] | String>;
  chargeID_not_in?: Maybe<String[] | String>;
  chargeID_lt?: Maybe<String>;
  chargeID_lte?: Maybe<String>;
  chargeID_gt?: Maybe<String>;
  chargeID_gte?: Maybe<String>;
  chargeID_contains?: Maybe<String>;
  chargeID_not_contains?: Maybe<String>;
  chargeID_starts_with?: Maybe<String>;
  chargeID_not_starts_with?: Maybe<String>;
  chargeID_ends_with?: Maybe<String>;
  chargeID_not_ends_with?: Maybe<String>;
  AND?: Maybe<FundsScalarWhereInput[] | FundsScalarWhereInput>;
  OR?: Maybe<FundsScalarWhereInput[] | FundsScalarWhereInput>;
  NOT?: Maybe<FundsScalarWhereInput[] | FundsScalarWhereInput>;
}

export interface EventUpdateManyMutationInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
}

export interface FundsUpdateManyWithWhereNestedInput {
  where: FundsScalarWhereInput;
  data: FundsUpdateManyDataInput;
}

export interface UserUpsertWithoutDotsInput {
  update: UserUpdateWithoutDotsDataInput;
  create: UserCreateWithoutDotsInput;
}

export interface FundsUpdateManyDataInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
}

export interface EventCreateManyWithoutCharityInput {
  create?: Maybe<
    EventCreateWithoutCharityInput[] | EventCreateWithoutCharityInput
  >;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput;
  create: UserCreateWithoutTransactionsInput;
}

export interface FundsCreateOneWithoutDonationsInput {
  create?: Maybe<FundsCreateWithoutDonationsInput>;
  connect?: Maybe<FundsWhereUniqueInput>;
}

export interface TransactionUpsertWithoutDonationsInput {
  update: TransactionUpdateWithoutDonationsDataInput;
  create: TransactionCreateWithoutDonationsInput;
}

export interface DonationCreateManyWithoutTransactionInput {
  create?: Maybe<
    | DonationCreateWithoutTransactionInput[]
    | DonationCreateWithoutTransactionInput
  >;
  connect?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
}

export interface DonationUpsertWithWhereUniqueWithoutSourceInput {
  where: DonationWhereUniqueInput;
  update: DonationUpdateWithoutSourceDataInput;
  create: DonationCreateWithoutSourceInput;
}

export interface CharityCreateOneWithoutEventsInput {
  create?: Maybe<CharityCreateWithoutEventsInput>;
  connect?: Maybe<CharityWhereUniqueInput>;
}

export interface DonationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  batchKey?: Maybe<String>;
  batchKey_not?: Maybe<String>;
  batchKey_in?: Maybe<String[] | String>;
  batchKey_not_in?: Maybe<String[] | String>;
  batchKey_lt?: Maybe<String>;
  batchKey_lte?: Maybe<String>;
  batchKey_gt?: Maybe<String>;
  batchKey_gte?: Maybe<String>;
  batchKey_contains?: Maybe<String>;
  batchKey_not_contains?: Maybe<String>;
  batchKey_starts_with?: Maybe<String>;
  batchKey_not_starts_with?: Maybe<String>;
  batchKey_ends_with?: Maybe<String>;
  batchKey_not_ends_with?: Maybe<String>;
  subBalance?: Maybe<Int>;
  subBalance_not?: Maybe<Int>;
  subBalance_in?: Maybe<Int[] | Int>;
  subBalance_not_in?: Maybe<Int[] | Int>;
  subBalance_lt?: Maybe<Int>;
  subBalance_lte?: Maybe<Int>;
  subBalance_gt?: Maybe<Int>;
  subBalance_gte?: Maybe<Int>;
  transferID?: Maybe<String>;
  transferID_not?: Maybe<String>;
  transferID_in?: Maybe<String[] | String>;
  transferID_not_in?: Maybe<String[] | String>;
  transferID_lt?: Maybe<String>;
  transferID_lte?: Maybe<String>;
  transferID_gt?: Maybe<String>;
  transferID_gte?: Maybe<String>;
  transferID_contains?: Maybe<String>;
  transferID_not_contains?: Maybe<String>;
  transferID_starts_with?: Maybe<String>;
  transferID_not_starts_with?: Maybe<String>;
  transferID_ends_with?: Maybe<String>;
  transferID_not_ends_with?: Maybe<String>;
  AND?: Maybe<DonationScalarWhereInput[] | DonationScalarWhereInput>;
  OR?: Maybe<DonationScalarWhereInput[] | DonationScalarWhereInput>;
  NOT?: Maybe<DonationScalarWhereInput[] | DonationScalarWhereInput>;
}

export interface CircleJoinRequestCreateManyWithoutUserInput {
  create?: Maybe<
    | CircleJoinRequestCreateWithoutUserInput[]
    | CircleJoinRequestCreateWithoutUserInput
  >;
  connect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
}

export interface DonationUpdateManyWithWhereNestedInput {
  where: DonationScalarWhereInput;
  data: DonationUpdateManyDataInput;
}

export interface CircleInviteCreateManyWithoutCircleInput {
  create?: Maybe<
    | CircleInviteCreateWithoutCircleInput[]
    | CircleInviteCreateWithoutCircleInput
  >;
  connect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
}

export interface DonationUpdateManyDataInput {
  amount?: Maybe<Int>;
  batchKey?: Maybe<String>;
  subBalance?: Maybe<Int>;
  transferID?: Maybe<String>;
}

export interface CircleCreateManyWithoutMembersInput {
  create?: Maybe<
    CircleCreateWithoutMembersInput[] | CircleCreateWithoutMembersInput
  >;
  connect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutFundsInput {
  create?: Maybe<UserCreateWithoutFundsInput>;
  update?: Maybe<UserUpdateWithoutFundsDataInput>;
  upsert?: Maybe<UserUpsertWithoutFundsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateOneWithoutCircleJoinRequestsInput {
  create?: Maybe<UserCreateWithoutCircleJoinRequestsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutFundsDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface CircleCreateOneWithoutInvitesInput {
  create?: Maybe<CircleCreateWithoutInvitesInput>;
  connect?: Maybe<CircleWhereUniqueInput>;
}

export interface UserUpsertWithoutFundsInput {
  update: UserUpdateWithoutFundsDataInput;
  create: UserCreateWithoutFundsInput;
}

export interface CircleCreateManyWithoutOwnerInput {
  create?: Maybe<
    CircleCreateWithoutOwnerInput[] | CircleCreateWithoutOwnerInput
  >;
  connect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
}

export interface FundsUpsertWithoutTransactionInput {
  update: FundsUpdateWithoutTransactionDataInput;
  create: FundsCreateWithoutTransactionInput;
}

export interface CharityCreateManyWithoutFollowersInput {
  create?: Maybe<
    CharityCreateWithoutFollowersInput[] | CharityCreateWithoutFollowersInput
  >;
  connect?: Maybe<CharityWhereUniqueInput[] | CharityWhereUniqueInput>;
}

export interface TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutUserDataInput;
  create: TransactionCreateWithoutUserInput;
}

export interface IdentityCreateOneWithoutUserInput {
  create?: Maybe<IdentityCreateWithoutUserInput>;
  connect?: Maybe<IdentityWhereUniqueInput>;
}

export interface TransactionScalarWhereInput {
  id?: Maybe<Int>;
  id_not?: Maybe<Int>;
  id_in?: Maybe<Int[] | Int>;
  id_not_in?: Maybe<Int[] | Int>;
  id_lt?: Maybe<Int>;
  id_lte?: Maybe<Int>;
  id_gt?: Maybe<Int>;
  id_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  balance?: Maybe<Int>;
  balance_not?: Maybe<Int>;
  balance_in?: Maybe<Int[] | Int>;
  balance_not_in?: Maybe<Int[] | Int>;
  balance_lt?: Maybe<Int>;
  balance_lte?: Maybe<Int>;
  balance_gt?: Maybe<Int>;
  balance_gte?: Maybe<Int>;
  AND?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  OR?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  NOT?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
}

export interface EventCreateOneInput {
  create?: Maybe<EventCreateInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput;
  data: TransactionUpdateManyDataInput;
}

export interface TransactionCreateManyWithoutUserInput {
  create?: Maybe<
    TransactionCreateWithoutUserInput[] | TransactionCreateWithoutUserInput
  >;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
}

export interface TransactionUpdateManyDataInput {
  balance?: Maybe<Int>;
}

export interface DonationCreateManyWithoutSourceInput {
  create?: Maybe<
    DonationCreateWithoutSourceInput[] | DonationCreateWithoutSourceInput
  >;
  connect?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
}

export interface UserUpsertWithWhereUniqueWithoutCirclesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCirclesDataInput;
  create: UserCreateWithoutCirclesInput;
}

export interface UserCreateOneWithoutTransactionsInput {
  create?: Maybe<UserCreateWithoutTransactionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameFirst_not?: Maybe<String>;
  nameFirst_in?: Maybe<String[] | String>;
  nameFirst_not_in?: Maybe<String[] | String>;
  nameFirst_lt?: Maybe<String>;
  nameFirst_lte?: Maybe<String>;
  nameFirst_gt?: Maybe<String>;
  nameFirst_gte?: Maybe<String>;
  nameFirst_contains?: Maybe<String>;
  nameFirst_not_contains?: Maybe<String>;
  nameFirst_starts_with?: Maybe<String>;
  nameFirst_not_starts_with?: Maybe<String>;
  nameFirst_ends_with?: Maybe<String>;
  nameFirst_not_ends_with?: Maybe<String>;
  nameLast?: Maybe<String>;
  nameLast_not?: Maybe<String>;
  nameLast_in?: Maybe<String[] | String>;
  nameLast_not_in?: Maybe<String[] | String>;
  nameLast_lt?: Maybe<String>;
  nameLast_lte?: Maybe<String>;
  nameLast_gt?: Maybe<String>;
  nameLast_gte?: Maybe<String>;
  nameLast_contains?: Maybe<String>;
  nameLast_not_contains?: Maybe<String>;
  nameLast_starts_with?: Maybe<String>;
  nameLast_not_starts_with?: Maybe<String>;
  nameLast_ends_with?: Maybe<String>;
  nameLast_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  securityToken?: Maybe<Int>;
  securityToken_not?: Maybe<Int>;
  securityToken_in?: Maybe<Int[] | Int>;
  securityToken_not_in?: Maybe<Int[] | Int>;
  securityToken_lt?: Maybe<Int>;
  securityToken_lte?: Maybe<Int>;
  securityToken_gt?: Maybe<Int>;
  securityToken_gte?: Maybe<Int>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserCreateOneWithoutFundsInput {
  create?: Maybe<UserCreateWithoutFundsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface CharityUpdateInput {
  acronym?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
  events?: Maybe<EventUpdateManyWithoutCharityInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowedCharitiesInput>;
}

export interface UserUpdateManyDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
}

export interface DonationUpdateManyWithoutEventInput {
  create?: Maybe<
    DonationCreateWithoutEventInput[] | DonationCreateWithoutEventInput
  >;
  delete?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  connect?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  set?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  disconnect?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
  update?: Maybe<
    | DonationUpdateWithWhereUniqueWithoutEventInput[]
    | DonationUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | DonationUpsertWithWhereUniqueWithoutEventInput[]
    | DonationUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<DonationScalarWhereInput[] | DonationScalarWhereInput>;
  updateMany?: Maybe<
    | DonationUpdateManyWithWhereNestedInput[]
    | DonationUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateOneRequiredWithoutCirclesOwnedInput {
  create?: Maybe<UserCreateWithoutCirclesOwnedInput>;
  update?: Maybe<UserUpdateWithoutCirclesOwnedDataInput>;
  upsert?: Maybe<UserUpsertWithoutCirclesOwnedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface UserUpdateWithoutCirclesOwnedDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface FundsSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FundsWhereInput>;
  AND?: Maybe<FundsSubscriptionWhereInput[] | FundsSubscriptionWhereInput>;
  OR?: Maybe<FundsSubscriptionWhereInput[] | FundsSubscriptionWhereInput>;
  NOT?: Maybe<FundsSubscriptionWhereInput[] | FundsSubscriptionWhereInput>;
}

export interface UserUpsertWithoutCirclesOwnedInput {
  update: UserUpdateWithoutCirclesOwnedDataInput;
  create: UserCreateWithoutCirclesOwnedInput;
}

export interface CircleJoinRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CircleJoinRequestWhereInput>;
  AND?: Maybe<
    | CircleJoinRequestSubscriptionWhereInput[]
    | CircleJoinRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CircleJoinRequestSubscriptionWhereInput[]
    | CircleJoinRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CircleJoinRequestSubscriptionWhereInput[]
    | CircleJoinRequestSubscriptionWhereInput
  >;
}

export interface CircleUpsertWithoutInvitesInput {
  update: CircleUpdateWithoutInvitesDataInput;
  create: CircleCreateWithoutInvitesInput;
}

export interface TransactionUpdateManyMutationInput {
  balance?: Maybe<Int>;
}

export interface CircleInviteUpsertWithWhereUniqueWithoutUserInput {
  where: CircleInviteWhereUniqueInput;
  update: CircleInviteUpdateWithoutUserDataInput;
  create: CircleInviteCreateWithoutUserInput;
}

export interface UserUpdateOneRequiredWithoutPreferencesInput {
  create?: Maybe<UserCreateWithoutPreferencesInput>;
  update?: Maybe<UserUpdateWithoutPreferencesDataInput>;
  upsert?: Maybe<UserUpsertWithoutPreferencesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleInviteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput>;
  OR?: Maybe<CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput>;
  NOT?: Maybe<CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput>;
}

export interface UserUpsertWithoutLoopsInput {
  update: UserUpdateWithoutLoopsDataInput;
  create: UserCreateWithoutLoopsInput;
}

export interface UserUpsertWithoutCircleJoinRequestsInput {
  update: UserUpdateWithoutCircleJoinRequestsDataInput;
  create: UserCreateWithoutCircleJoinRequestsInput;
}

export interface LoopCreateInput {
  id?: Maybe<ID_Input>;
  count: Int;
  event: EventCreateOneInput;
  user: UserCreateOneWithoutLoopsInput;
}

export interface CircleJoinRequestUpsertWithWhereUniqueWithoutCircleInput {
  where: CircleJoinRequestWhereUniqueInput;
  update: CircleJoinRequestUpdateWithoutCircleDataInput;
  create: CircleJoinRequestCreateWithoutCircleInput;
}

export interface UserCreateWithoutIdentityInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface CircleJoinRequestScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput
  >;
  OR?: Maybe<
    CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput
  >;
  NOT?: Maybe<
    CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput
  >;
}

export interface UserUpdateOneRequiredWithoutHalosInput {
  create?: Maybe<UserCreateWithoutHalosInput>;
  update?: Maybe<UserUpdateWithoutHalosDataInput>;
  upsert?: Maybe<UserUpsertWithoutHalosInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleUpsertWithWhereUniqueWithoutMembersInput {
  where: CircleWhereUniqueInput;
  update: CircleUpdateWithoutMembersDataInput;
  create: CircleCreateWithoutMembersInput;
}

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<Int>;
}>;

export interface UserUpsertWithoutCircleInvitesInput {
  update: UserUpdateWithoutCircleInvitesDataInput;
  create: UserCreateWithoutCircleInvitesInput;
}

export interface TransactionCreateOneWithoutFundsInput {
  create?: Maybe<TransactionCreateWithoutFundsInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface CircleInviteUpsertWithWhereUniqueWithoutCircleInput {
  where: CircleInviteWhereUniqueInput;
  update: CircleInviteUpdateWithoutCircleDataInput;
  create: CircleInviteCreateWithoutCircleInput;
}

export interface UserCreateManyWithoutFollowedCharitiesInput {
  create?: Maybe<
    | UserCreateWithoutFollowedCharitiesInput[]
    | UserCreateWithoutFollowedCharitiesInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface CircleUpsertWithoutJoinRequestsInput {
  update: CircleUpdateWithoutJoinRequestsDataInput;
  create: CircleCreateWithoutJoinRequestsInput;
}

export interface UserCreateOneWithoutCircleInvitesInput {
  create?: Maybe<UserCreateWithoutCircleInvitesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleJoinRequestUpsertWithWhereUniqueWithoutUserInput {
  where: CircleJoinRequestWhereUniqueInput;
  update: CircleJoinRequestUpdateWithoutUserDataInput;
  create: CircleJoinRequestCreateWithoutUserInput;
}

export interface CircleInviteCreateManyWithoutUserInput {
  create?: Maybe<
    CircleInviteCreateWithoutUserInput[] | CircleInviteCreateWithoutUserInput
  >;
  connect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
}

export interface UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFollowedCharitiesDataInput;
  create: UserCreateWithoutFollowedCharitiesInput;
}

export interface DotCreateManyWithoutUserInput {
  create?: Maybe<DotCreateWithoutUserInput[] | DotCreateWithoutUserInput>;
  connect?: Maybe<DotWhereUniqueInput[] | DotWhereUniqueInput>;
}

export interface CharityUpsertWithoutEventsInput {
  update: CharityUpdateWithoutEventsDataInput;
  create: CharityCreateWithoutEventsInput;
}

export interface LoopCreateManyWithoutUserInput {
  create?: Maybe<LoopCreateWithoutUserInput[] | LoopCreateWithoutUserInput>;
  connect?: Maybe<LoopWhereUniqueInput[] | LoopWhereUniqueInput>;
}

export interface EventUpsertWithoutDonationsInput {
  update: EventUpdateWithoutDonationsDataInput;
  create: EventCreateWithoutDonationsInput;
}

export interface FundsCreateOneWithoutTransactionInput {
  create?: Maybe<FundsCreateWithoutTransactionInput>;
  connect?: Maybe<FundsWhereUniqueInput>;
}

export interface DonationUpsertWithWhereUniqueWithoutTransactionInput {
  where: DonationWhereUniqueInput;
  update: DonationUpdateWithoutTransactionDataInput;
  create: DonationCreateWithoutTransactionInput;
}

export interface FundsCreateManyWithoutUserInput {
  create?: Maybe<FundsCreateWithoutUserInput[] | FundsCreateWithoutUserInput>;
  connect?: Maybe<FundsWhereUniqueInput[] | FundsWhereUniqueInput>;
}

export interface TransactionUpsertWithoutFundsInput {
  update: TransactionUpdateWithoutFundsDataInput;
  create: TransactionCreateWithoutFundsInput;
}

export interface EventUpdateWithWhereUniqueWithoutCharityInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutCharityDataInput;
}

export interface FundsUpsertWithoutDonationsInput {
  update: FundsUpdateWithoutDonationsDataInput;
  create: FundsCreateWithoutDonationsInput;
}

export interface DotWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  action?: Maybe<String>;
  action_not?: Maybe<String>;
  action_in?: Maybe<String[] | String>;
  action_not_in?: Maybe<String[] | String>;
  action_lt?: Maybe<String>;
  action_lte?: Maybe<String>;
  action_gt?: Maybe<String>;
  action_gte?: Maybe<String>;
  action_contains?: Maybe<String>;
  action_not_contains?: Maybe<String>;
  action_starts_with?: Maybe<String>;
  action_not_starts_with?: Maybe<String>;
  action_ends_with?: Maybe<String>;
  action_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  total?: Maybe<Int>;
  total_not?: Maybe<Int>;
  total_in?: Maybe<Int[] | Int>;
  total_not_in?: Maybe<Int[] | Int>;
  total_lt?: Maybe<Int>;
  total_lte?: Maybe<Int>;
  total_gt?: Maybe<Int>;
  total_gte?: Maybe<Int>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<DotWhereInput[] | DotWhereInput>;
  OR?: Maybe<DotWhereInput[] | DotWhereInput>;
  NOT?: Maybe<DotWhereInput[] | DotWhereInput>;
}

export interface DonationUpsertWithWhereUniqueWithoutEventInput {
  where: DonationWhereUniqueInput;
  update: DonationUpdateWithoutEventDataInput;
  create: DonationCreateWithoutEventInput;
}

export interface EventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  goal_not?: Maybe<Int>;
  goal_in?: Maybe<Int[] | Int>;
  goal_not_in?: Maybe<Int[] | Int>;
  goal_lt?: Maybe<Int>;
  goal_lte?: Maybe<Int>;
  goal_gt?: Maybe<Int>;
  goal_gte?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  multiplier_not?: Maybe<Int>;
  multiplier_in?: Maybe<Int[] | Int>;
  multiplier_not_in?: Maybe<Int[] | Int>;
  multiplier_lt?: Maybe<Int>;
  multiplier_lte?: Maybe<Int>;
  multiplier_gt?: Maybe<Int>;
  multiplier_gte?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEvent_not?: Maybe<String>;
  specialEvent_in?: Maybe<String[] | String>;
  specialEvent_not_in?: Maybe<String[] | String>;
  specialEvent_lt?: Maybe<String>;
  specialEvent_lte?: Maybe<String>;
  specialEvent_gt?: Maybe<String>;
  specialEvent_gte?: Maybe<String>;
  specialEvent_contains?: Maybe<String>;
  specialEvent_not_contains?: Maybe<String>;
  specialEvent_starts_with?: Maybe<String>;
  specialEvent_not_starts_with?: Maybe<String>;
  specialEvent_ends_with?: Maybe<String>;
  specialEvent_not_ends_with?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventDescription_not?: Maybe<String>;
  specialEventDescription_in?: Maybe<String[] | String>;
  specialEventDescription_not_in?: Maybe<String[] | String>;
  specialEventDescription_lt?: Maybe<String>;
  specialEventDescription_lte?: Maybe<String>;
  specialEventDescription_gt?: Maybe<String>;
  specialEventDescription_gte?: Maybe<String>;
  specialEventDescription_contains?: Maybe<String>;
  specialEventDescription_not_contains?: Maybe<String>;
  specialEventDescription_starts_with?: Maybe<String>;
  specialEventDescription_not_starts_with?: Maybe<String>;
  specialEventDescription_ends_with?: Maybe<String>;
  specialEventDescription_not_ends_with?: Maybe<String>;
  specialEventName?: Maybe<String>;
  specialEventName_not?: Maybe<String>;
  specialEventName_in?: Maybe<String[] | String>;
  specialEventName_not_in?: Maybe<String[] | String>;
  specialEventName_lt?: Maybe<String>;
  specialEventName_lte?: Maybe<String>;
  specialEventName_gt?: Maybe<String>;
  specialEventName_gte?: Maybe<String>;
  specialEventName_contains?: Maybe<String>;
  specialEventName_not_contains?: Maybe<String>;
  specialEventName_starts_with?: Maybe<String>;
  specialEventName_not_starts_with?: Maybe<String>;
  specialEventName_ends_with?: Maybe<String>;
  specialEventName_not_ends_with?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorName_not?: Maybe<String>;
  sponsorName_in?: Maybe<String[] | String>;
  sponsorName_not_in?: Maybe<String[] | String>;
  sponsorName_lt?: Maybe<String>;
  sponsorName_lte?: Maybe<String>;
  sponsorName_gt?: Maybe<String>;
  sponsorName_gte?: Maybe<String>;
  sponsorName_contains?: Maybe<String>;
  sponsorName_not_contains?: Maybe<String>;
  sponsorName_starts_with?: Maybe<String>;
  sponsorName_not_starts_with?: Maybe<String>;
  sponsorName_ends_with?: Maybe<String>;
  sponsorName_not_ends_with?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  sponsorWebsite_not?: Maybe<String>;
  sponsorWebsite_in?: Maybe<String[] | String>;
  sponsorWebsite_not_in?: Maybe<String[] | String>;
  sponsorWebsite_lt?: Maybe<String>;
  sponsorWebsite_lte?: Maybe<String>;
  sponsorWebsite_gt?: Maybe<String>;
  sponsorWebsite_gte?: Maybe<String>;
  sponsorWebsite_contains?: Maybe<String>;
  sponsorWebsite_not_contains?: Maybe<String>;
  sponsorWebsite_starts_with?: Maybe<String>;
  sponsorWebsite_not_starts_with?: Maybe<String>;
  sponsorWebsite_ends_with?: Maybe<String>;
  sponsorWebsite_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  charity?: Maybe<CharityWhereInput>;
  donations_every?: Maybe<DonationWhereInput>;
  donations_some?: Maybe<DonationWhereInput>;
  donations_none?: Maybe<DonationWhereInput>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export interface EventUpsertWithWhereUniqueWithoutCharityInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutCharityDataInput;
  create: EventCreateWithoutCharityInput;
}

export interface UserCreateOneWithoutPreferencesInput {
  create?: Maybe<UserCreateWithoutPreferencesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface EventScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  goal_not?: Maybe<Int>;
  goal_in?: Maybe<Int[] | Int>;
  goal_not_in?: Maybe<Int[] | Int>;
  goal_lt?: Maybe<Int>;
  goal_lte?: Maybe<Int>;
  goal_gt?: Maybe<Int>;
  goal_gte?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  multiplier_not?: Maybe<Int>;
  multiplier_in?: Maybe<Int[] | Int>;
  multiplier_not_in?: Maybe<Int[] | Int>;
  multiplier_lt?: Maybe<Int>;
  multiplier_lte?: Maybe<Int>;
  multiplier_gt?: Maybe<Int>;
  multiplier_gte?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEvent_not?: Maybe<String>;
  specialEvent_in?: Maybe<String[] | String>;
  specialEvent_not_in?: Maybe<String[] | String>;
  specialEvent_lt?: Maybe<String>;
  specialEvent_lte?: Maybe<String>;
  specialEvent_gt?: Maybe<String>;
  specialEvent_gte?: Maybe<String>;
  specialEvent_contains?: Maybe<String>;
  specialEvent_not_contains?: Maybe<String>;
  specialEvent_starts_with?: Maybe<String>;
  specialEvent_not_starts_with?: Maybe<String>;
  specialEvent_ends_with?: Maybe<String>;
  specialEvent_not_ends_with?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventDescription_not?: Maybe<String>;
  specialEventDescription_in?: Maybe<String[] | String>;
  specialEventDescription_not_in?: Maybe<String[] | String>;
  specialEventDescription_lt?: Maybe<String>;
  specialEventDescription_lte?: Maybe<String>;
  specialEventDescription_gt?: Maybe<String>;
  specialEventDescription_gte?: Maybe<String>;
  specialEventDescription_contains?: Maybe<String>;
  specialEventDescription_not_contains?: Maybe<String>;
  specialEventDescription_starts_with?: Maybe<String>;
  specialEventDescription_not_starts_with?: Maybe<String>;
  specialEventDescription_ends_with?: Maybe<String>;
  specialEventDescription_not_ends_with?: Maybe<String>;
  specialEventName?: Maybe<String>;
  specialEventName_not?: Maybe<String>;
  specialEventName_in?: Maybe<String[] | String>;
  specialEventName_not_in?: Maybe<String[] | String>;
  specialEventName_lt?: Maybe<String>;
  specialEventName_lte?: Maybe<String>;
  specialEventName_gt?: Maybe<String>;
  specialEventName_gte?: Maybe<String>;
  specialEventName_contains?: Maybe<String>;
  specialEventName_not_contains?: Maybe<String>;
  specialEventName_starts_with?: Maybe<String>;
  specialEventName_not_starts_with?: Maybe<String>;
  specialEventName_ends_with?: Maybe<String>;
  specialEventName_not_ends_with?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorName_not?: Maybe<String>;
  sponsorName_in?: Maybe<String[] | String>;
  sponsorName_not_in?: Maybe<String[] | String>;
  sponsorName_lt?: Maybe<String>;
  sponsorName_lte?: Maybe<String>;
  sponsorName_gt?: Maybe<String>;
  sponsorName_gte?: Maybe<String>;
  sponsorName_contains?: Maybe<String>;
  sponsorName_not_contains?: Maybe<String>;
  sponsorName_starts_with?: Maybe<String>;
  sponsorName_not_starts_with?: Maybe<String>;
  sponsorName_ends_with?: Maybe<String>;
  sponsorName_not_ends_with?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  sponsorWebsite_not?: Maybe<String>;
  sponsorWebsite_in?: Maybe<String[] | String>;
  sponsorWebsite_not_in?: Maybe<String[] | String>;
  sponsorWebsite_lt?: Maybe<String>;
  sponsorWebsite_lte?: Maybe<String>;
  sponsorWebsite_gt?: Maybe<String>;
  sponsorWebsite_gte?: Maybe<String>;
  sponsorWebsite_contains?: Maybe<String>;
  sponsorWebsite_not_contains?: Maybe<String>;
  sponsorWebsite_starts_with?: Maybe<String>;
  sponsorWebsite_not_starts_with?: Maybe<String>;
  sponsorWebsite_ends_with?: Maybe<String>;
  sponsorWebsite_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  OR?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  NOT?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
}

export interface UserUpdateWithoutIdentityDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  funds?: Maybe<FundsUpdateManyWithoutUserInput>;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface UserCreateOneWithoutHalosInput {
  create?: Maybe<UserCreateWithoutHalosInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface EventUpdateManyDataInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
}

export interface DonationCreateManyWithoutEventInput {
  create?: Maybe<
    DonationCreateWithoutEventInput[] | DonationCreateWithoutEventInput
  >;
  connect?: Maybe<DonationWhereUniqueInput[] | DonationWhereUniqueInput>;
}

export interface CharityUpdateManyMutationInput {
  acronym?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  website?: Maybe<String>;
}

export interface CircleCreateOneWithoutJoinRequestsInput {
  create?: Maybe<CircleCreateWithoutJoinRequestsInput>;
  connect?: Maybe<CircleWhereUniqueInput>;
}

export interface DotUpdateInput {
  action?: Maybe<String>;
  amount?: Maybe<Int>;
  total?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutDotsInput>;
}

export interface UserCreateManyWithoutCirclesInput {
  create?: Maybe<
    UserCreateWithoutCirclesInput[] | UserCreateWithoutCirclesInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutDotsInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  funds?: Maybe<FundsCreateManyWithoutUserInput>;
}

export interface PreferencesCreateOneWithoutUserInput {
  create?: Maybe<PreferencesCreateWithoutUserInput>;
  connect?: Maybe<PreferencesWhereUniqueInput>;
}

export interface CircleCreateInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  name: String;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestCreateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteCreateManyWithoutCircleInput>;
  members?: Maybe<UserCreateManyWithoutCirclesInput>;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface UserCreateOneWithoutCirclesOwnedInput {
  create?: Maybe<UserCreateWithoutCirclesOwnedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleUpdateInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteUpdateManyWithoutCircleInput>;
  members?: Maybe<UserUpdateManyWithoutCirclesInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutCirclesOwnedInput>;
}

export interface DotSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DotWhereInput>;
  AND?: Maybe<DotSubscriptionWhereInput[] | DotSubscriptionWhereInput>;
  OR?: Maybe<DotSubscriptionWhereInput[] | DotSubscriptionWhereInput>;
  NOT?: Maybe<DotSubscriptionWhereInput[] | DotSubscriptionWhereInput>;
}

export interface CircleUpdateManyMutationInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
}

export interface LoopUpdateInput {
  count?: Maybe<Int>;
  event?: Maybe<EventUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutLoopsInput>;
}

export interface CircleInviteCreateInput {
  id?: Maybe<ID_Input>;
  circle: CircleCreateOneWithoutInvitesInput;
  user: UserCreateOneWithoutCircleInvitesInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface CircleInviteUpdateInput {
  circle?: Maybe<CircleUpdateOneRequiredWithoutInvitesInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutCircleInvitesInput>;
}

export interface CircleJoinRequestCreateManyWithoutCircleInput {
  create?: Maybe<
    | CircleJoinRequestCreateWithoutCircleInput[]
    | CircleJoinRequestCreateWithoutCircleInput
  >;
  connect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
}

export interface CircleJoinRequestCreateInput {
  id?: Maybe<ID_Input>;
  circle: CircleCreateOneWithoutJoinRequestsInput;
  user: UserCreateOneWithoutCircleJoinRequestsInput;
}

export interface TransactionCreateOneWithoutDonationsInput {
  create?: Maybe<TransactionCreateWithoutDonationsInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface CircleJoinRequestUpdateInput {
  circle?: Maybe<CircleUpdateOneRequiredWithoutJoinRequestsInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutCircleJoinRequestsInput>;
}

export interface PreferencesUpdateManyMutationInput {
  allowDonationEmails?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
}

export interface DotCreateInput {
  id?: Maybe<ID_Input>;
  action: String;
  amount: Int;
  total: Int;
  user: UserCreateOneWithoutDotsInput;
}

export interface DonationUpdateManyMutationInput {
  amount?: Maybe<Int>;
  batchKey?: Maybe<String>;
  subBalance?: Maybe<Int>;
  transferID?: Maybe<String>;
}

export interface DonationUpdateInput {
  amount?: Maybe<Int>;
  batchKey?: Maybe<String>;
  subBalance?: Maybe<Int>;
  transferID?: Maybe<String>;
  event?: Maybe<EventUpdateOneWithoutDonationsInput>;
  source?: Maybe<FundsUpdateOneWithoutDonationsInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutDonationsInput>;
}

export interface DonationCreateInput {
  id?: Maybe<ID_Input>;
  amount: Int;
  batchKey: String;
  subBalance: Int;
  transferID: String;
  event?: Maybe<EventCreateOneWithoutDonationsInput>;
  source?: Maybe<FundsCreateOneWithoutDonationsInput>;
  transaction: TransactionCreateOneWithoutDonationsInput;
}

export interface HaloUpdateManyMutationInput {
  key?: Maybe<String>;
  tier?: Maybe<String>;
}

export interface DonationUpdateWithoutEventDataInput {
  amount?: Maybe<Int>;
  batchKey?: Maybe<String>;
  subBalance?: Maybe<Int>;
  transferID?: Maybe<String>;
  source?: Maybe<FundsUpdateOneWithoutDonationsInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutDonationsInput>;
}

export interface HaloCreateManyWithoutUserInput {
  create?: Maybe<HaloCreateWithoutUserInput[] | HaloCreateWithoutUserInput>;
  connect?: Maybe<HaloWhereUniqueInput[] | HaloWhereUniqueInput>;
}

export interface EventCreateOneWithoutDonationsInput {
  create?: Maybe<EventCreateWithoutDonationsInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  email: () => Promise<String>;
  nameFirst: () => Promise<String>;
  nameLast: () => Promise<String>;
  picture: () => Promise<String>;
  securityToken: () => Promise<Int>;
  username: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bio: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameLast: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  securityToken: () => Promise<AsyncIterator<Int>>;
  username: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Event {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  endDate: DateTimeOutput;
  goal: Int;
  multiplier?: Int;
  specialEvent?: String;
  specialEventDescription?: String;
  specialEventName?: String;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeOutput;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  goal: () => Promise<Int>;
  multiplier: () => Promise<Int>;
  specialEvent: () => Promise<String>;
  specialEventDescription: () => Promise<String>;
  specialEventName: () => Promise<String>;
  sponsorName: () => Promise<String>;
  sponsorWebsite: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  charity: <T = CharityPromise>() => T;
  donations: <T = FragmentableArray<Donation>>(args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  goal: () => Promise<AsyncIterator<Int>>;
  multiplier: () => Promise<AsyncIterator<Int>>;
  specialEvent: () => Promise<AsyncIterator<String>>;
  specialEventDescription: () => Promise<AsyncIterator<String>>;
  specialEventName: () => Promise<AsyncIterator<String>>;
  sponsorName: () => Promise<AsyncIterator<String>>;
  sponsorWebsite: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  charity: <T = CharitySubscription>() => T;
  donations: <T = Promise<AsyncIterator<DonationSubscription>>>(args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  goal: () => Promise<Int>;
  multiplier: () => Promise<Int>;
  specialEvent: () => Promise<String>;
  specialEventDescription: () => Promise<String>;
  specialEventName: () => Promise<String>;
  sponsorName: () => Promise<String>;
  sponsorWebsite: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  charity: <T = CharityPromise>() => T;
  donations: <T = FragmentableArray<Donation>>(args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface AggregateCharity {
  count: Int;
}

export interface AggregateCharityPromise
  extends Promise<AggregateCharity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharitySubscription
  extends Promise<AsyncIterator<AggregateCharity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PreferencesPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  allowDonationEmails: Boolean;
  publicProfile: Boolean;
}

export interface PreferencesPreviousValuesPromise
  extends Promise<PreferencesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  allowDonationEmails: () => Promise<Boolean>;
  publicProfile: () => Promise<Boolean>;
}

export interface PreferencesPreviousValuesSubscription
  extends Promise<AsyncIterator<PreferencesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  allowDonationEmails: () => Promise<AsyncIterator<Boolean>>;
  publicProfile: () => Promise<AsyncIterator<Boolean>>;
}

export interface CharityEdge {
  node: Charity;
  cursor: String;
}

export interface CharityEdgePromise extends Promise<CharityEdge>, Fragmentable {
  node: <T = CharityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharityEdgeSubscription
  extends Promise<AsyncIterator<CharityEdge>>,
    Fragmentable {
  node: <T = CharitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharityConnection {
  pageInfo: PageInfo;
  edges: CharityEdge[];
}

export interface CharityConnectionPromise
  extends Promise<CharityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharityEdge>>() => T;
  aggregate: <T = AggregateCharityPromise>() => T;
}

export interface CharityConnectionSubscription
  extends Promise<AsyncIterator<CharityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharitySubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Donation {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amount: Int;
  batchKey: String;
  subBalance: Int;
  transferID: String;
}

export interface DonationPromise extends Promise<Donation>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  batchKey: () => Promise<String>;
  subBalance: () => Promise<Int>;
  transferID: () => Promise<String>;
  event: <T = EventPromise>() => T;
  source: <T = FundsPromise>() => T;
  transaction: <T = TransactionPromise>() => T;
}

export interface DonationSubscription
  extends Promise<AsyncIterator<Donation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  batchKey: () => Promise<AsyncIterator<String>>;
  subBalance: () => Promise<AsyncIterator<Int>>;
  transferID: () => Promise<AsyncIterator<String>>;
  event: <T = EventSubscription>() => T;
  source: <T = FundsSubscription>() => T;
  transaction: <T = TransactionSubscription>() => T;
}

export interface DonationNullablePromise
  extends Promise<Donation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  batchKey: () => Promise<String>;
  subBalance: () => Promise<Int>;
  transferID: () => Promise<String>;
  event: <T = EventPromise>() => T;
  source: <T = FundsPromise>() => T;
  transaction: <T = TransactionPromise>() => T;
}

export interface AggregatePreferences {
  count: Int;
}

export interface AggregatePreferencesPromise
  extends Promise<AggregatePreferences>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePreferencesSubscription
  extends Promise<AsyncIterator<AggregatePreferences>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Preferences {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  allowDonationEmails: Boolean;
  publicProfile: Boolean;
}

export interface PreferencesPromise extends Promise<Preferences>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  allowDonationEmails: () => Promise<Boolean>;
  publicProfile: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
}

export interface PreferencesSubscription
  extends Promise<AsyncIterator<Preferences>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  allowDonationEmails: () => Promise<AsyncIterator<Boolean>>;
  publicProfile: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
}

export interface PreferencesNullablePromise
  extends Promise<Preferences | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  allowDonationEmails: () => Promise<Boolean>;
  publicProfile: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
}

export interface PreferencesConnection {
  pageInfo: PageInfo;
  edges: PreferencesEdge[];
}

export interface PreferencesConnectionPromise
  extends Promise<PreferencesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PreferencesEdge>>() => T;
  aggregate: <T = AggregatePreferencesPromise>() => T;
}

export interface PreferencesConnectionSubscription
  extends Promise<AsyncIterator<PreferencesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PreferencesEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePreferencesSubscription>() => T;
}

export interface TransactionPreviousValues {
  id: Int;
  createdAt: DateTimeOutput;
  balance: Int;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  balance: () => Promise<Int>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  balance: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateLoop {
  count: Int;
}

export interface AggregateLoopPromise
  extends Promise<AggregateLoop>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoopSubscription
  extends Promise<AsyncIterator<AggregateLoop>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CharitySubscriptionPayload {
  mutation: MutationType;
  node: Charity;
  updatedFields: String[];
  previousValues: CharityPreviousValues;
}

export interface CharitySubscriptionPayloadPromise
  extends Promise<CharitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharityPreviousValuesPromise>() => T;
}

export interface CharitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharityPreviousValuesSubscription>() => T;
}

export interface LoopConnection {
  pageInfo: PageInfo;
  edges: LoopEdge[];
}

export interface LoopConnectionPromise
  extends Promise<LoopConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoopEdge>>() => T;
  aggregate: <T = AggregateLoopPromise>() => T;
}

export interface LoopConnectionSubscription
  extends Promise<AsyncIterator<LoopConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoopEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoopSubscription>() => T;
}

export interface CharityPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  acronym?: String;
  bannerCredit?: String;
  connectedAccountID?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
}

export interface CharityPreviousValuesPromise
  extends Promise<CharityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  acronym: () => Promise<String>;
  bannerCredit: () => Promise<String>;
  connectedAccountID: () => Promise<String>;
  ein: () => Promise<String>;
  expensesAdministrative: () => Promise<Float>;
  expensesFundraising: () => Promise<Float>;
  expensesOther: () => Promise<Float>;
  expensesProgram: () => Promise<Float>;
  expensesUpdated: () => Promise<String>;
  location: () => Promise<String>;
  mission: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  website: () => Promise<String>;
}

export interface CharityPreviousValuesSubscription
  extends Promise<AsyncIterator<CharityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  acronym: () => Promise<AsyncIterator<String>>;
  bannerCredit: () => Promise<AsyncIterator<String>>;
  connectedAccountID: () => Promise<AsyncIterator<String>>;
  ein: () => Promise<AsyncIterator<String>>;
  expensesAdministrative: () => Promise<AsyncIterator<Float>>;
  expensesFundraising: () => Promise<AsyncIterator<Float>>;
  expensesOther: () => Promise<AsyncIterator<Float>>;
  expensesProgram: () => Promise<AsyncIterator<Float>>;
  expensesUpdated: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  mission: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
}

export interface IdentityEdge {
  node: Identity;
  cursor: String;
}

export interface IdentityEdgePromise
  extends Promise<IdentityEdge>,
    Fragmentable {
  node: <T = IdentityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IdentityEdgeSubscription
  extends Promise<AsyncIterator<IdentityEdge>>,
    Fragmentable {
  node: <T = IdentitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Loop {
  id: ID_Output;
  createdAt: DateTimeOutput;
  count: Int;
}

export interface LoopPromise extends Promise<Loop>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  count: () => Promise<Int>;
  event: <T = EventPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface LoopSubscription
  extends Promise<AsyncIterator<Loop>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  count: () => Promise<AsyncIterator<Int>>;
  event: <T = EventSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface LoopNullablePromise
  extends Promise<Loop | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  count: () => Promise<Int>;
  event: <T = EventPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface CircleSubscriptionPayload {
  mutation: MutationType;
  node: Circle;
  updatedFields: String[];
  previousValues: CirclePreviousValues;
}

export interface CircleSubscriptionPayloadPromise
  extends Promise<CircleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CirclePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CirclePreviousValuesPromise>() => T;
}

export interface CircleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CircleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CircleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CirclePreviousValuesSubscription>() => T;
}

export interface HaloEdge {
  node: Halo;
  cursor: String;
}

export interface HaloEdgePromise extends Promise<HaloEdge>, Fragmentable {
  node: <T = HaloPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HaloEdgeSubscription
  extends Promise<AsyncIterator<HaloEdge>>,
    Fragmentable {
  node: <T = HaloSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CirclePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  name: String;
  open: Boolean;
}

export interface CirclePreviousValuesPromise
  extends Promise<CirclePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  open: () => Promise<Boolean>;
}

export interface CirclePreviousValuesSubscription
  extends Promise<AsyncIterator<CirclePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface AggregateFunds {
  count: Int;
}

export interface AggregateFundsPromise
  extends Promise<AggregateFunds>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFundsSubscription
  extends Promise<AsyncIterator<AggregateFunds>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface FundsConnection {
  pageInfo: PageInfo;
  edges: FundsEdge[];
}

export interface FundsConnectionPromise
  extends Promise<FundsConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FundsEdge>>() => T;
  aggregate: <T = AggregateFundsPromise>() => T;
}

export interface FundsConnectionSubscription
  extends Promise<AsyncIterator<FundsConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FundsEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFundsSubscription>() => T;
}

export interface CircleInviteSubscriptionPayload {
  mutation: MutationType;
  node: CircleInvite;
  updatedFields: String[];
  previousValues: CircleInvitePreviousValues;
}

export interface CircleInviteSubscriptionPayloadPromise
  extends Promise<CircleInviteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CircleInvitePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CircleInvitePreviousValuesPromise>() => T;
}

export interface CircleInviteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CircleInviteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CircleInviteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CircleInvitePreviousValuesSubscription>() => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CircleInvitePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleInvitePreviousValuesPromise
  extends Promise<CircleInvitePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CircleInvitePreviousValuesSubscription
  extends Promise<AsyncIterator<CircleInvitePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateDot {
  count: Int;
}

export interface AggregateDotPromise
  extends Promise<AggregateDot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDotSubscription
  extends Promise<AsyncIterator<AggregateDot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Identity {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  provider: IdentityProvider;
  providerID: String;
}

export interface IdentityPromise extends Promise<Identity>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  provider: () => Promise<IdentityProvider>;
  providerID: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface IdentitySubscription
  extends Promise<AsyncIterator<Identity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  provider: () => Promise<AsyncIterator<IdentityProvider>>;
  providerID: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface IdentityNullablePromise
  extends Promise<Identity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  provider: () => Promise<IdentityProvider>;
  providerID: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface DotConnection {
  pageInfo: PageInfo;
  edges: DotEdge[];
}

export interface DotConnectionPromise
  extends Promise<DotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DotEdge>>() => T;
  aggregate: <T = AggregateDotPromise>() => T;
}

export interface DotConnectionSubscription
  extends Promise<AsyncIterator<DotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDotSubscription>() => T;
}

export interface CircleJoinRequestSubscriptionPayload {
  mutation: MutationType;
  node: CircleJoinRequest;
  updatedFields: String[];
  previousValues: CircleJoinRequestPreviousValues;
}

export interface CircleJoinRequestSubscriptionPayloadPromise
  extends Promise<CircleJoinRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CircleJoinRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CircleJoinRequestPreviousValuesPromise>() => T;
}

export interface CircleJoinRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CircleJoinRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CircleJoinRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CircleJoinRequestPreviousValuesSubscription>() => T;
}

export interface DonationEdge {
  node: Donation;
  cursor: String;
}

export interface DonationEdgePromise
  extends Promise<DonationEdge>,
    Fragmentable {
  node: <T = DonationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DonationEdgeSubscription
  extends Promise<AsyncIterator<DonationEdge>>,
    Fragmentable {
  node: <T = DonationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CircleJoinRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleJoinRequestPreviousValuesPromise
  extends Promise<CircleJoinRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CircleJoinRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<CircleJoinRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateCircleJoinRequest {
  count: Int;
}

export interface AggregateCircleJoinRequestPromise
  extends Promise<AggregateCircleJoinRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCircleJoinRequestSubscription
  extends Promise<AsyncIterator<AggregateCircleJoinRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Halo {
  id: ID_Output;
  createdAt: DateTimeOutput;
  key: String;
  tier?: String;
}

export interface HaloPromise extends Promise<Halo>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  tier: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface HaloSubscription
  extends Promise<AsyncIterator<Halo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  tier: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface HaloNullablePromise
  extends Promise<Halo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  tier: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface CircleJoinRequestConnection {
  pageInfo: PageInfo;
  edges: CircleJoinRequestEdge[];
}

export interface CircleJoinRequestConnectionPromise
  extends Promise<CircleJoinRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CircleJoinRequestEdge>>() => T;
  aggregate: <T = AggregateCircleJoinRequestPromise>() => T;
}

export interface CircleJoinRequestConnectionSubscription
  extends Promise<AsyncIterator<CircleJoinRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CircleJoinRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCircleJoinRequestSubscription>() => T;
}

export interface DonationSubscriptionPayload {
  mutation: MutationType;
  node: Donation;
  updatedFields: String[];
  previousValues: DonationPreviousValues;
}

export interface DonationSubscriptionPayloadPromise
  extends Promise<DonationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DonationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DonationPreviousValuesPromise>() => T;
}

export interface DonationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DonationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DonationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DonationPreviousValuesSubscription>() => T;
}

export interface CircleInviteEdge {
  node: CircleInvite;
  cursor: String;
}

export interface CircleInviteEdgePromise
  extends Promise<CircleInviteEdge>,
    Fragmentable {
  node: <T = CircleInvitePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CircleInviteEdgeSubscription
  extends Promise<AsyncIterator<CircleInviteEdge>>,
    Fragmentable {
  node: <T = CircleInviteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DonationPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amount: Int;
  batchKey: String;
  subBalance: Int;
  transferID: String;
}

export interface DonationPreviousValuesPromise
  extends Promise<DonationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  batchKey: () => Promise<String>;
  subBalance: () => Promise<Int>;
  transferID: () => Promise<String>;
}

export interface DonationPreviousValuesSubscription
  extends Promise<AsyncIterator<DonationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  batchKey: () => Promise<AsyncIterator<String>>;
  subBalance: () => Promise<AsyncIterator<Int>>;
  transferID: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCircle {
  count: Int;
}

export interface AggregateCirclePromise
  extends Promise<AggregateCircle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCircleSubscription
  extends Promise<AsyncIterator<AggregateCircle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Dot {
  id: ID_Output;
  createdAt: DateTimeOutput;
  action: String;
  amount: Int;
  total: Int;
}

export interface DotPromise extends Promise<Dot>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
  amount: () => Promise<Int>;
  total: () => Promise<Int>;
  user: <T = UserPromise>() => T;
}

export interface DotSubscription
  extends Promise<AsyncIterator<Dot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
}

export interface DotNullablePromise extends Promise<Dot | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
  amount: () => Promise<Int>;
  total: () => Promise<Int>;
  user: <T = UserPromise>() => T;
}

export interface CircleConnection {
  pageInfo: PageInfo;
  edges: CircleEdge[];
}

export interface CircleConnectionPromise
  extends Promise<CircleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CircleEdge>>() => T;
  aggregate: <T = AggregateCirclePromise>() => T;
}

export interface CircleConnectionSubscription
  extends Promise<AsyncIterator<CircleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CircleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCircleSubscription>() => T;
}

export interface DotSubscriptionPayload {
  mutation: MutationType;
  node: Dot;
  updatedFields: String[];
  previousValues: DotPreviousValues;
}

export interface DotSubscriptionPayloadPromise
  extends Promise<DotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DotPreviousValuesPromise>() => T;
}

export interface DotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DotPreviousValuesSubscription>() => T;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DotPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  action: String;
  amount: Int;
  total: Int;
}

export interface DotPreviousValuesPromise
  extends Promise<DotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
  amount: () => Promise<Int>;
  total: () => Promise<Int>;
}

export interface DotPreviousValuesSubscription
  extends Promise<AsyncIterator<DotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
}

export interface PreferencesEdge {
  node: Preferences;
  cursor: String;
}

export interface PreferencesEdgePromise
  extends Promise<PreferencesEdge>,
    Fragmentable {
  node: <T = PreferencesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PreferencesEdgeSubscription
  extends Promise<AsyncIterator<PreferencesEdge>>,
    Fragmentable {
  node: <T = PreferencesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Funds {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
}

export interface FundsPromise extends Promise<Funds>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amountAdded: () => Promise<Int>;
  amountNet: () => Promise<Int>;
  chargeID: () => Promise<String>;
  donations: <T = FragmentableArray<Donation>>(args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface FundsSubscription
  extends Promise<AsyncIterator<Funds>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amountAdded: () => Promise<AsyncIterator<Int>>;
  amountNet: () => Promise<AsyncIterator<Int>>;
  chargeID: () => Promise<AsyncIterator<String>>;
  donations: <T = Promise<AsyncIterator<DonationSubscription>>>(args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface FundsNullablePromise
  extends Promise<Funds | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amountAdded: () => Promise<Int>;
  amountNet: () => Promise<Int>;
  chargeID: () => Promise<String>;
  donations: <T = FragmentableArray<Donation>>(args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface LoopEdge {
  node: Loop;
  cursor: String;
}

export interface LoopEdgePromise extends Promise<LoopEdge>, Fragmentable {
  node: <T = LoopPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoopEdgeSubscription
  extends Promise<AsyncIterator<LoopEdge>>,
    Fragmentable {
  node: <T = LoopSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface IdentityConnection {
  pageInfo: PageInfo;
  edges: IdentityEdge[];
}

export interface IdentityConnectionPromise
  extends Promise<IdentityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IdentityEdge>>() => T;
  aggregate: <T = AggregateIdentityPromise>() => T;
}

export interface IdentityConnectionSubscription
  extends Promise<AsyncIterator<IdentityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IdentityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIdentitySubscription>() => T;
}

export interface EventPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  endDate: DateTimeOutput;
  goal: Int;
  multiplier?: Int;
  specialEvent?: String;
  specialEventDescription?: String;
  specialEventName?: String;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeOutput;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  goal: () => Promise<Int>;
  multiplier: () => Promise<Int>;
  specialEvent: () => Promise<String>;
  specialEventDescription: () => Promise<String>;
  specialEventName: () => Promise<String>;
  sponsorName: () => Promise<String>;
  sponsorWebsite: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  goal: () => Promise<AsyncIterator<Int>>;
  multiplier: () => Promise<AsyncIterator<Int>>;
  specialEvent: () => Promise<AsyncIterator<String>>;
  specialEventDescription: () => Promise<AsyncIterator<String>>;
  specialEventName: () => Promise<AsyncIterator<String>>;
  sponsorName: () => Promise<AsyncIterator<String>>;
  sponsorWebsite: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface HaloConnection {
  pageInfo: PageInfo;
  edges: HaloEdge[];
}

export interface HaloConnectionPromise
  extends Promise<HaloConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HaloEdge>>() => T;
  aggregate: <T = AggregateHaloPromise>() => T;
}

export interface HaloConnectionSubscription
  extends Promise<AsyncIterator<HaloConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HaloEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHaloSubscription>() => T;
}

export interface CircleInvite {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleInvitePromise
  extends Promise<CircleInvite>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  circle: <T = CirclePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CircleInviteSubscription
  extends Promise<AsyncIterator<CircleInvite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  circle: <T = CircleSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface CircleInviteNullablePromise
  extends Promise<CircleInvite | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  circle: <T = CirclePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface FundsSubscriptionPayload {
  mutation: MutationType;
  node: Funds;
  updatedFields: String[];
  previousValues: FundsPreviousValues;
}

export interface FundsSubscriptionPayloadPromise
  extends Promise<FundsSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FundsPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FundsPreviousValuesPromise>() => T;
}

export interface FundsSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FundsSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FundsSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FundsPreviousValuesSubscription>() => T;
}

export interface DotEdge {
  node: Dot;
  cursor: String;
}

export interface DotEdgePromise extends Promise<DotEdge>, Fragmentable {
  node: <T = DotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DotEdgeSubscription
  extends Promise<AsyncIterator<DotEdge>>,
    Fragmentable {
  node: <T = DotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface FundsPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
}

export interface FundsPreviousValuesPromise
  extends Promise<FundsPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amountAdded: () => Promise<Int>;
  amountNet: () => Promise<Int>;
  chargeID: () => Promise<String>;
}

export interface FundsPreviousValuesSubscription
  extends Promise<AsyncIterator<FundsPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amountAdded: () => Promise<AsyncIterator<Int>>;
  amountNet: () => Promise<AsyncIterator<Int>>;
  chargeID: () => Promise<AsyncIterator<String>>;
}

export interface DonationConnection {
  pageInfo: PageInfo;
  edges: DonationEdge[];
}

export interface DonationConnectionPromise
  extends Promise<DonationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DonationEdge>>() => T;
  aggregate: <T = AggregateDonationPromise>() => T;
}

export interface DonationConnectionSubscription
  extends Promise<AsyncIterator<DonationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DonationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDonationSubscription>() => T;
}

export interface Circle {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  name: String;
  open: Boolean;
}

export interface CirclePromise extends Promise<Circle>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  open: () => Promise<Boolean>;
  joinRequests: <T = FragmentableArray<CircleJoinRequest>>(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invites: <T = FragmentableArray<CircleInvite>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserPromise>() => T;
}

export interface CircleSubscription
  extends Promise<AsyncIterator<Circle>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
  joinRequests: <
    T = Promise<AsyncIterator<CircleJoinRequestSubscription>>
  >(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invites: <T = Promise<AsyncIterator<CircleInviteSubscription>>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserSubscription>() => T;
}

export interface CircleNullablePromise
  extends Promise<Circle | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  open: () => Promise<Boolean>;
  joinRequests: <T = FragmentableArray<CircleJoinRequest>>(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invites: <T = FragmentableArray<CircleInvite>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserPromise>() => T;
}

export interface AggregateCircleInvite {
  count: Int;
}

export interface AggregateCircleInvitePromise
  extends Promise<AggregateCircleInvite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCircleInviteSubscription
  extends Promise<AsyncIterator<AggregateCircleInvite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HaloSubscriptionPayload {
  mutation: MutationType;
  node: Halo;
  updatedFields: String[];
  previousValues: HaloPreviousValues;
}

export interface HaloSubscriptionPayloadPromise
  extends Promise<HaloSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HaloPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HaloPreviousValuesPromise>() => T;
}

export interface HaloSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HaloSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HaloSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HaloPreviousValuesSubscription>() => T;
}

export interface CircleEdge {
  node: Circle;
  cursor: String;
}

export interface CircleEdgePromise extends Promise<CircleEdge>, Fragmentable {
  node: <T = CirclePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CircleEdgeSubscription
  extends Promise<AsyncIterator<CircleEdge>>,
    Fragmentable {
  node: <T = CircleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HaloPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  key: String;
  tier?: String;
}

export interface HaloPreviousValuesPromise
  extends Promise<HaloPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  tier: () => Promise<String>;
}

export interface HaloPreviousValuesSubscription
  extends Promise<AsyncIterator<HaloPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  tier: () => Promise<AsyncIterator<String>>;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface CircleJoinRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleJoinRequestPromise
  extends Promise<CircleJoinRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  circle: <T = CirclePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CircleJoinRequestSubscription
  extends Promise<AsyncIterator<CircleJoinRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  circle: <T = CircleSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface CircleJoinRequestNullablePromise
  extends Promise<CircleJoinRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  circle: <T = CirclePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface AggregateIdentity {
  count: Int;
}

export interface AggregateIdentityPromise
  extends Promise<AggregateIdentity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIdentitySubscription
  extends Promise<AsyncIterator<AggregateIdentity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IdentitySubscriptionPayload {
  mutation: MutationType;
  node: Identity;
  updatedFields: String[];
  previousValues: IdentityPreviousValues;
}

export interface IdentitySubscriptionPayloadPromise
  extends Promise<IdentitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IdentityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IdentityPreviousValuesPromise>() => T;
}

export interface IdentitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IdentitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IdentitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IdentityPreviousValuesSubscription>() => T;
}

export interface FundsEdge {
  node: Funds;
  cursor: String;
}

export interface FundsEdgePromise extends Promise<FundsEdge>, Fragmentable {
  node: <T = FundsPromise>() => T;
  cursor: () => Promise<String>;
}

export interface FundsEdgeSubscription
  extends Promise<AsyncIterator<FundsEdge>>,
    Fragmentable {
  node: <T = FundsSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface IdentityPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  provider: IdentityProvider;
  providerID: String;
}

export interface IdentityPreviousValuesPromise
  extends Promise<IdentityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  provider: () => Promise<IdentityProvider>;
  providerID: () => Promise<String>;
}

export interface IdentityPreviousValuesSubscription
  extends Promise<AsyncIterator<IdentityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  provider: () => Promise<AsyncIterator<IdentityProvider>>;
  providerID: () => Promise<AsyncIterator<String>>;
}

export interface AggregateDonation {
  count: Int;
}

export interface AggregateDonationPromise
  extends Promise<AggregateDonation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDonationSubscription
  extends Promise<AsyncIterator<AggregateDonation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  email: () => Promise<String>;
  nameFirst: () => Promise<String>;
  nameLast: () => Promise<String>;
  picture: () => Promise<String>;
  securityToken: () => Promise<Int>;
  username: () => Promise<String>;
  circleJoinRequests: <T = FragmentableArray<CircleJoinRequest>>(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circleInvites: <T = FragmentableArray<CircleInvite>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circles: <T = FragmentableArray<Circle>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circlesOwned: <T = FragmentableArray<Circle>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dots: <T = FragmentableArray<Dot>>(args?: {
    where?: DotWhereInput;
    orderBy?: DotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followedCharities: <T = FragmentableArray<Charity>>(args?: {
    where?: CharityWhereInput;
    orderBy?: CharityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  halos: <T = FragmentableArray<Halo>>(args?: {
    where?: HaloWhereInput;
    orderBy?: HaloOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  identity: <T = IdentityPromise>() => T;
  loops: <T = FragmentableArray<Loop>>(args?: {
    where?: LoopWhereInput;
    orderBy?: LoopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preferences: <T = PreferencesPromise>() => T;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = FragmentableArray<Funds>>(args?: {
    where?: FundsWhereInput;
    orderBy?: FundsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bio: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameLast: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  securityToken: () => Promise<AsyncIterator<Int>>;
  username: () => Promise<AsyncIterator<String>>;
  circleJoinRequests: <
    T = Promise<AsyncIterator<CircleJoinRequestSubscription>>
  >(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circleInvites: <T = Promise<AsyncIterator<CircleInviteSubscription>>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circles: <T = Promise<AsyncIterator<CircleSubscription>>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circlesOwned: <T = Promise<AsyncIterator<CircleSubscription>>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dots: <T = Promise<AsyncIterator<DotSubscription>>>(args?: {
    where?: DotWhereInput;
    orderBy?: DotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followedCharities: <T = Promise<AsyncIterator<CharitySubscription>>>(args?: {
    where?: CharityWhereInput;
    orderBy?: CharityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  halos: <T = Promise<AsyncIterator<HaloSubscription>>>(args?: {
    where?: HaloWhereInput;
    orderBy?: HaloOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  identity: <T = IdentitySubscription>() => T;
  loops: <T = Promise<AsyncIterator<LoopSubscription>>>(args?: {
    where?: LoopWhereInput;
    orderBy?: LoopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preferences: <T = PreferencesSubscription>() => T;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = Promise<AsyncIterator<FundsSubscription>>>(args?: {
    where?: FundsWhereInput;
    orderBy?: FundsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  email: () => Promise<String>;
  nameFirst: () => Promise<String>;
  nameLast: () => Promise<String>;
  picture: () => Promise<String>;
  securityToken: () => Promise<Int>;
  username: () => Promise<String>;
  circleJoinRequests: <T = FragmentableArray<CircleJoinRequest>>(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circleInvites: <T = FragmentableArray<CircleInvite>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circles: <T = FragmentableArray<Circle>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circlesOwned: <T = FragmentableArray<Circle>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dots: <T = FragmentableArray<Dot>>(args?: {
    where?: DotWhereInput;
    orderBy?: DotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followedCharities: <T = FragmentableArray<Charity>>(args?: {
    where?: CharityWhereInput;
    orderBy?: CharityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  halos: <T = FragmentableArray<Halo>>(args?: {
    where?: HaloWhereInput;
    orderBy?: HaloOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  identity: <T = IdentityPromise>() => T;
  loops: <T = FragmentableArray<Loop>>(args?: {
    where?: LoopWhereInput;
    orderBy?: LoopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preferences: <T = PreferencesPromise>() => T;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = FragmentableArray<Funds>>(args?: {
    where?: FundsWhereInput;
    orderBy?: FundsOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CircleInviteConnection {
  pageInfo: PageInfo;
  edges: CircleInviteEdge[];
}

export interface CircleInviteConnectionPromise
  extends Promise<CircleInviteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CircleInviteEdge>>() => T;
  aggregate: <T = AggregateCircleInvitePromise>() => T;
}

export interface CircleInviteConnectionSubscription
  extends Promise<AsyncIterator<CircleInviteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CircleInviteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCircleInviteSubscription>() => T;
}

export interface Charity {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  acronym?: String;
  bannerCredit?: String;
  connectedAccountID?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
}

export interface CharityPromise extends Promise<Charity>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  acronym: () => Promise<String>;
  bannerCredit: () => Promise<String>;
  connectedAccountID: () => Promise<String>;
  ein: () => Promise<String>;
  expensesAdministrative: () => Promise<Float>;
  expensesFundraising: () => Promise<Float>;
  expensesOther: () => Promise<Float>;
  expensesProgram: () => Promise<Float>;
  expensesUpdated: () => Promise<String>;
  location: () => Promise<String>;
  mission: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  website: () => Promise<String>;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CharitySubscription
  extends Promise<AsyncIterator<Charity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  acronym: () => Promise<AsyncIterator<String>>;
  bannerCredit: () => Promise<AsyncIterator<String>>;
  connectedAccountID: () => Promise<AsyncIterator<String>>;
  ein: () => Promise<AsyncIterator<String>>;
  expensesAdministrative: () => Promise<AsyncIterator<Float>>;
  expensesFundraising: () => Promise<AsyncIterator<Float>>;
  expensesOther: () => Promise<AsyncIterator<Float>>;
  expensesProgram: () => Promise<AsyncIterator<Float>>;
  expensesUpdated: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  mission: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CharityNullablePromise
  extends Promise<Charity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  acronym: () => Promise<String>;
  bannerCredit: () => Promise<String>;
  connectedAccountID: () => Promise<String>;
  ein: () => Promise<String>;
  expensesAdministrative: () => Promise<Float>;
  expensesFundraising: () => Promise<Float>;
  expensesOther: () => Promise<Float>;
  expensesProgram: () => Promise<Float>;
  expensesUpdated: () => Promise<String>;
  location: () => Promise<String>;
  mission: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  website: () => Promise<String>;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PreferencesSubscriptionPayload {
  mutation: MutationType;
  node: Preferences;
  updatedFields: String[];
  previousValues: PreferencesPreviousValues;
}

export interface PreferencesSubscriptionPayloadPromise
  extends Promise<PreferencesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PreferencesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PreferencesPreviousValuesPromise>() => T;
}

export interface PreferencesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PreferencesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PreferencesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PreferencesPreviousValuesSubscription>() => T;
}

export interface Transaction {
  id: Int;
  createdAt: DateTimeOutput;
  balance: Int;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  balance: () => Promise<Int>;
  donations: <T = FragmentableArray<Donation>>(args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = FundsPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  balance: () => Promise<AsyncIterator<Int>>;
  donations: <T = Promise<AsyncIterator<DonationSubscription>>>(args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = FundsSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface TransactionNullablePromise
  extends Promise<Transaction | null>,
    Fragmentable {
  id: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  balance: () => Promise<Int>;
  donations: <T = FragmentableArray<Donation>>(args?: {
    where?: DonationWhereInput;
    orderBy?: DonationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = FundsPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface LoopPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  count: Int;
}

export interface LoopPreviousValuesPromise
  extends Promise<LoopPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  count: () => Promise<Int>;
}

export interface LoopPreviousValuesSubscription
  extends Promise<AsyncIterator<LoopPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoopSubscriptionPayload {
  mutation: MutationType;
  node: Loop;
  updatedFields: String[];
  previousValues: LoopPreviousValues;
}

export interface LoopSubscriptionPayloadPromise
  extends Promise<LoopSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LoopPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoopPreviousValuesPromise>() => T;
}

export interface LoopSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoopSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoopSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoopPreviousValuesSubscription>() => T;
}

export interface AggregateHalo {
  count: Int;
}

export interface AggregateHaloPromise
  extends Promise<AggregateHalo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHaloSubscription
  extends Promise<AsyncIterator<AggregateHalo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CircleJoinRequestEdge {
  node: CircleJoinRequest;
  cursor: String;
}

export interface CircleJoinRequestEdgePromise
  extends Promise<CircleJoinRequestEdge>,
    Fragmentable {
  node: <T = CircleJoinRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CircleJoinRequestEdgeSubscription
  extends Promise<AsyncIterator<CircleJoinRequestEdge>>,
    Fragmentable {
  node: <T = CircleJoinRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export type Long = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Dot",
    embedded: false
  },
  {
    name: "Halo",
    embedded: false
  },
  {
    name: "Identity",
    embedded: false
  },
  {
    name: "Loop",
    embedded: false
  },
  {
    name: "Preferences",
    embedded: false
  },
  {
    name: "Circle",
    embedded: false
  },
  {
    name: "CircleJoinRequest",
    embedded: false
  },
  {
    name: "CircleInvite",
    embedded: false
  },
  {
    name: "Charity",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Donation",
    embedded: false
  },
  {
    name: "Funds",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  },
  {
    name: "IdentityProvider",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
