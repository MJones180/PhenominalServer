// Code generated by Prisma (prisma@1.18.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode, GraphQLSchema } from "graphql";
import { IResolvers } from "graphql-tools/dist/Interfaces";
import { makePrismaClientClass, BaseClientOptions } from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  charity: (where?: CharityWhereInput) => Promise<boolean>;
  circle: (where?: CircleWhereInput) => Promise<boolean>;
  dot: (where?: DotWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  halo: (where?: HaloWhereInput) => Promise<boolean>;
  identity: (where?: IdentityWhereInput) => Promise<boolean>;
  loop: (where?: LoopWhereInput) => Promise<boolean>;
  preferences: (where?: PreferencesWhereInput) => Promise<boolean>;
  specialFundraiser: (where?: SpecialFundraiserWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;
  $getAbstractResolvers(filterSchema?: GraphQLSchema | string): IResolvers;

  /**
   * Queries
   */

  charity: (where: CharityWhereUniqueInput) => Charity;
  charities: (
    args?: {
      where?: CharityWhereInput;
      orderBy?: CharityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CharityNode>;
  charitiesConnection: (
    args?: {
      where?: CharityWhereInput;
      orderBy?: CharityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CharityConnection;
  circle: (where: CircleWhereUniqueInput) => Circle;
  circles: (
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CircleNode>;
  circlesConnection: (
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CircleConnection;
  dot: (where: DotWhereUniqueInput) => Dot;
  dots: (
    args?: {
      where?: DotWhereInput;
      orderBy?: DotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<DotNode>;
  dotsConnection: (
    args?: {
      where?: DotWhereInput;
      orderBy?: DotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DotConnection;
  event: (where: EventWhereUniqueInput) => Event;
  events: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<EventNode>;
  eventsConnection: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EventConnection;
  halo: (where: HaloWhereUniqueInput) => Halo;
  haloes: (
    args?: {
      where?: HaloWhereInput;
      orderBy?: HaloOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<HaloNode>;
  haloesConnection: (
    args?: {
      where?: HaloWhereInput;
      orderBy?: HaloOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HaloConnection;
  identity: (where: IdentityWhereUniqueInput) => Identity;
  identities: (
    args?: {
      where?: IdentityWhereInput;
      orderBy?: IdentityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<IdentityNode>;
  identitiesConnection: (
    args?: {
      where?: IdentityWhereInput;
      orderBy?: IdentityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => IdentityConnection;
  loop: (where: LoopWhereUniqueInput) => Loop;
  loops: (
    args?: {
      where?: LoopWhereInput;
      orderBy?: LoopOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<LoopNode>;
  loopsConnection: (
    args?: {
      where?: LoopWhereInput;
      orderBy?: LoopOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LoopConnection;
  preferences: (where: PreferencesWhereUniqueInput) => Preferences;
  preferenceses: (
    args?: {
      where?: PreferencesWhereInput;
      orderBy?: PreferencesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<PreferencesNode>;
  preferencesesConnection: (
    args?: {
      where?: PreferencesWhereInput;
      orderBy?: PreferencesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PreferencesConnection;
  specialFundraiser: (
    where: SpecialFundraiserWhereUniqueInput
  ) => SpecialFundraiser;
  specialFundraisers: (
    args?: {
      where?: SpecialFundraiserWhereInput;
      orderBy?: SpecialFundraiserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SpecialFundraiserNode>;
  specialFundraisersConnection: (
    args?: {
      where?: SpecialFundraiserWhereInput;
      orderBy?: SpecialFundraiserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SpecialFundraiserConnection;
  transaction: (where: TransactionWhereUniqueInput) => Transaction;
  transactions: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TransactionNode>;
  transactionsConnection: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransactionConnection;
  user: (where: UserWhereUniqueInput) => User;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<UserNode>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnection;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCharity: (data: CharityCreateInput) => Charity;
  updateCharity: (
    args: { data: CharityUpdateInput; where: CharityWhereUniqueInput }
  ) => Charity;
  updateManyCharities: (
    args: { data: CharityUpdateInput; where?: CharityWhereInput }
  ) => BatchPayload;
  upsertCharity: (
    args: {
      where: CharityWhereUniqueInput;
      create: CharityCreateInput;
      update: CharityUpdateInput;
    }
  ) => Charity;
  deleteCharity: (where: CharityWhereUniqueInput) => Charity;
  deleteManyCharities: (where?: CharityWhereInput) => BatchPayload;
  createCircle: (data: CircleCreateInput) => Circle;
  updateCircle: (
    args: { data: CircleUpdateInput; where: CircleWhereUniqueInput }
  ) => Circle;
  updateManyCircles: (
    args: { data: CircleUpdateInput; where?: CircleWhereInput }
  ) => BatchPayload;
  upsertCircle: (
    args: {
      where: CircleWhereUniqueInput;
      create: CircleCreateInput;
      update: CircleUpdateInput;
    }
  ) => Circle;
  deleteCircle: (where: CircleWhereUniqueInput) => Circle;
  deleteManyCircles: (where?: CircleWhereInput) => BatchPayload;
  createDot: (data: DotCreateInput) => Dot;
  updateDot: (
    args: { data: DotUpdateInput; where: DotWhereUniqueInput }
  ) => Dot;
  updateManyDots: (
    args: { data: DotUpdateInput; where?: DotWhereInput }
  ) => BatchPayload;
  upsertDot: (
    args: {
      where: DotWhereUniqueInput;
      create: DotCreateInput;
      update: DotUpdateInput;
    }
  ) => Dot;
  deleteDot: (where: DotWhereUniqueInput) => Dot;
  deleteManyDots: (where?: DotWhereInput) => BatchPayload;
  createEvent: (data: EventCreateInput) => Event;
  updateEvent: (
    args: { data: EventUpdateInput; where: EventWhereUniqueInput }
  ) => Event;
  updateManyEvents: (
    args: { data: EventUpdateInput; where?: EventWhereInput }
  ) => BatchPayload;
  upsertEvent: (
    args: {
      where: EventWhereUniqueInput;
      create: EventCreateInput;
      update: EventUpdateInput;
    }
  ) => Event;
  deleteEvent: (where: EventWhereUniqueInput) => Event;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayload;
  createHalo: (data: HaloCreateInput) => Halo;
  updateHalo: (
    args: { data: HaloUpdateInput; where: HaloWhereUniqueInput }
  ) => Halo;
  updateManyHaloes: (
    args: { data: HaloUpdateInput; where?: HaloWhereInput }
  ) => BatchPayload;
  upsertHalo: (
    args: {
      where: HaloWhereUniqueInput;
      create: HaloCreateInput;
      update: HaloUpdateInput;
    }
  ) => Halo;
  deleteHalo: (where: HaloWhereUniqueInput) => Halo;
  deleteManyHaloes: (where?: HaloWhereInput) => BatchPayload;
  createIdentity: (data: IdentityCreateInput) => Identity;
  updateIdentity: (
    args: { data: IdentityUpdateInput; where: IdentityWhereUniqueInput }
  ) => Identity;
  updateManyIdentities: (
    args: { data: IdentityUpdateInput; where?: IdentityWhereInput }
  ) => BatchPayload;
  upsertIdentity: (
    args: {
      where: IdentityWhereUniqueInput;
      create: IdentityCreateInput;
      update: IdentityUpdateInput;
    }
  ) => Identity;
  deleteIdentity: (where: IdentityWhereUniqueInput) => Identity;
  deleteManyIdentities: (where?: IdentityWhereInput) => BatchPayload;
  createLoop: (data: LoopCreateInput) => Loop;
  updateLoop: (
    args: { data: LoopUpdateInput; where: LoopWhereUniqueInput }
  ) => Loop;
  updateManyLoops: (
    args: { data: LoopUpdateInput; where?: LoopWhereInput }
  ) => BatchPayload;
  upsertLoop: (
    args: {
      where: LoopWhereUniqueInput;
      create: LoopCreateInput;
      update: LoopUpdateInput;
    }
  ) => Loop;
  deleteLoop: (where: LoopWhereUniqueInput) => Loop;
  deleteManyLoops: (where?: LoopWhereInput) => BatchPayload;
  createPreferences: (data: PreferencesCreateInput) => Preferences;
  updatePreferences: (
    args: { data: PreferencesUpdateInput; where: PreferencesWhereUniqueInput }
  ) => Preferences;
  updateManyPreferenceses: (
    args: { data: PreferencesUpdateInput; where?: PreferencesWhereInput }
  ) => BatchPayload;
  upsertPreferences: (
    args: {
      where: PreferencesWhereUniqueInput;
      create: PreferencesCreateInput;
      update: PreferencesUpdateInput;
    }
  ) => Preferences;
  deletePreferences: (where: PreferencesWhereUniqueInput) => Preferences;
  deleteManyPreferenceses: (where?: PreferencesWhereInput) => BatchPayload;
  createSpecialFundraiser: (
    data: SpecialFundraiserCreateInput
  ) => SpecialFundraiser;
  updateSpecialFundraiser: (
    args: {
      data: SpecialFundraiserUpdateInput;
      where: SpecialFundraiserWhereUniqueInput;
    }
  ) => SpecialFundraiser;
  updateManySpecialFundraisers: (
    args: {
      data: SpecialFundraiserUpdateInput;
      where?: SpecialFundraiserWhereInput;
    }
  ) => BatchPayload;
  upsertSpecialFundraiser: (
    args: {
      where: SpecialFundraiserWhereUniqueInput;
      create: SpecialFundraiserCreateInput;
      update: SpecialFundraiserUpdateInput;
    }
  ) => SpecialFundraiser;
  deleteSpecialFundraiser: (
    where: SpecialFundraiserWhereUniqueInput
  ) => SpecialFundraiser;
  deleteManySpecialFundraisers: (
    where?: SpecialFundraiserWhereInput
  ) => BatchPayload;
  createTransaction: (data: TransactionCreateInput) => Transaction;
  updateTransaction: (
    args: { data: TransactionUpdateInput; where: TransactionWhereUniqueInput }
  ) => Transaction;
  updateManyTransactions: (
    args: { data: TransactionUpdateInput; where?: TransactionWhereInput }
  ) => BatchPayload;
  upsertTransaction: (
    args: {
      where: TransactionWhereUniqueInput;
      create: TransactionCreateInput;
      update: TransactionUpdateInput;
    }
  ) => Transaction;
  deleteTransaction: (where: TransactionWhereUniqueInput) => Transaction;
  deleteManyTransactions: (where?: TransactionWhereInput) => BatchPayload;
  createUser: (data: UserCreateInput) => User;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => User;
  updateManyUsers: (
    args: { data: UserUpdateInput; where?: UserWhereInput }
  ) => BatchPayload;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => User;
  deleteUser: (where: UserWhereUniqueInput) => User;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayload;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  charity: (
    where?: CharitySubscriptionWhereInput
  ) => CharitySubscriptionPayloadSubscription;
  circle: (
    where?: CircleSubscriptionWhereInput
  ) => CircleSubscriptionPayloadSubscription;
  dot: (
    where?: DotSubscriptionWhereInput
  ) => DotSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  halo: (
    where?: HaloSubscriptionWhereInput
  ) => HaloSubscriptionPayloadSubscription;
  identity: (
    where?: IdentitySubscriptionWhereInput
  ) => IdentitySubscriptionPayloadSubscription;
  loop: (
    where?: LoopSubscriptionWhereInput
  ) => LoopSubscriptionPayloadSubscription;
  preferences: (
    where?: PreferencesSubscriptionWhereInput
  ) => PreferencesSubscriptionPayloadSubscription;
  specialFundraiser: (
    where?: SpecialFundraiserSubscriptionWhereInput
  ) => SpecialFundraiserSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type CharityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "acronym_ASC"
  | "acronym_DESC"
  | "bannerCredit_ASC"
  | "bannerCredit_DESC"
  | "ein_ASC"
  | "ein_DESC"
  | "expensesAdministrative_ASC"
  | "expensesAdministrative_DESC"
  | "expensesFundraising_ASC"
  | "expensesFundraising_DESC"
  | "expensesOther_ASC"
  | "expensesOther_DESC"
  | "expensesProgram_ASC"
  | "expensesProgram_DESC"
  | "expensesUpdated_ASC"
  | "expensesUpdated_DESC"
  | "location_ASC"
  | "location_DESC"
  | "mission_ASC"
  | "mission_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "website_ASC"
  | "website_DESC";

export type IdentityProvider = "FACEBOOK" | "GOOGLE";

export type DotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "action_ASC"
  | "action_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "total_ASC"
  | "total_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type SpecialFundraiserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "email_ASC"
  | "email_DESC"
  | "nameFirst_ASC"
  | "nameFirst_DESC"
  | "nameLast_ASC"
  | "nameLast_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "securityToken_ASC"
  | "securityToken_DESC"
  | "username_ASC"
  | "username_DESC";

export type IdentityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "provider_ASC"
  | "provider_DESC"
  | "providerID_ASC"
  | "providerID_DESC";

export type TransactionType = "DONATION" | "ADD_FUNDS";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "goal_ASC"
  | "goal_DESC"
  | "multiplier_ASC"
  | "multiplier_DESC"
  | "sponsorName_ASC"
  | "sponsorName_DESC"
  | "sponsorWebsite_ASC"
  | "sponsorWebsite_DESC"
  | "startDate_ASC"
  | "startDate_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "balance_ASC"
  | "balance_DESC"
  | "key_ASC"
  | "key_DESC"
  | "stripeID_ASC"
  | "stripeID_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CircleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "open_ASC"
  | "open_DESC";

export type LoopOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "count_ASC"
  | "count_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PreferencesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "allowDonationEmails_ASC"
  | "allowDonationEmails_DESC"
  | "publicProfile_ASC"
  | "publicProfile_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type HaloOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "key_ASC"
  | "key_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface CircleUpdateWithoutUsersDataInput {
  description?: String;
  name?: String;
  open?: Boolean;
  owner?: UserUpdateOneRequiredWithoutCirclesOwnedInput;
}

export type CharityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  ein?: String;
}>;

export interface CharityUpdateWithWhereUniqueWithoutFollowersInput {
  where: CharityWhereUniqueInput;
  data: CharityUpdateWithoutFollowersDataInput;
}

export interface LoopWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  count?: Int;
  count_not?: Int;
  count_in?: Int[] | Int;
  count_not_in?: Int[] | Int;
  count_lt?: Int;
  count_lte?: Int;
  count_gt?: Int;
  count_gte?: Int;
  event?: EventWhereInput;
  user?: UserWhereInput;
  AND?: LoopWhereInput[] | LoopWhereInput;
  OR?: LoopWhereInput[] | LoopWhereInput;
  NOT?: LoopWhereInput[] | LoopWhereInput;
}

export interface CharityUpdateWithoutFollowersDataInput {
  acronym?: String;
  bannerCredit?: String;
  ein?: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location?: String;
  mission?: String;
  name?: String;
  phoneNumber?: String;
  website?: String;
  events?: EventUpdateManyWithoutCharityInput;
}

export interface TransactionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  balance?: Int;
  balance_not?: Int;
  balance_in?: Int[] | Int;
  balance_not_in?: Int[] | Int;
  balance_lt?: Int;
  balance_lte?: Int;
  balance_gt?: Int;
  balance_gte?: Int;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  stripeID?: String;
  stripeID_not?: String;
  stripeID_in?: String[] | String;
  stripeID_not_in?: String[] | String;
  stripeID_lt?: String;
  stripeID_lte?: String;
  stripeID_gt?: String;
  stripeID_gte?: String;
  stripeID_contains?: String;
  stripeID_not_contains?: String;
  stripeID_starts_with?: String;
  stripeID_not_starts_with?: String;
  stripeID_ends_with?: String;
  stripeID_not_ends_with?: String;
  type?: TransactionType;
  type_not?: TransactionType;
  type_in?: TransactionType[] | TransactionType;
  type_not_in?: TransactionType[] | TransactionType;
  event?: EventWhereInput;
  user?: UserWhereInput;
  AND?: TransactionWhereInput[] | TransactionWhereInput;
  OR?: TransactionWhereInput[] | TransactionWhereInput;
  NOT?: TransactionWhereInput[] | TransactionWhereInput;
}

export interface CharityUpsertWithWhereUniqueWithoutFollowersInput {
  where: CharityWhereUniqueInput;
  update: CharityUpdateWithoutFollowersDataInput;
  create: CharityCreateWithoutFollowersInput;
}

export interface SpecialFundraiserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  event?: EventWhereInput;
  AND?: SpecialFundraiserWhereInput[] | SpecialFundraiserWhereInput;
  OR?: SpecialFundraiserWhereInput[] | SpecialFundraiserWhereInput;
  NOT?: SpecialFundraiserWhereInput[] | SpecialFundraiserWhereInput;
}

export interface UserCreateManyWithoutFollowedCharitiesInput {
  create?:
    | UserCreateWithoutFollowedCharitiesInput[]
    | UserCreateWithoutFollowedCharitiesInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserUpsertWithoutDotsInput {
  update: UserUpdateWithoutDotsDataInput;
  create: UserCreateWithoutDotsInput;
}

export interface UserCreateWithoutFollowedCharitiesInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circles?: CircleCreateManyWithoutUsersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface HaloUpdateManyWithoutUserInput {
  create?: HaloCreateWithoutUserInput[] | HaloCreateWithoutUserInput;
  delete?: HaloWhereUniqueInput[] | HaloWhereUniqueInput;
  connect?: HaloWhereUniqueInput[] | HaloWhereUniqueInput;
  disconnect?: HaloWhereUniqueInput[] | HaloWhereUniqueInput;
  update?:
    | HaloUpdateWithWhereUniqueWithoutUserInput[]
    | HaloUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | HaloUpsertWithWhereUniqueWithoutUserInput[]
    | HaloUpsertWithWhereUniqueWithoutUserInput;
}

export interface CircleCreateManyWithoutOwnerInput {
  create?: CircleCreateWithoutOwnerInput[] | CircleCreateWithoutOwnerInput;
  connect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface CircleCreateWithoutOwnerInput {
  description?: String;
  name: String;
  open?: Boolean;
  users?: UserCreateManyWithoutCirclesInput;
}

export interface SpecialFundraiserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SpecialFundraiserWhereInput;
  AND?:
    | SpecialFundraiserSubscriptionWhereInput[]
    | SpecialFundraiserSubscriptionWhereInput;
  OR?:
    | SpecialFundraiserSubscriptionWhereInput[]
    | SpecialFundraiserSubscriptionWhereInput;
  NOT?:
    | SpecialFundraiserSubscriptionWhereInput[]
    | SpecialFundraiserSubscriptionWhereInput;
}

export interface UserCreateManyWithoutCirclesInput {
  create?: UserCreateWithoutCirclesInput[] | UserCreateWithoutCirclesInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface CircleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  open?: Boolean;
  open_not?: Boolean;
  owner?: UserWhereInput;
  users_every?: UserWhereInput;
  users_some?: UserWhereInput;
  users_none?: UserWhereInput;
  AND?: CircleWhereInput[] | CircleWhereInput;
  OR?: CircleWhereInput[] | CircleWhereInput;
  NOT?: CircleWhereInput[] | CircleWhereInput;
}

export interface UserCreateWithoutCirclesInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface LoopSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LoopWhereInput;
  AND?: LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput;
  OR?: LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput;
  NOT?: LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput;
}

export interface PreferencesCreateOneWithoutUserInput {
  create?: PreferencesCreateWithoutUserInput;
  connect?: PreferencesWhereUniqueInput;
}

export interface IdentitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: IdentityWhereInput;
  AND?: IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput;
  OR?: IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput;
  NOT?: IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput;
}

export interface PreferencesCreateWithoutUserInput {
  allowDonationEmails?: Boolean;
  publicProfile?: Boolean;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EventWhereInput;
  AND?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  OR?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  NOT?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
}

export interface TransactionCreateManyWithoutUserInput {
  create?:
    | TransactionCreateWithoutUserInput[]
    | TransactionCreateWithoutUserInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
}

export interface DotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DotWhereInput;
  AND?: DotSubscriptionWhereInput[] | DotSubscriptionWhereInput;
  OR?: DotSubscriptionWhereInput[] | DotSubscriptionWhereInput;
  NOT?: DotSubscriptionWhereInput[] | DotSubscriptionWhereInput;
}

export interface TransactionCreateWithoutUserInput {
  amount: Int;
  balance: Int;
  key: String;
  stripeID?: String;
  type: TransactionType;
  event?: EventCreateOneWithoutDonationsInput;
}

export interface CharitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CharityWhereInput;
  AND?: CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput;
  OR?: CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput;
  NOT?: CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput;
}

export interface EventCreateOneWithoutDonationsInput {
  create?: EventCreateWithoutDonationsInput;
  connect?: EventWhereUniqueInput;
}

export interface UserCreateInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circles?: CircleCreateManyWithoutUsersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface EventCreateWithoutDonationsInput {
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeInput;
  charity?: CharityCreateOneWithoutEventsInput;
  specialFundraiser?: SpecialFundraiserCreateOneWithoutEventInput;
}

export type CircleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CharityUpdateInput {
  acronym?: String;
  bannerCredit?: String;
  ein?: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location?: String;
  mission?: String;
  name?: String;
  phoneNumber?: String;
  website?: String;
  events?: EventUpdateManyWithoutCharityInput;
  followers?: UserUpdateManyWithoutFollowedCharitiesInput;
}

export interface EventUpsertWithoutSpecialFundraiserInput {
  update: EventUpdateWithoutSpecialFundraiserDataInput;
  create: EventCreateWithoutSpecialFundraiserInput;
}

export interface EventUpdateManyWithoutCharityInput {
  create?: EventCreateWithoutCharityInput[] | EventCreateWithoutCharityInput;
  delete?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  disconnect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  update?:
    | EventUpdateWithWhereUniqueWithoutCharityInput[]
    | EventUpdateWithWhereUniqueWithoutCharityInput;
  upsert?:
    | EventUpsertWithWhereUniqueWithoutCharityInput[]
    | EventUpsertWithWhereUniqueWithoutCharityInput;
}

export type DotWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EventUpdateWithWhereUniqueWithoutCharityInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutCharityDataInput;
}

export interface SpecialFundraiserUpdateInput {
  description?: String;
  name?: String;
  event?: EventUpdateOneRequiredWithoutSpecialFundraiserInput;
}

export interface EventUpdateWithoutCharityDataInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
  specialFundraiser?: SpecialFundraiserUpdateOneWithoutEventInput;
  donations?: TransactionUpdateManyWithoutEventInput;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SpecialFundraiserUpdateOneWithoutEventInput {
  create?: SpecialFundraiserCreateWithoutEventInput;
  update?: SpecialFundraiserUpdateWithoutEventDataInput;
  upsert?: SpecialFundraiserUpsertWithoutEventInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SpecialFundraiserWhereUniqueInput;
}

export interface SpecialFundraiserCreateInput {
  description: String;
  name: String;
  event: EventCreateOneWithoutSpecialFundraiserInput;
}

export interface SpecialFundraiserUpdateWithoutEventDataInput {
  description?: String;
  name?: String;
}

export type HaloWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface SpecialFundraiserUpsertWithoutEventInput {
  update: SpecialFundraiserUpdateWithoutEventDataInput;
  create: SpecialFundraiserCreateWithoutEventInput;
}

export interface UserUpdateOneRequiredWithoutPreferencesInput {
  create?: UserCreateWithoutPreferencesInput;
  update?: UserUpdateWithoutPreferencesDataInput;
  upsert?: UserUpsertWithoutPreferencesInput;
  connect?: UserWhereUniqueInput;
}

export interface TransactionUpdateManyWithoutEventInput {
  create?:
    | TransactionCreateWithoutEventInput[]
    | TransactionCreateWithoutEventInput;
  delete?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  disconnect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  update?:
    | TransactionUpdateWithWhereUniqueWithoutEventInput[]
    | TransactionUpdateWithWhereUniqueWithoutEventInput;
  upsert?:
    | TransactionUpsertWithWhereUniqueWithoutEventInput[]
    | TransactionUpsertWithWhereUniqueWithoutEventInput;
}

export type IdentityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  providerID?: String;
}>;

export interface TransactionUpdateWithWhereUniqueWithoutEventInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutEventDataInput;
}

export interface UserCreateOneWithoutPreferencesInput {
  create?: UserCreateWithoutPreferencesInput;
  connect?: UserWhereUniqueInput;
}

export interface TransactionUpdateWithoutEventDataInput {
  amount?: Int;
  balance?: Int;
  key?: String;
  stripeID?: String;
  type?: TransactionType;
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
}

export interface UserUpsertWithoutLoopsInput {
  update: UserUpdateWithoutLoopsDataInput;
  create: UserCreateWithoutLoopsInput;
}

export interface UserUpdateOneRequiredWithoutTransactionsInput {
  create?: UserCreateWithoutTransactionsInput;
  update?: UserUpdateWithoutTransactionsDataInput;
  upsert?: UserUpsertWithoutTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutLoopsDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circles?: CircleUpdateManyWithoutUsersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface UserUpdateWithoutTransactionsDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circles?: CircleUpdateManyWithoutUsersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
}

export interface LoopUpdateInput {
  count?: Int;
  event?: EventUpdateOneRequiredInput;
  user?: UserUpdateOneRequiredWithoutLoopsInput;
}

export interface CircleUpdateManyWithoutUsersInput {
  create?: CircleCreateWithoutUsersInput[] | CircleCreateWithoutUsersInput;
  delete?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  connect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  disconnect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  update?:
    | CircleUpdateWithWhereUniqueWithoutUsersInput[]
    | CircleUpdateWithWhereUniqueWithoutUsersInput;
  upsert?:
    | CircleUpsertWithWhereUniqueWithoutUsersInput[]
    | CircleUpsertWithWhereUniqueWithoutUsersInput;
}

export interface UserCreateWithoutLoopsInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circles?: CircleCreateManyWithoutUsersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface CircleUpdateWithWhereUniqueWithoutUsersInput {
  where: CircleWhereUniqueInput;
  data: CircleUpdateWithoutUsersDataInput;
}

export interface LoopCreateInput {
  count: Int;
  event: EventCreateOneInput;
  user: UserCreateOneWithoutLoopsInput;
}

export interface UserCreateWithoutHalosInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circles?: CircleCreateManyWithoutUsersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export type SpecialFundraiserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneRequiredWithoutCirclesOwnedInput {
  create?: UserCreateWithoutCirclesOwnedInput;
  update?: UserUpdateWithoutCirclesOwnedDataInput;
  upsert?: UserUpsertWithoutCirclesOwnedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutIdentityInput {
  create?: UserCreateWithoutIdentityInput;
  update?: UserUpdateWithoutIdentityDataInput;
  upsert?: UserUpsertWithoutIdentityInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCirclesOwnedDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circles?: CircleUpdateManyWithoutUsersInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface UserCreateWithoutIdentityInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circles?: CircleCreateManyWithoutUsersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface DotUpdateManyWithoutUserInput {
  create?: DotCreateWithoutUserInput[] | DotCreateWithoutUserInput;
  delete?: DotWhereUniqueInput[] | DotWhereUniqueInput;
  connect?: DotWhereUniqueInput[] | DotWhereUniqueInput;
  disconnect?: DotWhereUniqueInput[] | DotWhereUniqueInput;
  update?:
    | DotUpdateWithWhereUniqueWithoutUserInput[]
    | DotUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | DotUpsertWithWhereUniqueWithoutUserInput[]
    | DotUpsertWithWhereUniqueWithoutUserInput;
}

export interface UserCreateOneWithoutIdentityInput {
  create?: UserCreateWithoutIdentityInput;
  connect?: UserWhereUniqueInput;
}

export interface DotUpdateWithWhereUniqueWithoutUserInput {
  where: DotWhereUniqueInput;
  data: DotUpdateWithoutUserDataInput;
}

export interface UserUpsertWithoutHalosInput {
  update: UserUpdateWithoutHalosDataInput;
  create: UserCreateWithoutHalosInput;
}

export interface DotUpdateWithoutUserDataInput {
  action?: String;
  amount?: Int;
  total?: Int;
}

export interface UserUpdateWithoutHalosDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circles?: CircleUpdateManyWithoutUsersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface DotUpsertWithWhereUniqueWithoutUserInput {
  where: DotWhereUniqueInput;
  update: DotUpdateWithoutUserDataInput;
  create: DotCreateWithoutUserInput;
}

export interface HaloUpdateInput {
  key?: String;
  user?: UserUpdateOneRequiredWithoutHalosInput;
}

export interface CharityUpdateManyWithoutFollowersInput {
  create?:
    | CharityCreateWithoutFollowersInput[]
    | CharityCreateWithoutFollowersInput;
  delete?: CharityWhereUniqueInput[] | CharityWhereUniqueInput;
  connect?: CharityWhereUniqueInput[] | CharityWhereUniqueInput;
  disconnect?: CharityWhereUniqueInput[] | CharityWhereUniqueInput;
  update?:
    | CharityUpdateWithWhereUniqueWithoutFollowersInput[]
    | CharityUpdateWithWhereUniqueWithoutFollowersInput;
  upsert?:
    | CharityUpsertWithWhereUniqueWithoutFollowersInput[]
    | CharityUpsertWithWhereUniqueWithoutFollowersInput;
}

export interface CharityCreateInput {
  acronym?: String;
  bannerCredit?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
  events?: EventCreateManyWithoutCharityInput;
  followers?: UserCreateManyWithoutFollowedCharitiesInput;
}

export interface PreferencesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  allowDonationEmails?: Boolean;
  allowDonationEmails_not?: Boolean;
  publicProfile?: Boolean;
  publicProfile_not?: Boolean;
  user?: UserWhereInput;
  AND?: PreferencesWhereInput[] | PreferencesWhereInput;
  OR?: PreferencesWhereInput[] | PreferencesWhereInput;
  NOT?: PreferencesWhereInput[] | PreferencesWhereInput;
}

export interface EventCreateWithoutCharityInput {
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeInput;
  specialFundraiser?: SpecialFundraiserCreateOneWithoutEventInput;
  donations?: TransactionCreateManyWithoutEventInput;
}

export interface IdentityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  provider?: IdentityProvider;
  provider_not?: IdentityProvider;
  provider_in?: IdentityProvider[] | IdentityProvider;
  provider_not_in?: IdentityProvider[] | IdentityProvider;
  providerID?: String;
  providerID_not?: String;
  providerID_in?: String[] | String;
  providerID_not_in?: String[] | String;
  providerID_lt?: String;
  providerID_lte?: String;
  providerID_gt?: String;
  providerID_gte?: String;
  providerID_contains?: String;
  providerID_not_contains?: String;
  providerID_starts_with?: String;
  providerID_not_starts_with?: String;
  providerID_ends_with?: String;
  providerID_not_ends_with?: String;
  user?: UserWhereInput;
  AND?: IdentityWhereInput[] | IdentityWhereInput;
  OR?: IdentityWhereInput[] | IdentityWhereInput;
  NOT?: IdentityWhereInput[] | IdentityWhereInput;
}

export interface SpecialFundraiserCreateWithoutEventInput {
  description: String;
  name: String;
}

export interface HaloWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  user?: UserWhereInput;
  AND?: HaloWhereInput[] | HaloWhereInput;
  OR?: HaloWhereInput[] | HaloWhereInput;
  NOT?: HaloWhereInput[] | HaloWhereInput;
}

export interface TransactionCreateWithoutEventInput {
  amount: Int;
  balance: Int;
  key: String;
  stripeID?: String;
  type: TransactionType;
  user: UserCreateOneWithoutTransactionsInput;
}

export interface UserCreateOneWithoutHalosInput {
  create?: UserCreateWithoutHalosInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutTransactionsInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circles?: CircleCreateManyWithoutUsersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
}

export interface HaloUpdateWithWhereUniqueWithoutUserInput {
  where: HaloWhereUniqueInput;
  data: HaloUpdateWithoutUserDataInput;
}

export interface CircleCreateWithoutUsersInput {
  description?: String;
  name: String;
  open?: Boolean;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface HaloUpdateWithoutUserDataInput {
  key?: String;
}

export interface UserCreateWithoutCirclesOwnedInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circles?: CircleCreateManyWithoutUsersInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface HaloUpsertWithWhereUniqueWithoutUserInput {
  where: HaloWhereUniqueInput;
  update: HaloUpdateWithoutUserDataInput;
  create: HaloCreateWithoutUserInput;
}

export interface DotCreateWithoutUserInput {
  action: String;
  amount: Int;
  total: Int;
}

export interface IdentityUpdateOneRequiredWithoutUserInput {
  create?: IdentityCreateWithoutUserInput;
  update?: IdentityUpdateWithoutUserDataInput;
  upsert?: IdentityUpsertWithoutUserInput;
  connect?: IdentityWhereUniqueInput;
}

export interface CharityCreateWithoutFollowersInput {
  acronym?: String;
  bannerCredit?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
  events?: EventCreateManyWithoutCharityInput;
}

export interface IdentityUpdateWithoutUserDataInput {
  provider?: IdentityProvider;
  providerID?: String;
}

export interface HaloCreateWithoutUserInput {
  key: String;
}

export interface IdentityUpsertWithoutUserInput {
  update: IdentityUpdateWithoutUserDataInput;
  create: IdentityCreateWithoutUserInput;
}

export interface IdentityCreateWithoutUserInput {
  provider: IdentityProvider;
  providerID: String;
}

export interface LoopUpdateManyWithoutUserInput {
  create?: LoopCreateWithoutUserInput[] | LoopCreateWithoutUserInput;
  delete?: LoopWhereUniqueInput[] | LoopWhereUniqueInput;
  connect?: LoopWhereUniqueInput[] | LoopWhereUniqueInput;
  disconnect?: LoopWhereUniqueInput[] | LoopWhereUniqueInput;
  update?:
    | LoopUpdateWithWhereUniqueWithoutUserInput[]
    | LoopUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | LoopUpsertWithWhereUniqueWithoutUserInput[]
    | LoopUpsertWithWhereUniqueWithoutUserInput;
}

export interface LoopCreateWithoutUserInput {
  count: Int;
  event: EventCreateOneInput;
}

export interface LoopUpdateWithWhereUniqueWithoutUserInput {
  where: LoopWhereUniqueInput;
  data: LoopUpdateWithoutUserDataInput;
}

export interface EventCreateInput {
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeInput;
  charity?: CharityCreateOneWithoutEventsInput;
  specialFundraiser?: SpecialFundraiserCreateOneWithoutEventInput;
  donations?: TransactionCreateManyWithoutEventInput;
}

export interface LoopUpdateWithoutUserDataInput {
  count?: Int;
  event?: EventUpdateOneRequiredInput;
}

export interface CharityCreateWithoutEventsInput {
  acronym?: String;
  bannerCredit?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
  followers?: UserCreateManyWithoutFollowedCharitiesInput;
}

export interface EventUpdateOneRequiredInput {
  create?: EventCreateInput;
  update?: EventUpdateDataInput;
  upsert?: EventUpsertNestedInput;
  connect?: EventWhereUniqueInput;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransactionWhereInput;
  AND?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  OR?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  NOT?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
}

export interface EventUpdateDataInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
  charity?: CharityUpdateOneWithoutEventsInput;
  specialFundraiser?: SpecialFundraiserUpdateOneWithoutEventInput;
  donations?: TransactionUpdateManyWithoutEventInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  nameFirst?: String;
  nameFirst_not?: String;
  nameFirst_in?: String[] | String;
  nameFirst_not_in?: String[] | String;
  nameFirst_lt?: String;
  nameFirst_lte?: String;
  nameFirst_gt?: String;
  nameFirst_gte?: String;
  nameFirst_contains?: String;
  nameFirst_not_contains?: String;
  nameFirst_starts_with?: String;
  nameFirst_not_starts_with?: String;
  nameFirst_ends_with?: String;
  nameFirst_not_ends_with?: String;
  nameLast?: String;
  nameLast_not?: String;
  nameLast_in?: String[] | String;
  nameLast_not_in?: String[] | String;
  nameLast_lt?: String;
  nameLast_lte?: String;
  nameLast_gt?: String;
  nameLast_gte?: String;
  nameLast_contains?: String;
  nameLast_not_contains?: String;
  nameLast_starts_with?: String;
  nameLast_not_starts_with?: String;
  nameLast_ends_with?: String;
  nameLast_not_ends_with?: String;
  picture?: String;
  picture_not?: String;
  picture_in?: String[] | String;
  picture_not_in?: String[] | String;
  picture_lt?: String;
  picture_lte?: String;
  picture_gt?: String;
  picture_gte?: String;
  picture_contains?: String;
  picture_not_contains?: String;
  picture_starts_with?: String;
  picture_not_starts_with?: String;
  picture_ends_with?: String;
  picture_not_ends_with?: String;
  securityToken?: Int;
  securityToken_not?: Int;
  securityToken_in?: Int[] | Int;
  securityToken_not_in?: Int[] | Int;
  securityToken_lt?: Int;
  securityToken_lte?: Int;
  securityToken_gt?: Int;
  securityToken_gte?: Int;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  circles_every?: CircleWhereInput;
  circles_some?: CircleWhereInput;
  circles_none?: CircleWhereInput;
  circlesOwned_every?: CircleWhereInput;
  circlesOwned_some?: CircleWhereInput;
  circlesOwned_none?: CircleWhereInput;
  dots_every?: DotWhereInput;
  dots_some?: DotWhereInput;
  dots_none?: DotWhereInput;
  followedCharities_every?: CharityWhereInput;
  followedCharities_some?: CharityWhereInput;
  followedCharities_none?: CharityWhereInput;
  halos_every?: HaloWhereInput;
  halos_some?: HaloWhereInput;
  halos_none?: HaloWhereInput;
  identity?: IdentityWhereInput;
  loops_every?: LoopWhereInput;
  loops_some?: LoopWhereInput;
  loops_none?: LoopWhereInput;
  preferences?: PreferencesWhereInput;
  transactions_every?: TransactionWhereInput;
  transactions_some?: TransactionWhereInput;
  transactions_none?: TransactionWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface CharityUpdateOneWithoutEventsInput {
  create?: CharityCreateWithoutEventsInput;
  update?: CharityUpdateWithoutEventsDataInput;
  upsert?: CharityUpsertWithoutEventsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CharityWhereUniqueInput;
}

export interface HaloSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HaloWhereInput;
  AND?: HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput;
  OR?: HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput;
  NOT?: HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput;
}

export interface CharityUpdateWithoutEventsDataInput {
  acronym?: String;
  bannerCredit?: String;
  ein?: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location?: String;
  mission?: String;
  name?: String;
  phoneNumber?: String;
  website?: String;
  followers?: UserUpdateManyWithoutFollowedCharitiesInput;
}

export interface CircleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CircleWhereInput;
  AND?: CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput;
  OR?: CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput;
  NOT?: CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput;
}

export interface UserUpdateManyWithoutFollowedCharitiesInput {
  create?:
    | UserCreateWithoutFollowedCharitiesInput[]
    | UserCreateWithoutFollowedCharitiesInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput[]
    | UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput[]
    | UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput;
}

export interface TransactionUpdateInput {
  amount?: Int;
  balance?: Int;
  key?: String;
  stripeID?: String;
  type?: TransactionType;
  event?: EventUpdateOneWithoutDonationsInput;
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
}

export interface UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFollowedCharitiesDataInput;
}

export interface EventUpdateWithoutSpecialFundraiserDataInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
  charity?: CharityUpdateOneWithoutEventsInput;
  donations?: TransactionUpdateManyWithoutEventInput;
}

export interface UserUpdateWithoutFollowedCharitiesDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circles?: CircleUpdateManyWithoutUsersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface EventCreateWithoutSpecialFundraiserInput {
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeInput;
  charity?: CharityCreateOneWithoutEventsInput;
  donations?: TransactionCreateManyWithoutEventInput;
}

export interface CircleUpdateManyWithoutOwnerInput {
  create?: CircleCreateWithoutOwnerInput[] | CircleCreateWithoutOwnerInput;
  delete?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  connect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  disconnect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  update?:
    | CircleUpdateWithWhereUniqueWithoutOwnerInput[]
    | CircleUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | CircleUpsertWithWhereUniqueWithoutOwnerInput[]
    | CircleUpsertWithWhereUniqueWithoutOwnerInput;
}

export interface UserUpsertWithoutPreferencesInput {
  update: UserUpdateWithoutPreferencesDataInput;
  create: UserCreateWithoutPreferencesInput;
}

export interface CircleUpdateWithWhereUniqueWithoutOwnerInput {
  where: CircleWhereUniqueInput;
  data: CircleUpdateWithoutOwnerDataInput;
}

export interface PreferencesUpdateInput {
  allowDonationEmails?: Boolean;
  publicProfile?: Boolean;
  user?: UserUpdateOneRequiredWithoutPreferencesInput;
}

export interface CircleUpdateWithoutOwnerDataInput {
  description?: String;
  name?: String;
  open?: Boolean;
  users?: UserUpdateManyWithoutCirclesInput;
}

export interface PreferencesCreateInput {
  allowDonationEmails?: Boolean;
  publicProfile?: Boolean;
  user: UserCreateOneWithoutPreferencesInput;
}

export interface UserUpdateManyWithoutCirclesInput {
  create?: UserCreateWithoutCirclesInput[] | UserCreateWithoutCirclesInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutCirclesInput[]
    | UserUpdateWithWhereUniqueWithoutCirclesInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutCirclesInput[]
    | UserUpsertWithWhereUniqueWithoutCirclesInput;
}

export interface UserUpdateOneRequiredWithoutLoopsInput {
  create?: UserCreateWithoutLoopsInput;
  update?: UserUpdateWithoutLoopsDataInput;
  upsert?: UserUpsertWithoutLoopsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithWhereUniqueWithoutCirclesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCirclesDataInput;
}

export interface UserCreateOneWithoutLoopsInput {
  create?: UserCreateWithoutLoopsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCirclesDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface UserUpdateWithoutIdentityDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circles?: CircleUpdateManyWithoutUsersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface PreferencesUpdateOneRequiredWithoutUserInput {
  create?: PreferencesCreateWithoutUserInput;
  update?: PreferencesUpdateWithoutUserDataInput;
  upsert?: PreferencesUpsertWithoutUserInput;
  connect?: PreferencesWhereUniqueInput;
}

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  key?: String;
}>;

export interface PreferencesUpdateWithoutUserDataInput {
  allowDonationEmails?: Boolean;
  publicProfile?: Boolean;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
}>;

export interface PreferencesUpsertWithoutUserInput {
  update: PreferencesUpdateWithoutUserDataInput;
  create: PreferencesCreateWithoutUserInput;
}

export interface SpecialFundraiserCreateOneWithoutEventInput {
  create?: SpecialFundraiserCreateWithoutEventInput;
  connect?: SpecialFundraiserWhereUniqueInput;
}

export interface TransactionUpdateManyWithoutUserInput {
  create?:
    | TransactionCreateWithoutUserInput[]
    | TransactionCreateWithoutUserInput;
  delete?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  disconnect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  update?:
    | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    | TransactionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    | TransactionUpsertWithWhereUniqueWithoutUserInput;
}

export interface UserCreateOneWithoutTransactionsInput {
  create?: UserCreateWithoutTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutUserDataInput;
}

export interface UserCreateOneWithoutCirclesOwnedInput {
  create?: UserCreateWithoutCirclesOwnedInput;
  connect?: UserWhereUniqueInput;
}

export interface TransactionUpdateWithoutUserDataInput {
  amount?: Int;
  balance?: Int;
  key?: String;
  stripeID?: String;
  type?: TransactionType;
  event?: EventUpdateOneWithoutDonationsInput;
}

export interface CharityCreateManyWithoutFollowersInput {
  create?:
    | CharityCreateWithoutFollowersInput[]
    | CharityCreateWithoutFollowersInput;
  connect?: CharityWhereUniqueInput[] | CharityWhereUniqueInput;
}

export interface EventUpdateOneWithoutDonationsInput {
  create?: EventCreateWithoutDonationsInput;
  update?: EventUpdateWithoutDonationsDataInput;
  upsert?: EventUpsertWithoutDonationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EventWhereUniqueInput;
}

export interface IdentityCreateOneWithoutUserInput {
  create?: IdentityCreateWithoutUserInput;
  connect?: IdentityWhereUniqueInput;
}

export interface EventUpdateWithoutDonationsDataInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
  charity?: CharityUpdateOneWithoutEventsInput;
  specialFundraiser?: SpecialFundraiserUpdateOneWithoutEventInput;
}

export interface EventCreateOneInput {
  create?: EventCreateInput;
  connect?: EventWhereUniqueInput;
}

export interface EventUpsertWithoutDonationsInput {
  update: EventUpdateWithoutDonationsDataInput;
  create: EventCreateWithoutDonationsInput;
}

export interface DotWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  action?: String;
  action_not?: String;
  action_in?: String[] | String;
  action_not_in?: String[] | String;
  action_lt?: String;
  action_lte?: String;
  action_gt?: String;
  action_gte?: String;
  action_contains?: String;
  action_not_contains?: String;
  action_starts_with?: String;
  action_not_starts_with?: String;
  action_ends_with?: String;
  action_not_ends_with?: String;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  total?: Int;
  total_not?: Int;
  total_in?: Int[] | Int;
  total_not_in?: Int[] | Int;
  total_lt?: Int;
  total_lte?: Int;
  total_gt?: Int;
  total_gte?: Int;
  user?: UserWhereInput;
  AND?: DotWhereInput[] | DotWhereInput;
  OR?: DotWhereInput[] | DotWhereInput;
  NOT?: DotWhereInput[] | DotWhereInput;
}

export interface TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutUserDataInput;
  create: TransactionCreateWithoutUserInput;
}

export interface CharityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  acronym?: String;
  acronym_not?: String;
  acronym_in?: String[] | String;
  acronym_not_in?: String[] | String;
  acronym_lt?: String;
  acronym_lte?: String;
  acronym_gt?: String;
  acronym_gte?: String;
  acronym_contains?: String;
  acronym_not_contains?: String;
  acronym_starts_with?: String;
  acronym_not_starts_with?: String;
  acronym_ends_with?: String;
  acronym_not_ends_with?: String;
  bannerCredit?: String;
  bannerCredit_not?: String;
  bannerCredit_in?: String[] | String;
  bannerCredit_not_in?: String[] | String;
  bannerCredit_lt?: String;
  bannerCredit_lte?: String;
  bannerCredit_gt?: String;
  bannerCredit_gte?: String;
  bannerCredit_contains?: String;
  bannerCredit_not_contains?: String;
  bannerCredit_starts_with?: String;
  bannerCredit_not_starts_with?: String;
  bannerCredit_ends_with?: String;
  bannerCredit_not_ends_with?: String;
  ein?: String;
  ein_not?: String;
  ein_in?: String[] | String;
  ein_not_in?: String[] | String;
  ein_lt?: String;
  ein_lte?: String;
  ein_gt?: String;
  ein_gte?: String;
  ein_contains?: String;
  ein_not_contains?: String;
  ein_starts_with?: String;
  ein_not_starts_with?: String;
  ein_ends_with?: String;
  ein_not_ends_with?: String;
  expensesAdministrative?: Float;
  expensesAdministrative_not?: Float;
  expensesAdministrative_in?: Float[] | Float;
  expensesAdministrative_not_in?: Float[] | Float;
  expensesAdministrative_lt?: Float;
  expensesAdministrative_lte?: Float;
  expensesAdministrative_gt?: Float;
  expensesAdministrative_gte?: Float;
  expensesFundraising?: Float;
  expensesFundraising_not?: Float;
  expensesFundraising_in?: Float[] | Float;
  expensesFundraising_not_in?: Float[] | Float;
  expensesFundraising_lt?: Float;
  expensesFundraising_lte?: Float;
  expensesFundraising_gt?: Float;
  expensesFundraising_gte?: Float;
  expensesOther?: Float;
  expensesOther_not?: Float;
  expensesOther_in?: Float[] | Float;
  expensesOther_not_in?: Float[] | Float;
  expensesOther_lt?: Float;
  expensesOther_lte?: Float;
  expensesOther_gt?: Float;
  expensesOther_gte?: Float;
  expensesProgram?: Float;
  expensesProgram_not?: Float;
  expensesProgram_in?: Float[] | Float;
  expensesProgram_not_in?: Float[] | Float;
  expensesProgram_lt?: Float;
  expensesProgram_lte?: Float;
  expensesProgram_gt?: Float;
  expensesProgram_gte?: Float;
  expensesUpdated?: String;
  expensesUpdated_not?: String;
  expensesUpdated_in?: String[] | String;
  expensesUpdated_not_in?: String[] | String;
  expensesUpdated_lt?: String;
  expensesUpdated_lte?: String;
  expensesUpdated_gt?: String;
  expensesUpdated_gte?: String;
  expensesUpdated_contains?: String;
  expensesUpdated_not_contains?: String;
  expensesUpdated_starts_with?: String;
  expensesUpdated_not_starts_with?: String;
  expensesUpdated_ends_with?: String;
  expensesUpdated_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  mission?: String;
  mission_not?: String;
  mission_in?: String[] | String;
  mission_not_in?: String[] | String;
  mission_lt?: String;
  mission_lte?: String;
  mission_gt?: String;
  mission_gte?: String;
  mission_contains?: String;
  mission_not_contains?: String;
  mission_starts_with?: String;
  mission_not_starts_with?: String;
  mission_ends_with?: String;
  mission_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  phoneNumber?: String;
  phoneNumber_not?: String;
  phoneNumber_in?: String[] | String;
  phoneNumber_not_in?: String[] | String;
  phoneNumber_lt?: String;
  phoneNumber_lte?: String;
  phoneNumber_gt?: String;
  phoneNumber_gte?: String;
  phoneNumber_contains?: String;
  phoneNumber_not_contains?: String;
  phoneNumber_starts_with?: String;
  phoneNumber_not_starts_with?: String;
  phoneNumber_ends_with?: String;
  phoneNumber_not_ends_with?: String;
  website?: String;
  website_not?: String;
  website_in?: String[] | String;
  website_not_in?: String[] | String;
  website_lt?: String;
  website_lte?: String;
  website_gt?: String;
  website_gte?: String;
  website_contains?: String;
  website_not_contains?: String;
  website_starts_with?: String;
  website_not_starts_with?: String;
  website_ends_with?: String;
  website_not_ends_with?: String;
  events_every?: EventWhereInput;
  events_some?: EventWhereInput;
  events_none?: EventWhereInput;
  followers_every?: UserWhereInput;
  followers_some?: UserWhereInput;
  followers_none?: UserWhereInput;
  AND?: CharityWhereInput[] | CharityWhereInput;
  OR?: CharityWhereInput[] | CharityWhereInput;
  NOT?: CharityWhereInput[] | CharityWhereInput;
}

export interface UserUpsertWithWhereUniqueWithoutCirclesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCirclesDataInput;
  create: UserCreateWithoutCirclesInput;
}

export interface UserUpdateInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circles?: CircleUpdateManyWithoutUsersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface CircleUpsertWithWhereUniqueWithoutOwnerInput {
  where: CircleWhereUniqueInput;
  update: CircleUpdateWithoutOwnerDataInput;
  create: CircleCreateWithoutOwnerInput;
}

export interface EventUpdateOneRequiredWithoutSpecialFundraiserInput {
  create?: EventCreateWithoutSpecialFundraiserInput;
  update?: EventUpdateWithoutSpecialFundraiserDataInput;
  upsert?: EventUpsertWithoutSpecialFundraiserInput;
  connect?: EventWhereUniqueInput;
}

export interface UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFollowedCharitiesDataInput;
  create: UserCreateWithoutFollowedCharitiesInput;
}

export interface UserUpdateWithoutPreferencesDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circles?: CircleUpdateManyWithoutUsersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface CharityUpsertWithoutEventsInput {
  update: CharityUpdateWithoutEventsDataInput;
  create: CharityCreateWithoutEventsInput;
}

export type LoopWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface EventUpsertNestedInput {
  update: EventUpdateDataInput;
  create: EventCreateInput;
}

export interface UserUpsertWithoutIdentityInput {
  update: UserUpdateWithoutIdentityDataInput;
  create: UserCreateWithoutIdentityInput;
}

export interface LoopUpsertWithWhereUniqueWithoutUserInput {
  where: LoopWhereUniqueInput;
  update: LoopUpdateWithoutUserDataInput;
  create: LoopCreateWithoutUserInput;
}

export interface IdentityCreateInput {
  provider: IdentityProvider;
  providerID: String;
  user: UserCreateOneWithoutIdentityInput;
}

export interface UserUpsertWithoutCirclesOwnedInput {
  update: UserUpdateWithoutCirclesOwnedDataInput;
  create: UserCreateWithoutCirclesOwnedInput;
}

export interface EventCreateManyWithoutCharityInput {
  create?: EventCreateWithoutCharityInput[] | EventCreateWithoutCharityInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
}

export interface CircleUpsertWithWhereUniqueWithoutUsersInput {
  where: CircleWhereUniqueInput;
  update: CircleUpdateWithoutUsersDataInput;
  create: CircleCreateWithoutUsersInput;
}

export interface CircleCreateManyWithoutUsersInput {
  create?: CircleCreateWithoutUsersInput[] | CircleCreateWithoutUsersInput;
  connect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
}

export interface UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput;
  create: UserCreateWithoutTransactionsInput;
}

export interface HaloCreateManyWithoutUserInput {
  create?: HaloCreateWithoutUserInput[] | HaloCreateWithoutUserInput;
  connect?: HaloWhereUniqueInput[] | HaloWhereUniqueInput;
}

export interface TransactionUpsertWithWhereUniqueWithoutEventInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutEventDataInput;
  create: TransactionCreateWithoutEventInput;
}

export interface CharityCreateOneWithoutEventsInput {
  create?: CharityCreateWithoutEventsInput;
  connect?: CharityWhereUniqueInput;
}

export interface EventUpsertWithWhereUniqueWithoutCharityInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutCharityDataInput;
  create: EventCreateWithoutCharityInput;
}

export interface EventWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  goal?: Int;
  goal_not?: Int;
  goal_in?: Int[] | Int;
  goal_not_in?: Int[] | Int;
  goal_lt?: Int;
  goal_lte?: Int;
  goal_gt?: Int;
  goal_gte?: Int;
  multiplier?: Int;
  multiplier_not?: Int;
  multiplier_in?: Int[] | Int;
  multiplier_not_in?: Int[] | Int;
  multiplier_lt?: Int;
  multiplier_lte?: Int;
  multiplier_gt?: Int;
  multiplier_gte?: Int;
  sponsorName?: String;
  sponsorName_not?: String;
  sponsorName_in?: String[] | String;
  sponsorName_not_in?: String[] | String;
  sponsorName_lt?: String;
  sponsorName_lte?: String;
  sponsorName_gt?: String;
  sponsorName_gte?: String;
  sponsorName_contains?: String;
  sponsorName_not_contains?: String;
  sponsorName_starts_with?: String;
  sponsorName_not_starts_with?: String;
  sponsorName_ends_with?: String;
  sponsorName_not_ends_with?: String;
  sponsorWebsite?: String;
  sponsorWebsite_not?: String;
  sponsorWebsite_in?: String[] | String;
  sponsorWebsite_not_in?: String[] | String;
  sponsorWebsite_lt?: String;
  sponsorWebsite_lte?: String;
  sponsorWebsite_gt?: String;
  sponsorWebsite_gte?: String;
  sponsorWebsite_contains?: String;
  sponsorWebsite_not_contains?: String;
  sponsorWebsite_starts_with?: String;
  sponsorWebsite_not_starts_with?: String;
  sponsorWebsite_ends_with?: String;
  sponsorWebsite_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  charity?: CharityWhereInput;
  specialFundraiser?: SpecialFundraiserWhereInput;
  donations_every?: TransactionWhereInput;
  donations_some?: TransactionWhereInput;
  donations_none?: TransactionWhereInput;
  AND?: EventWhereInput[] | EventWhereInput;
  OR?: EventWhereInput[] | EventWhereInput;
  NOT?: EventWhereInput[] | EventWhereInput;
}

export interface HaloCreateInput {
  key: String;
  user: UserCreateOneWithoutHalosInput;
}

export interface EventCreateOneWithoutSpecialFundraiserInput {
  create?: EventCreateWithoutSpecialFundraiserInput;
  connect?: EventWhereUniqueInput;
}

export interface EventUpdateInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
  charity?: CharityUpdateOneWithoutEventsInput;
  specialFundraiser?: SpecialFundraiserUpdateOneWithoutEventInput;
  donations?: TransactionUpdateManyWithoutEventInput;
}

export type PreferencesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CircleCreateInput {
  description?: String;
  name: String;
  open?: Boolean;
  owner: UserCreateOneWithoutCirclesOwnedInput;
  users?: UserCreateManyWithoutCirclesInput;
}

export interface UserUpdateOneRequiredWithoutHalosInput {
  create?: UserCreateWithoutHalosInput;
  update?: UserUpdateWithoutHalosDataInput;
  upsert?: UserUpsertWithoutHalosInput;
  connect?: UserWhereUniqueInput;
}

export interface CircleUpdateInput {
  description?: String;
  name?: String;
  open?: Boolean;
  owner?: UserUpdateOneRequiredWithoutCirclesOwnedInput;
  users?: UserUpdateManyWithoutCirclesInput;
}

export interface DotCreateManyWithoutUserInput {
  create?: DotCreateWithoutUserInput[] | DotCreateWithoutUserInput;
  connect?: DotWhereUniqueInput[] | DotWhereUniqueInput;
}

export interface DotCreateInput {
  action: String;
  amount: Int;
  total: Int;
  user: UserCreateOneWithoutDotsInput;
}

export interface PreferencesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PreferencesWhereInput;
  AND?: PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput;
  OR?: PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput;
  NOT?: PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput;
}

export interface UserCreateOneWithoutDotsInput {
  create?: UserCreateWithoutDotsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutPreferencesInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circles?: CircleCreateManyWithoutUsersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface UserUpdateWithoutDotsDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circles?: CircleUpdateManyWithoutUsersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface UserUpdateOneRequiredWithoutDotsInput {
  create?: UserCreateWithoutDotsInput;
  update?: UserUpdateWithoutDotsDataInput;
  upsert?: UserUpsertWithoutDotsInput;
  connect?: UserWhereUniqueInput;
}

export interface DotUpdateInput {
  action?: String;
  amount?: Int;
  total?: Int;
  user?: UserUpdateOneRequiredWithoutDotsInput;
}

export interface UserCreateWithoutDotsInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circles?: CircleCreateManyWithoutUsersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface IdentityUpdateInput {
  provider?: IdentityProvider;
  providerID?: String;
  user?: UserUpdateOneRequiredWithoutIdentityInput;
}

export interface TransactionCreateInput {
  amount: Int;
  balance: Int;
  key: String;
  stripeID?: String;
  type: TransactionType;
  event?: EventCreateOneWithoutDonationsInput;
  user: UserCreateOneWithoutTransactionsInput;
}

export interface LoopCreateManyWithoutUserInput {
  create?: LoopCreateWithoutUserInput[] | LoopCreateWithoutUserInput;
  connect?: LoopWhereUniqueInput[] | LoopWhereUniqueInput;
}

export interface TransactionCreateManyWithoutEventInput {
  create?:
    | TransactionCreateWithoutEventInput[]
    | TransactionCreateWithoutEventInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
}

export interface UserPreviousValues
  extends Promise<UserPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  email: () => Promise<String>;
  nameFirst: () => Promise<String>;
  nameLast: () => Promise<String>;
  picture: () => Promise<String>;
  securityToken: () => Promise<Int>;
  username: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bio: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameLast: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  securityToken: () => Promise<AsyncIterator<Int>>;
  username: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCharityNode {
  count: Int;
}

export interface AggregateCharity
  extends Promise<AggregateCharityNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharitySubscription
  extends Promise<AsyncIterator<AggregateCharityNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  endDate: DateTimeOutput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeOutput;
}

export interface Event extends Promise<EventNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  goal: () => Promise<Int>;
  multiplier: () => Promise<Int>;
  sponsorName: () => Promise<String>;
  sponsorWebsite: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  charity: <T = Charity>() => T;
  specialFundraiser: <T = SpecialFundraiser>() => T;
  donations: <T = FragmentableArray<TransactionNode>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EventSubscription
  extends Promise<AsyncIterator<EventNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  goal: () => Promise<AsyncIterator<Int>>;
  multiplier: () => Promise<AsyncIterator<Int>>;
  sponsorName: () => Promise<AsyncIterator<String>>;
  sponsorWebsite: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  charity: <T = CharitySubscription>() => T;
  specialFundraiser: <T = SpecialFundraiserSubscription>() => T;
  donations: <T = Promise<AsyncIterator<TransactionSubscription>>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CharityEdgeNode {
  cursor: String;
}

export interface CharityEdge extends Promise<CharityEdgeNode>, Fragmentable {
  node: <T = Charity>() => T;
  cursor: () => Promise<String>;
}

export interface CharityEdgeSubscription
  extends Promise<AsyncIterator<CharityEdgeNode>>,
    Fragmentable {
  node: <T = CharitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SpecialFundraiserNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  name: String;
}

export interface SpecialFundraiser
  extends Promise<SpecialFundraiserNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  event: <T = Event>() => T;
}

export interface SpecialFundraiserSubscription
  extends Promise<AsyncIterator<SpecialFundraiserNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  event: <T = EventSubscription>() => T;
}

export interface PageInfoNode {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfo extends Promise<PageInfoNode>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfoNode>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUserNode {
  count: Int;
}

export interface AggregateUser
  extends Promise<AggregateUserNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUserNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CharityConnectionNode {}

export interface CharityConnection
  extends Promise<CharityConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<CharityEdgeNode>>() => T;
  aggregate: <T = AggregateCharity>() => T;
}

export interface CharityConnectionSubscription
  extends Promise<AsyncIterator<CharityConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharitySubscription>() => T;
}

export interface UserConnectionNode {}

export interface UserConnection
  extends Promise<UserConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<UserEdgeNode>>() => T;
  aggregate: <T = AggregateUser>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface TransactionPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amount: Int;
  balance: Int;
  key: String;
  stripeID?: String;
  type: TransactionType;
}

export interface TransactionPreviousValues
  extends Promise<TransactionPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  balance: () => Promise<Int>;
  key: () => Promise<String>;
  stripeID: () => Promise<String>;
  type: () => Promise<TransactionType>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  balance: () => Promise<AsyncIterator<Int>>;
  key: () => Promise<AsyncIterator<String>>;
  stripeID: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
}

export interface SpecialFundraiserPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  name: String;
}

export interface SpecialFundraiserPreviousValues
  extends Promise<SpecialFundraiserPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SpecialFundraiserPreviousValuesSubscription
  extends Promise<AsyncIterator<SpecialFundraiserPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserEdgeNode {
  cursor: String;
}

export interface UserEdge extends Promise<UserEdgeNode>, Fragmentable {
  node: <T = User>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdgeNode>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransactionEdgeNode {
  cursor: String;
}

export interface TransactionEdge
  extends Promise<TransactionEdgeNode>,
    Fragmentable {
  node: <T = Transaction>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdgeNode>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransactionNode {
  count: Int;
}

export interface AggregateTransaction
  extends Promise<AggregateTransactionNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransactionNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SpecialFundraiserEdgeNode {
  cursor: String;
}

export interface SpecialFundraiserEdge
  extends Promise<SpecialFundraiserEdgeNode>,
    Fragmentable {
  node: <T = SpecialFundraiser>() => T;
  cursor: () => Promise<String>;
}

export interface SpecialFundraiserEdgeSubscription
  extends Promise<AsyncIterator<SpecialFundraiserEdgeNode>>,
    Fragmentable {
  node: <T = SpecialFundraiserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransactionConnectionNode {}

export interface TransactionConnection
  extends Promise<TransactionConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<TransactionEdgeNode>>() => T;
  aggregate: <T = AggregateTransaction>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface CharityNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  acronym?: String;
  bannerCredit?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
}

export interface Charity extends Promise<CharityNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  acronym: () => Promise<String>;
  bannerCredit: () => Promise<String>;
  ein: () => Promise<String>;
  expensesAdministrative: () => Promise<Float>;
  expensesFundraising: () => Promise<Float>;
  expensesOther: () => Promise<Float>;
  expensesProgram: () => Promise<Float>;
  expensesUpdated: () => Promise<String>;
  location: () => Promise<String>;
  mission: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  website: () => Promise<String>;
  events: <T = FragmentableArray<EventNode>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  followers: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CharitySubscription
  extends Promise<AsyncIterator<CharityNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  acronym: () => Promise<AsyncIterator<String>>;
  bannerCredit: () => Promise<AsyncIterator<String>>;
  ein: () => Promise<AsyncIterator<String>>;
  expensesAdministrative: () => Promise<AsyncIterator<Float>>;
  expensesFundraising: () => Promise<AsyncIterator<Float>>;
  expensesOther: () => Promise<AsyncIterator<Float>>;
  expensesProgram: () => Promise<AsyncIterator<Float>>;
  expensesUpdated: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  mission: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  followers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CharitySubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CharitySubscriptionPayload
  extends Promise<CharitySubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Charity>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharityPreviousValues>() => T;
}

export interface CharitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharitySubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharityPreviousValuesSubscription>() => T;
}

export interface PreferencesEdgeNode {
  cursor: String;
}

export interface PreferencesEdge
  extends Promise<PreferencesEdgeNode>,
    Fragmentable {
  node: <T = Preferences>() => T;
  cursor: () => Promise<String>;
}

export interface PreferencesEdgeSubscription
  extends Promise<AsyncIterator<PreferencesEdgeNode>>,
    Fragmentable {
  node: <T = PreferencesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharityPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  acronym?: String;
  bannerCredit?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
}

export interface CharityPreviousValues
  extends Promise<CharityPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  acronym: () => Promise<String>;
  bannerCredit: () => Promise<String>;
  ein: () => Promise<String>;
  expensesAdministrative: () => Promise<Float>;
  expensesFundraising: () => Promise<Float>;
  expensesOther: () => Promise<Float>;
  expensesProgram: () => Promise<Float>;
  expensesUpdated: () => Promise<String>;
  location: () => Promise<String>;
  mission: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  website: () => Promise<String>;
}

export interface CharityPreviousValuesSubscription
  extends Promise<AsyncIterator<CharityPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  acronym: () => Promise<AsyncIterator<String>>;
  bannerCredit: () => Promise<AsyncIterator<String>>;
  ein: () => Promise<AsyncIterator<String>>;
  expensesAdministrative: () => Promise<AsyncIterator<Float>>;
  expensesFundraising: () => Promise<AsyncIterator<Float>>;
  expensesOther: () => Promise<AsyncIterator<Float>>;
  expensesProgram: () => Promise<AsyncIterator<Float>>;
  expensesUpdated: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  mission: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface UserSubscriptionPayload
  extends Promise<UserSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = User>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValues>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface PreferencesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  allowDonationEmails: Boolean;
  publicProfile: Boolean;
}

export interface Preferences extends Promise<PreferencesNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  allowDonationEmails: () => Promise<Boolean>;
  publicProfile: () => Promise<Boolean>;
  user: <T = User>() => T;
}

export interface PreferencesSubscription
  extends Promise<AsyncIterator<PreferencesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  allowDonationEmails: () => Promise<AsyncIterator<Boolean>>;
  publicProfile: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
}

export interface LoopEdgeNode {
  cursor: String;
}

export interface LoopEdge extends Promise<LoopEdgeNode>, Fragmentable {
  node: <T = Loop>() => T;
  cursor: () => Promise<String>;
}

export interface LoopEdgeSubscription
  extends Promise<AsyncIterator<LoopEdgeNode>>,
    Fragmentable {
  node: <T = LoopSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CircleSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface CircleSubscriptionPayload
  extends Promise<CircleSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Circle>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CirclePreviousValues>() => T;
}

export interface CircleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CircleSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CircleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CirclePreviousValuesSubscription>() => T;
}

export interface AggregateIdentityNode {
  count: Int;
}

export interface AggregateIdentity
  extends Promise<AggregateIdentityNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIdentitySubscription
  extends Promise<AsyncIterator<AggregateIdentityNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CirclePreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  name: String;
  open: Boolean;
}

export interface CirclePreviousValues
  extends Promise<CirclePreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  open: () => Promise<Boolean>;
}

export interface CirclePreviousValuesSubscription
  extends Promise<AsyncIterator<CirclePreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface IdentityConnectionNode {}

export interface IdentityConnection
  extends Promise<IdentityConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<IdentityEdgeNode>>() => T;
  aggregate: <T = AggregateIdentity>() => T;
}

export interface IdentityConnectionSubscription
  extends Promise<AsyncIterator<IdentityConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IdentityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIdentitySubscription>() => T;
}

export interface LoopNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  count: Int;
}

export interface Loop extends Promise<LoopNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  count: () => Promise<Int>;
  event: <T = Event>() => T;
  user: <T = User>() => T;
}

export interface LoopSubscription
  extends Promise<AsyncIterator<LoopNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  count: () => Promise<AsyncIterator<Int>>;
  event: <T = EventSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface AggregateHaloNode {
  count: Int;
}

export interface AggregateHalo
  extends Promise<AggregateHaloNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHaloSubscription
  extends Promise<AsyncIterator<AggregateHaloNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DotSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface DotSubscriptionPayload
  extends Promise<DotSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Dot>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DotPreviousValues>() => T;
}

export interface DotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DotSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DotPreviousValuesSubscription>() => T;
}

export interface HaloConnectionNode {}

export interface HaloConnection
  extends Promise<HaloConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<HaloEdgeNode>>() => T;
  aggregate: <T = AggregateHalo>() => T;
}

export interface HaloConnectionSubscription
  extends Promise<AsyncIterator<HaloConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HaloEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHaloSubscription>() => T;
}

export interface DotPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  action: String;
  amount: Int;
  total: Int;
}

export interface DotPreviousValues
  extends Promise<DotPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
  amount: () => Promise<Int>;
  total: () => Promise<Int>;
}

export interface DotPreviousValuesSubscription
  extends Promise<AsyncIterator<DotPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
}

export interface EventEdgeNode {
  cursor: String;
}

export interface EventEdge extends Promise<EventEdgeNode>, Fragmentable {
  node: <T = Event>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdgeNode>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface IdentityNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  provider: IdentityProvider;
  providerID: String;
}

export interface Identity extends Promise<IdentityNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  provider: () => Promise<IdentityProvider>;
  providerID: () => Promise<String>;
  user: <T = User>() => T;
}

export interface IdentitySubscription
  extends Promise<AsyncIterator<IdentityNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  provider: () => Promise<AsyncIterator<IdentityProvider>>;
  providerID: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface AggregateDotNode {
  count: Int;
}

export interface AggregateDot extends Promise<AggregateDotNode>, Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDotSubscription
  extends Promise<AsyncIterator<AggregateDotNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface EventSubscriptionPayload
  extends Promise<EventSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Event>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValues>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface DotConnectionNode {}

export interface DotConnection
  extends Promise<DotConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<DotEdgeNode>>() => T;
  aggregate: <T = AggregateDot>() => T;
}

export interface DotConnectionSubscription
  extends Promise<AsyncIterator<DotConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDotSubscription>() => T;
}

export interface EventPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  endDate: DateTimeOutput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeOutput;
}

export interface EventPreviousValues
  extends Promise<EventPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  goal: () => Promise<Int>;
  multiplier: () => Promise<Int>;
  sponsorName: () => Promise<String>;
  sponsorWebsite: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  goal: () => Promise<AsyncIterator<Int>>;
  multiplier: () => Promise<AsyncIterator<Int>>;
  sponsorName: () => Promise<AsyncIterator<String>>;
  sponsorWebsite: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CircleEdgeNode {
  cursor: String;
}

export interface CircleEdge extends Promise<CircleEdgeNode>, Fragmentable {
  node: <T = Circle>() => T;
  cursor: () => Promise<String>;
}

export interface CircleEdgeSubscription
  extends Promise<AsyncIterator<CircleEdgeNode>>,
    Fragmentable {
  node: <T = CircleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface HaloNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  key: String;
}

export interface Halo extends Promise<HaloNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  user: <T = User>() => T;
}

export interface HaloSubscription
  extends Promise<AsyncIterator<HaloNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface BatchPayloadNode {
  count: Long;
}

export interface BatchPayload extends Promise<BatchPayloadNode>, Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayloadNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface HaloSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface HaloSubscriptionPayload
  extends Promise<HaloSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Halo>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HaloPreviousValues>() => T;
}

export interface HaloSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HaloSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HaloSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HaloPreviousValuesSubscription>() => T;
}

export interface SpecialFundraiserConnectionNode {}

export interface SpecialFundraiserConnection
  extends Promise<SpecialFundraiserConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<SpecialFundraiserEdgeNode>>() => T;
  aggregate: <T = AggregateSpecialFundraiser>() => T;
}

export interface SpecialFundraiserConnectionSubscription
  extends Promise<AsyncIterator<SpecialFundraiserConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpecialFundraiserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpecialFundraiserSubscription>() => T;
}

export interface HaloPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  key: String;
}

export interface HaloPreviousValues
  extends Promise<HaloPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
}

export interface HaloPreviousValuesSubscription
  extends Promise<AsyncIterator<HaloPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
}

export interface PreferencesConnectionNode {}

export interface PreferencesConnection
  extends Promise<PreferencesConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<PreferencesEdgeNode>>() => T;
  aggregate: <T = AggregatePreferences>() => T;
}

export interface PreferencesConnectionSubscription
  extends Promise<AsyncIterator<PreferencesConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PreferencesEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePreferencesSubscription>() => T;
}

export interface TransactionSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface TransactionSubscriptionPayload
  extends Promise<TransactionSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Transaction>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValues>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface LoopConnectionNode {}

export interface LoopConnection
  extends Promise<LoopConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<LoopEdgeNode>>() => T;
  aggregate: <T = AggregateLoop>() => T;
}

export interface LoopConnectionSubscription
  extends Promise<AsyncIterator<LoopConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoopEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoopSubscription>() => T;
}

export interface IdentitySubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface IdentitySubscriptionPayload
  extends Promise<IdentitySubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Identity>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IdentityPreviousValues>() => T;
}

export interface IdentitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IdentitySubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IdentitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IdentityPreviousValuesSubscription>() => T;
}

export interface TransactionNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amount: Int;
  balance: Int;
  key: String;
  stripeID?: String;
  type: TransactionType;
}

export interface Transaction extends Promise<TransactionNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  balance: () => Promise<Int>;
  key: () => Promise<String>;
  stripeID: () => Promise<String>;
  type: () => Promise<TransactionType>;
  event: <T = Event>() => T;
  user: <T = User>() => T;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<TransactionNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  balance: () => Promise<AsyncIterator<Int>>;
  key: () => Promise<AsyncIterator<String>>;
  stripeID: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  event: <T = EventSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface IdentityPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  provider: IdentityProvider;
  providerID: String;
}

export interface IdentityPreviousValues
  extends Promise<IdentityPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  provider: () => Promise<IdentityProvider>;
  providerID: () => Promise<String>;
}

export interface IdentityPreviousValuesSubscription
  extends Promise<AsyncIterator<IdentityPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  provider: () => Promise<AsyncIterator<IdentityProvider>>;
  providerID: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEventNode {
  count: Int;
}

export interface AggregateEvent
  extends Promise<AggregateEventNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEventNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DotNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  action: String;
  amount: Int;
  total: Int;
}

export interface Dot extends Promise<DotNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
  amount: () => Promise<Int>;
  total: () => Promise<Int>;
  user: <T = User>() => T;
}

export interface DotSubscription
  extends Promise<AsyncIterator<DotNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
}

export interface DotEdgeNode {
  cursor: String;
}

export interface DotEdge extends Promise<DotEdgeNode>, Fragmentable {
  node: <T = Dot>() => T;
  cursor: () => Promise<String>;
}

export interface DotEdgeSubscription
  extends Promise<AsyncIterator<DotEdgeNode>>,
    Fragmentable {
  node: <T = DotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LoopSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface LoopSubscriptionPayload
  extends Promise<LoopSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Loop>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoopPreviousValues>() => T;
}

export interface LoopSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoopSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoopSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoopPreviousValuesSubscription>() => T;
}

export interface CircleConnectionNode {}

export interface CircleConnection
  extends Promise<CircleConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<CircleEdgeNode>>() => T;
  aggregate: <T = AggregateCircle>() => T;
}

export interface CircleConnectionSubscription
  extends Promise<AsyncIterator<CircleConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CircleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCircleSubscription>() => T;
}

export interface LoopPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  count: Int;
}

export interface LoopPreviousValues
  extends Promise<LoopPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  count: () => Promise<Int>;
}

export interface LoopPreviousValuesSubscription
  extends Promise<AsyncIterator<LoopPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePreferencesNode {
  count: Int;
}

export interface AggregatePreferences
  extends Promise<AggregatePreferencesNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePreferencesSubscription
  extends Promise<AsyncIterator<AggregatePreferencesNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CircleNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  name: String;
  open: Boolean;
}

export interface Circle extends Promise<CircleNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  open: () => Promise<Boolean>;
  owner: <T = User>() => T;
  users: <T = FragmentableArray<UserNode>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CircleSubscription
  extends Promise<AsyncIterator<CircleNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
  owner: <T = UserSubscription>() => T;
  users: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface IdentityEdgeNode {
  cursor: String;
}

export interface IdentityEdge extends Promise<IdentityEdgeNode>, Fragmentable {
  node: <T = Identity>() => T;
  cursor: () => Promise<String>;
}

export interface IdentityEdgeSubscription
  extends Promise<AsyncIterator<IdentityEdgeNode>>,
    Fragmentable {
  node: <T = IdentitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventConnectionNode {}

export interface EventConnection
  extends Promise<EventConnectionNode>,
    Fragmentable {
  pageInfo: <T = PageInfo>() => T;
  edges: <T = FragmentableArray<EventEdgeNode>>() => T;
  aggregate: <T = AggregateEvent>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnectionNode>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface SpecialFundraiserSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface SpecialFundraiserSubscriptionPayload
  extends Promise<SpecialFundraiserSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpecialFundraiser>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpecialFundraiserPreviousValues>() => T;
}

export interface SpecialFundraiserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpecialFundraiserSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpecialFundraiserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpecialFundraiserPreviousValuesSubscription>() => T;
}

export interface UserNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
}

export interface User extends Promise<UserNode>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  email: () => Promise<String>;
  nameFirst: () => Promise<String>;
  nameLast: () => Promise<String>;
  picture: () => Promise<String>;
  securityToken: () => Promise<Int>;
  username: () => Promise<String>;
  circles: <T = FragmentableArray<CircleNode>>(
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  circlesOwned: <T = FragmentableArray<CircleNode>>(
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  dots: <T = FragmentableArray<DotNode>>(
    args?: {
      where?: DotWhereInput;
      orderBy?: DotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  followedCharities: <T = FragmentableArray<CharityNode>>(
    args?: {
      where?: CharityWhereInput;
      orderBy?: CharityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  halos: <T = FragmentableArray<HaloNode>>(
    args?: {
      where?: HaloWhereInput;
      orderBy?: HaloOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  identity: <T = Identity>() => T;
  loops: <T = FragmentableArray<LoopNode>>(
    args?: {
      where?: LoopWhereInput;
      orderBy?: LoopOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  preferences: <T = Preferences>() => T;
  transactions: <T = FragmentableArray<TransactionNode>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<UserNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bio: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameLast: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  securityToken: () => Promise<AsyncIterator<Int>>;
  username: () => Promise<AsyncIterator<String>>;
  circles: <T = Promise<AsyncIterator<CircleSubscription>>>(
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  circlesOwned: <T = Promise<AsyncIterator<CircleSubscription>>>(
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  dots: <T = Promise<AsyncIterator<DotSubscription>>>(
    args?: {
      where?: DotWhereInput;
      orderBy?: DotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  followedCharities: <T = Promise<AsyncIterator<CharitySubscription>>>(
    args?: {
      where?: CharityWhereInput;
      orderBy?: CharityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  halos: <T = Promise<AsyncIterator<HaloSubscription>>>(
    args?: {
      where?: HaloWhereInput;
      orderBy?: HaloOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  identity: <T = IdentitySubscription>() => T;
  loops: <T = Promise<AsyncIterator<LoopSubscription>>>(
    args?: {
      where?: LoopWhereInput;
      orderBy?: LoopOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  preferences: <T = PreferencesSubscription>() => T;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface PreferencesPreviousValuesNode {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  allowDonationEmails: Boolean;
  publicProfile: Boolean;
}

export interface PreferencesPreviousValues
  extends Promise<PreferencesPreviousValuesNode>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  allowDonationEmails: () => Promise<Boolean>;
  publicProfile: () => Promise<Boolean>;
}

export interface PreferencesPreviousValuesSubscription
  extends Promise<AsyncIterator<PreferencesPreviousValuesNode>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  allowDonationEmails: () => Promise<AsyncIterator<Boolean>>;
  publicProfile: () => Promise<AsyncIterator<Boolean>>;
}

export interface PreferencesSubscriptionPayloadNode {
  mutation: MutationType;
  updatedFields?: String[];
}

export interface PreferencesSubscriptionPayload
  extends Promise<PreferencesSubscriptionPayloadNode>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = Preferences>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PreferencesPreviousValues>() => T;
}

export interface PreferencesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PreferencesSubscriptionPayloadNode>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PreferencesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PreferencesPreviousValuesSubscription>() => T;
}

export interface AggregateCircleNode {
  count: Int;
}

export interface AggregateCircle
  extends Promise<AggregateCircleNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCircleSubscription
  extends Promise<AsyncIterator<AggregateCircleNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HaloEdgeNode {
  cursor: String;
}

export interface HaloEdge extends Promise<HaloEdgeNode>, Fragmentable {
  node: <T = Halo>() => T;
  cursor: () => Promise<String>;
}

export interface HaloEdgeSubscription
  extends Promise<AsyncIterator<HaloEdgeNode>>,
    Fragmentable {
  node: <T = HaloSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateLoopNode {
  count: Int;
}

export interface AggregateLoop
  extends Promise<AggregateLoopNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoopSubscription
  extends Promise<AsyncIterator<AggregateLoopNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateSpecialFundraiserNode {
  count: Int;
}

export interface AggregateSpecialFundraiser
  extends Promise<AggregateSpecialFundraiserNode>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpecialFundraiserSubscription
  extends Promise<AsyncIterator<AggregateSpecialFundraiserNode>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](http://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Type Defs
 */

export const prisma: Prisma;
