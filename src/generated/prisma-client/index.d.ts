// Code generated by Prisma (prisma@1.33.0). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  charge: (where?: ChargeWhereInput) => Promise<boolean>;
  charity: (where?: CharityWhereInput) => Promise<boolean>;
  charityAuthHistory: (
    where?: CharityAuthHistoryWhereInput
  ) => Promise<boolean>;
  circle: (where?: CircleWhereInput) => Promise<boolean>;
  circleInvite: (where?: CircleInviteWhereInput) => Promise<boolean>;
  circleJoinRequest: (where?: CircleJoinRequestWhereInput) => Promise<boolean>;
  dot: (where?: DotWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  halo: (where?: HaloWhereInput) => Promise<boolean>;
  identity: (where?: IdentityWhereInput) => Promise<boolean>;
  loop: (where?: LoopWhereInput) => Promise<boolean>;
  preferences: (where?: PreferencesWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  transfer: (where?: TransferWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  charge: (where: ChargeWhereUniqueInput) => ChargeNullablePromise;
  charges: (args?: {
    where?: ChargeWhereInput;
    orderBy?: ChargeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Charge>;
  chargesConnection: (args?: {
    where?: ChargeWhereInput;
    orderBy?: ChargeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChargeConnectionPromise;
  charity: (where: CharityWhereUniqueInput) => CharityNullablePromise;
  charities: (args?: {
    where?: CharityWhereInput;
    orderBy?: CharityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Charity>;
  charitiesConnection: (args?: {
    where?: CharityWhereInput;
    orderBy?: CharityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CharityConnectionPromise;
  charityAuthHistory: (
    where: CharityAuthHistoryWhereUniqueInput
  ) => CharityAuthHistoryNullablePromise;
  charityAuthHistories: (args?: {
    where?: CharityAuthHistoryWhereInput;
    orderBy?: CharityAuthHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CharityAuthHistory>;
  charityAuthHistoriesConnection: (args?: {
    where?: CharityAuthHistoryWhereInput;
    orderBy?: CharityAuthHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CharityAuthHistoryConnectionPromise;
  circle: (where: CircleWhereUniqueInput) => CircleNullablePromise;
  circles: (args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Circle>;
  circlesConnection: (args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CircleConnectionPromise;
  circleInvite: (
    where: CircleInviteWhereUniqueInput
  ) => CircleInviteNullablePromise;
  circleInvites: (args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CircleInvite>;
  circleInvitesConnection: (args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CircleInviteConnectionPromise;
  circleJoinRequest: (
    where: CircleJoinRequestWhereUniqueInput
  ) => CircleJoinRequestNullablePromise;
  circleJoinRequests: (args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<CircleJoinRequest>;
  circleJoinRequestsConnection: (args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CircleJoinRequestConnectionPromise;
  dot: (where: DotWhereUniqueInput) => DotNullablePromise;
  dots: (args?: {
    where?: DotWhereInput;
    orderBy?: DotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Dot>;
  dotsConnection: (args?: {
    where?: DotWhereInput;
    orderBy?: DotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => DotConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  halo: (where: HaloWhereUniqueInput) => HaloNullablePromise;
  haloes: (args?: {
    where?: HaloWhereInput;
    orderBy?: HaloOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Halo>;
  haloesConnection: (args?: {
    where?: HaloWhereInput;
    orderBy?: HaloOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => HaloConnectionPromise;
  identity: (where: IdentityWhereUniqueInput) => IdentityNullablePromise;
  identities: (args?: {
    where?: IdentityWhereInput;
    orderBy?: IdentityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Identity>;
  identitiesConnection: (args?: {
    where?: IdentityWhereInput;
    orderBy?: IdentityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => IdentityConnectionPromise;
  loop: (where: LoopWhereUniqueInput) => LoopNullablePromise;
  loops: (args?: {
    where?: LoopWhereInput;
    orderBy?: LoopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Loop>;
  loopsConnection: (args?: {
    where?: LoopWhereInput;
    orderBy?: LoopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => LoopConnectionPromise;
  preferences: (
    where: PreferencesWhereUniqueInput
  ) => PreferencesNullablePromise;
  preferenceses: (args?: {
    where?: PreferencesWhereInput;
    orderBy?: PreferencesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Preferences>;
  preferencesesConnection: (args?: {
    where?: PreferencesWhereInput;
    orderBy?: PreferencesOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PreferencesConnectionPromise;
  transaction: (
    where: TransactionWhereUniqueInput
  ) => TransactionNullablePromise;
  transactions: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Transaction>;
  transactionsConnection: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TransactionConnectionPromise;
  transfer: (where: TransferWhereUniqueInput) => TransferNullablePromise;
  transfers: (args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Transfer>;
  transfersConnection: (args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TransferConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCharge: (data: ChargeCreateInput) => ChargePromise;
  updateCharge: (args: {
    data: ChargeUpdateInput;
    where: ChargeWhereUniqueInput;
  }) => ChargePromise;
  updateManyCharges: (args: {
    data: ChargeUpdateManyMutationInput;
    where?: ChargeWhereInput;
  }) => BatchPayloadPromise;
  upsertCharge: (args: {
    where: ChargeWhereUniqueInput;
    create: ChargeCreateInput;
    update: ChargeUpdateInput;
  }) => ChargePromise;
  deleteCharge: (where: ChargeWhereUniqueInput) => ChargePromise;
  deleteManyCharges: (where?: ChargeWhereInput) => BatchPayloadPromise;
  createCharity: (data: CharityCreateInput) => CharityPromise;
  updateCharity: (args: {
    data: CharityUpdateInput;
    where: CharityWhereUniqueInput;
  }) => CharityPromise;
  updateManyCharities: (args: {
    data: CharityUpdateManyMutationInput;
    where?: CharityWhereInput;
  }) => BatchPayloadPromise;
  upsertCharity: (args: {
    where: CharityWhereUniqueInput;
    create: CharityCreateInput;
    update: CharityUpdateInput;
  }) => CharityPromise;
  deleteCharity: (where: CharityWhereUniqueInput) => CharityPromise;
  deleteManyCharities: (where?: CharityWhereInput) => BatchPayloadPromise;
  createCharityAuthHistory: (
    data: CharityAuthHistoryCreateInput
  ) => CharityAuthHistoryPromise;
  updateCharityAuthHistory: (args: {
    data: CharityAuthHistoryUpdateInput;
    where: CharityAuthHistoryWhereUniqueInput;
  }) => CharityAuthHistoryPromise;
  upsertCharityAuthHistory: (args: {
    where: CharityAuthHistoryWhereUniqueInput;
    create: CharityAuthHistoryCreateInput;
    update: CharityAuthHistoryUpdateInput;
  }) => CharityAuthHistoryPromise;
  deleteCharityAuthHistory: (
    where: CharityAuthHistoryWhereUniqueInput
  ) => CharityAuthHistoryPromise;
  deleteManyCharityAuthHistories: (
    where?: CharityAuthHistoryWhereInput
  ) => BatchPayloadPromise;
  createCircle: (data: CircleCreateInput) => CirclePromise;
  updateCircle: (args: {
    data: CircleUpdateInput;
    where: CircleWhereUniqueInput;
  }) => CirclePromise;
  updateManyCircles: (args: {
    data: CircleUpdateManyMutationInput;
    where?: CircleWhereInput;
  }) => BatchPayloadPromise;
  upsertCircle: (args: {
    where: CircleWhereUniqueInput;
    create: CircleCreateInput;
    update: CircleUpdateInput;
  }) => CirclePromise;
  deleteCircle: (where: CircleWhereUniqueInput) => CirclePromise;
  deleteManyCircles: (where?: CircleWhereInput) => BatchPayloadPromise;
  createCircleInvite: (data: CircleInviteCreateInput) => CircleInvitePromise;
  updateCircleInvite: (args: {
    data: CircleInviteUpdateInput;
    where: CircleInviteWhereUniqueInput;
  }) => CircleInvitePromise;
  upsertCircleInvite: (args: {
    where: CircleInviteWhereUniqueInput;
    create: CircleInviteCreateInput;
    update: CircleInviteUpdateInput;
  }) => CircleInvitePromise;
  deleteCircleInvite: (
    where: CircleInviteWhereUniqueInput
  ) => CircleInvitePromise;
  deleteManyCircleInvites: (
    where?: CircleInviteWhereInput
  ) => BatchPayloadPromise;
  createCircleJoinRequest: (
    data: CircleJoinRequestCreateInput
  ) => CircleJoinRequestPromise;
  updateCircleJoinRequest: (args: {
    data: CircleJoinRequestUpdateInput;
    where: CircleJoinRequestWhereUniqueInput;
  }) => CircleJoinRequestPromise;
  upsertCircleJoinRequest: (args: {
    where: CircleJoinRequestWhereUniqueInput;
    create: CircleJoinRequestCreateInput;
    update: CircleJoinRequestUpdateInput;
  }) => CircleJoinRequestPromise;
  deleteCircleJoinRequest: (
    where: CircleJoinRequestWhereUniqueInput
  ) => CircleJoinRequestPromise;
  deleteManyCircleJoinRequests: (
    where?: CircleJoinRequestWhereInput
  ) => BatchPayloadPromise;
  createDot: (data: DotCreateInput) => DotPromise;
  updateDot: (args: {
    data: DotUpdateInput;
    where: DotWhereUniqueInput;
  }) => DotPromise;
  updateManyDots: (args: {
    data: DotUpdateManyMutationInput;
    where?: DotWhereInput;
  }) => BatchPayloadPromise;
  upsertDot: (args: {
    where: DotWhereUniqueInput;
    create: DotCreateInput;
    update: DotUpdateInput;
  }) => DotPromise;
  deleteDot: (where: DotWhereUniqueInput) => DotPromise;
  deleteManyDots: (where?: DotWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createHalo: (data: HaloCreateInput) => HaloPromise;
  updateHalo: (args: {
    data: HaloUpdateInput;
    where: HaloWhereUniqueInput;
  }) => HaloPromise;
  updateManyHaloes: (args: {
    data: HaloUpdateManyMutationInput;
    where?: HaloWhereInput;
  }) => BatchPayloadPromise;
  upsertHalo: (args: {
    where: HaloWhereUniqueInput;
    create: HaloCreateInput;
    update: HaloUpdateInput;
  }) => HaloPromise;
  deleteHalo: (where: HaloWhereUniqueInput) => HaloPromise;
  deleteManyHaloes: (where?: HaloWhereInput) => BatchPayloadPromise;
  createIdentity: (data: IdentityCreateInput) => IdentityPromise;
  updateIdentity: (args: {
    data: IdentityUpdateInput;
    where: IdentityWhereUniqueInput;
  }) => IdentityPromise;
  updateManyIdentities: (args: {
    data: IdentityUpdateManyMutationInput;
    where?: IdentityWhereInput;
  }) => BatchPayloadPromise;
  upsertIdentity: (args: {
    where: IdentityWhereUniqueInput;
    create: IdentityCreateInput;
    update: IdentityUpdateInput;
  }) => IdentityPromise;
  deleteIdentity: (where: IdentityWhereUniqueInput) => IdentityPromise;
  deleteManyIdentities: (where?: IdentityWhereInput) => BatchPayloadPromise;
  createLoop: (data: LoopCreateInput) => LoopPromise;
  updateLoop: (args: {
    data: LoopUpdateInput;
    where: LoopWhereUniqueInput;
  }) => LoopPromise;
  updateManyLoops: (args: {
    data: LoopUpdateManyMutationInput;
    where?: LoopWhereInput;
  }) => BatchPayloadPromise;
  upsertLoop: (args: {
    where: LoopWhereUniqueInput;
    create: LoopCreateInput;
    update: LoopUpdateInput;
  }) => LoopPromise;
  deleteLoop: (where: LoopWhereUniqueInput) => LoopPromise;
  deleteManyLoops: (where?: LoopWhereInput) => BatchPayloadPromise;
  createPreferences: (data: PreferencesCreateInput) => PreferencesPromise;
  updatePreferences: (args: {
    data: PreferencesUpdateInput;
    where: PreferencesWhereUniqueInput;
  }) => PreferencesPromise;
  updateManyPreferenceses: (args: {
    data: PreferencesUpdateManyMutationInput;
    where?: PreferencesWhereInput;
  }) => BatchPayloadPromise;
  upsertPreferences: (args: {
    where: PreferencesWhereUniqueInput;
    create: PreferencesCreateInput;
    update: PreferencesUpdateInput;
  }) => PreferencesPromise;
  deletePreferences: (where: PreferencesWhereUniqueInput) => PreferencesPromise;
  deleteManyPreferenceses: (
    where?: PreferencesWhereInput
  ) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (args: {
    data: TransactionUpdateInput;
    where: TransactionWhereUniqueInput;
  }) => TransactionPromise;
  updateManyTransactions: (args: {
    data: TransactionUpdateManyMutationInput;
    where?: TransactionWhereInput;
  }) => BatchPayloadPromise;
  upsertTransaction: (args: {
    where: TransactionWhereUniqueInput;
    create: TransactionCreateInput;
    update: TransactionUpdateInput;
  }) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;
  createTransfer: (data: TransferCreateInput) => TransferPromise;
  updateTransfer: (args: {
    data: TransferUpdateInput;
    where: TransferWhereUniqueInput;
  }) => TransferPromise;
  updateManyTransfers: (args: {
    data: TransferUpdateManyMutationInput;
    where?: TransferWhereInput;
  }) => BatchPayloadPromise;
  upsertTransfer: (args: {
    where: TransferWhereUniqueInput;
    create: TransferCreateInput;
    update: TransferUpdateInput;
  }) => TransferPromise;
  deleteTransfer: (where: TransferWhereUniqueInput) => TransferPromise;
  deleteManyTransfers: (where?: TransferWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  charge: (
    where?: ChargeSubscriptionWhereInput
  ) => ChargeSubscriptionPayloadSubscription;
  charity: (
    where?: CharitySubscriptionWhereInput
  ) => CharitySubscriptionPayloadSubscription;
  charityAuthHistory: (
    where?: CharityAuthHistorySubscriptionWhereInput
  ) => CharityAuthHistorySubscriptionPayloadSubscription;
  circle: (
    where?: CircleSubscriptionWhereInput
  ) => CircleSubscriptionPayloadSubscription;
  circleInvite: (
    where?: CircleInviteSubscriptionWhereInput
  ) => CircleInviteSubscriptionPayloadSubscription;
  circleJoinRequest: (
    where?: CircleJoinRequestSubscriptionWhereInput
  ) => CircleJoinRequestSubscriptionPayloadSubscription;
  dot: (
    where?: DotSubscriptionWhereInput
  ) => DotSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  halo: (
    where?: HaloSubscriptionWhereInput
  ) => HaloSubscriptionPayloadSubscription;
  identity: (
    where?: IdentitySubscriptionWhereInput
  ) => IdentitySubscriptionPayloadSubscription;
  loop: (
    where?: LoopSubscriptionWhereInput
  ) => LoopSubscriptionPayloadSubscription;
  preferences: (
    where?: PreferencesSubscriptionWhereInput
  ) => PreferencesSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  transfer: (
    where?: TransferSubscriptionWhereInput
  ) => TransferSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "action_ASC"
  | "action_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "total_ASC"
  | "total_DESC";

export type IdentityProvider = "FACEBOOK" | "GOOGLE";

export type CircleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "open_ASC"
  | "open_DESC";

export type PreferencesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "allowDonationEmails_ASC"
  | "allowDonationEmails_DESC"
  | "publicProfile_ASC"
  | "publicProfile_DESC";

export type CircleInviteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "balance_ASC"
  | "balance_DESC";

export type CircleJoinRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HaloOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "key_ASC"
  | "key_DESC"
  | "tier_ASC"
  | "tier_DESC";

export type TransferOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "chargeBalance_ASC"
  | "chargeBalance_DESC"
  | "firstOfBatch_ASC"
  | "firstOfBatch_DESC"
  | "transferID_ASC"
  | "transferID_DESC";

export type CharityAuthHistoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "goal_ASC"
  | "goal_DESC"
  | "multiplier_ASC"
  | "multiplier_DESC"
  | "specialEvent_ASC"
  | "specialEvent_DESC"
  | "specialEventDescription_ASC"
  | "specialEventDescription_DESC"
  | "specialEventName_ASC"
  | "specialEventName_DESC"
  | "sponsorName_ASC"
  | "sponsorName_DESC"
  | "sponsorWebsite_ASC"
  | "sponsorWebsite_DESC"
  | "startDate_ASC"
  | "startDate_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "email_ASC"
  | "email_DESC"
  | "nameFirst_ASC"
  | "nameFirst_DESC"
  | "nameLast_ASC"
  | "nameLast_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "securityToken_ASC"
  | "securityToken_DESC"
  | "username_ASC"
  | "username_DESC";

export type ChargeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "amountAdded_ASC"
  | "amountAdded_DESC"
  | "amountNet_ASC"
  | "amountNet_DESC"
  | "chargeID_ASC"
  | "chargeID_DESC";

export type LoopOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "count_ASC"
  | "count_DESC";

export type IdentityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "provider_ASC"
  | "provider_DESC"
  | "providerID_ASC"
  | "providerID_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type CharityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "acronym_ASC"
  | "acronym_DESC"
  | "banner_ASC"
  | "banner_DESC"
  | "bannerCredit_ASC"
  | "bannerCredit_DESC"
  | "connectedAccountID_ASC"
  | "connectedAccountID_DESC"
  | "ein_ASC"
  | "ein_DESC"
  | "email_ASC"
  | "email_DESC"
  | "expensesAdministrative_ASC"
  | "expensesAdministrative_DESC"
  | "expensesFundraising_ASC"
  | "expensesFundraising_DESC"
  | "expensesOther_ASC"
  | "expensesOther_DESC"
  | "expensesProgram_ASC"
  | "expensesProgram_DESC"
  | "expensesUpdated_ASC"
  | "expensesUpdated_DESC"
  | "location_ASC"
  | "location_DESC"
  | "logo_ASC"
  | "logo_DESC"
  | "mission_ASC"
  | "mission_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "representative_ASC"
  | "representative_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "website_ASC"
  | "website_DESC";

export interface CircleScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  open?: Maybe<Boolean>;
  open_not?: Maybe<Boolean>;
  AND?: Maybe<CircleScalarWhereInput[] | CircleScalarWhereInput>;
  OR?: Maybe<CircleScalarWhereInput[] | CircleScalarWhereInput>;
  NOT?: Maybe<CircleScalarWhereInput[] | CircleScalarWhereInput>;
}

export type ChargeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CharityUpdateManyWithoutFollowersInput {
  create?: Maybe<
    CharityCreateWithoutFollowersInput[] | CharityCreateWithoutFollowersInput
  >;
  delete?: Maybe<CharityWhereUniqueInput[] | CharityWhereUniqueInput>;
  connect?: Maybe<CharityWhereUniqueInput[] | CharityWhereUniqueInput>;
  set?: Maybe<CharityWhereUniqueInput[] | CharityWhereUniqueInput>;
  disconnect?: Maybe<CharityWhereUniqueInput[] | CharityWhereUniqueInput>;
  update?: Maybe<
    | CharityUpdateWithWhereUniqueWithoutFollowersInput[]
    | CharityUpdateWithWhereUniqueWithoutFollowersInput
  >;
  upsert?: Maybe<
    | CharityUpsertWithWhereUniqueWithoutFollowersInput[]
    | CharityUpsertWithWhereUniqueWithoutFollowersInput
  >;
  deleteMany?: Maybe<CharityScalarWhereInput[] | CharityScalarWhereInput>;
  updateMany?: Maybe<
    | CharityUpdateManyWithWhereNestedInput[]
    | CharityUpdateManyWithWhereNestedInput
  >;
}

export interface HaloWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  tier?: Maybe<String>;
  tier_not?: Maybe<String>;
  tier_in?: Maybe<String[] | String>;
  tier_not_in?: Maybe<String[] | String>;
  tier_lt?: Maybe<String>;
  tier_lte?: Maybe<String>;
  tier_gt?: Maybe<String>;
  tier_gte?: Maybe<String>;
  tier_contains?: Maybe<String>;
  tier_not_contains?: Maybe<String>;
  tier_starts_with?: Maybe<String>;
  tier_not_starts_with?: Maybe<String>;
  tier_ends_with?: Maybe<String>;
  tier_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<HaloWhereInput[] | HaloWhereInput>;
  OR?: Maybe<HaloWhereInput[] | HaloWhereInput>;
  NOT?: Maybe<HaloWhereInput[] | HaloWhereInput>;
}

export interface CharityUpdateWithWhereUniqueWithoutFollowersInput {
  where: CharityWhereUniqueInput;
  data: CharityUpdateWithoutFollowersDataInput;
}

export interface TransactionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  balance?: Maybe<Int>;
  balance_not?: Maybe<Int>;
  balance_in?: Maybe<Int[] | Int>;
  balance_not_in?: Maybe<Int[] | Int>;
  balance_lt?: Maybe<Int>;
  balance_lte?: Maybe<Int>;
  balance_gt?: Maybe<Int>;
  balance_gte?: Maybe<Int>;
  donations_every?: Maybe<TransferWhereInput>;
  donations_some?: Maybe<TransferWhereInput>;
  donations_none?: Maybe<TransferWhereInput>;
  funds?: Maybe<ChargeWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  OR?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  NOT?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
}

export interface CharityUpdateWithoutFollowersDataInput {
  acronym?: Maybe<String>;
  banner?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  email?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  representative?: Maybe<String>;
  verified?: Maybe<Boolean>;
  website?: Maybe<String>;
  authHistory?: Maybe<CharityAuthHistoryUpdateManyWithoutCharityInput>;
  events?: Maybe<EventUpdateManyWithoutCharityInput>;
}

export interface PreferencesWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  allowDonationEmails?: Maybe<Boolean>;
  allowDonationEmails_not?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
  publicProfile_not?: Maybe<Boolean>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<PreferencesWhereInput[] | PreferencesWhereInput>;
  OR?: Maybe<PreferencesWhereInput[] | PreferencesWhereInput>;
  NOT?: Maybe<PreferencesWhereInput[] | PreferencesWhereInput>;
}

export interface CharityUpdateWithoutEventsDataInput {
  acronym?: Maybe<String>;
  banner?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  email?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  representative?: Maybe<String>;
  verified?: Maybe<Boolean>;
  website?: Maybe<String>;
  authHistory?: Maybe<CharityAuthHistoryUpdateManyWithoutCharityInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowedCharitiesInput>;
}

export interface CircleJoinRequestCreateInput {
  id?: Maybe<ID_Input>;
  circle: CircleCreateOneWithoutJoinRequestsInput;
  user: UserCreateOneWithoutCircleJoinRequestsInput;
}

export interface CharityAuthHistoryUpdateManyWithoutCharityInput {
  create?: Maybe<
    | CharityAuthHistoryCreateWithoutCharityInput[]
    | CharityAuthHistoryCreateWithoutCharityInput
  >;
  delete?: Maybe<
    CharityAuthHistoryWhereUniqueInput[] | CharityAuthHistoryWhereUniqueInput
  >;
  connect?: Maybe<
    CharityAuthHistoryWhereUniqueInput[] | CharityAuthHistoryWhereUniqueInput
  >;
  set?: Maybe<
    CharityAuthHistoryWhereUniqueInput[] | CharityAuthHistoryWhereUniqueInput
  >;
  disconnect?: Maybe<
    CharityAuthHistoryWhereUniqueInput[] | CharityAuthHistoryWhereUniqueInput
  >;
  deleteMany?: Maybe<
    CharityAuthHistoryScalarWhereInput[] | CharityAuthHistoryScalarWhereInput
  >;
}

export interface EventUpdateManyWithoutCharityInput {
  create?: Maybe<
    EventCreateWithoutCharityInput[] | EventCreateWithoutCharityInput
  >;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutCharityInput[]
    | EventUpdateWithWhereUniqueWithoutCharityInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutCharityInput[]
    | EventUpsertWithWhereUniqueWithoutCharityInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface CharityAuthHistoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CharityAuthHistoryScalarWhereInput[] | CharityAuthHistoryScalarWhereInput
  >;
  OR?: Maybe<
    CharityAuthHistoryScalarWhereInput[] | CharityAuthHistoryScalarWhereInput
  >;
  NOT?: Maybe<
    CharityAuthHistoryScalarWhereInput[] | CharityAuthHistoryScalarWhereInput
  >;
}

export interface DotWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  action?: Maybe<String>;
  action_not?: Maybe<String>;
  action_in?: Maybe<String[] | String>;
  action_not_in?: Maybe<String[] | String>;
  action_lt?: Maybe<String>;
  action_lte?: Maybe<String>;
  action_gt?: Maybe<String>;
  action_gte?: Maybe<String>;
  action_contains?: Maybe<String>;
  action_not_contains?: Maybe<String>;
  action_starts_with?: Maybe<String>;
  action_not_starts_with?: Maybe<String>;
  action_ends_with?: Maybe<String>;
  action_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  total?: Maybe<Int>;
  total_not?: Maybe<Int>;
  total_in?: Maybe<Int[] | Int>;
  total_not_in?: Maybe<Int[] | Int>;
  total_lt?: Maybe<Int>;
  total_lte?: Maybe<Int>;
  total_gt?: Maybe<Int>;
  total_gte?: Maybe<Int>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<DotWhereInput[] | DotWhereInput>;
  OR?: Maybe<DotWhereInput[] | DotWhereInput>;
  NOT?: Maybe<DotWhereInput[] | DotWhereInput>;
}

export interface UserUpdateManyWithoutFollowedCharitiesInput {
  create?: Maybe<
    | UserCreateWithoutFollowedCharitiesInput[]
    | UserCreateWithoutFollowedCharitiesInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput[]
    | UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput[]
    | UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface CircleInviteWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  circle?: Maybe<CircleWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<CircleInviteWhereInput[] | CircleInviteWhereInput>;
  OR?: Maybe<CircleInviteWhereInput[] | CircleInviteWhereInput>;
  NOT?: Maybe<CircleInviteWhereInput[] | CircleInviteWhereInput>;
}

export interface UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFollowedCharitiesDataInput;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TransactionWhereInput>;
  AND?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  OR?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
}

export interface UserUpdateWithoutFollowedCharitiesDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface PreferencesSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PreferencesWhereInput>;
  AND?: Maybe<
    PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput
  >;
  OR?: Maybe<
    PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput
  >;
  NOT?: Maybe<
    PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput
  >;
}

export interface CircleJoinRequestUpdateManyWithoutUserInput {
  create?: Maybe<
    | CircleJoinRequestCreateWithoutUserInput[]
    | CircleJoinRequestCreateWithoutUserInput
  >;
  delete?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  connect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  set?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  update?: Maybe<
    | CircleJoinRequestUpdateWithWhereUniqueWithoutUserInput[]
    | CircleJoinRequestUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CircleJoinRequestUpsertWithWhereUniqueWithoutUserInput[]
    | CircleJoinRequestUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput
  >;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameFirst_not?: Maybe<String>;
  nameFirst_in?: Maybe<String[] | String>;
  nameFirst_not_in?: Maybe<String[] | String>;
  nameFirst_lt?: Maybe<String>;
  nameFirst_lte?: Maybe<String>;
  nameFirst_gt?: Maybe<String>;
  nameFirst_gte?: Maybe<String>;
  nameFirst_contains?: Maybe<String>;
  nameFirst_not_contains?: Maybe<String>;
  nameFirst_starts_with?: Maybe<String>;
  nameFirst_not_starts_with?: Maybe<String>;
  nameFirst_ends_with?: Maybe<String>;
  nameFirst_not_ends_with?: Maybe<String>;
  nameLast?: Maybe<String>;
  nameLast_not?: Maybe<String>;
  nameLast_in?: Maybe<String[] | String>;
  nameLast_not_in?: Maybe<String[] | String>;
  nameLast_lt?: Maybe<String>;
  nameLast_lte?: Maybe<String>;
  nameLast_gt?: Maybe<String>;
  nameLast_gte?: Maybe<String>;
  nameLast_contains?: Maybe<String>;
  nameLast_not_contains?: Maybe<String>;
  nameLast_starts_with?: Maybe<String>;
  nameLast_not_starts_with?: Maybe<String>;
  nameLast_ends_with?: Maybe<String>;
  nameLast_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  securityToken?: Maybe<Int>;
  securityToken_not?: Maybe<Int>;
  securityToken_in?: Maybe<Int[] | Int>;
  securityToken_not_in?: Maybe<Int[] | Int>;
  securityToken_lt?: Maybe<Int>;
  securityToken_lte?: Maybe<Int>;
  securityToken_gt?: Maybe<Int>;
  securityToken_gte?: Maybe<Int>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  circleJoinRequests_every?: Maybe<CircleJoinRequestWhereInput>;
  circleJoinRequests_some?: Maybe<CircleJoinRequestWhereInput>;
  circleJoinRequests_none?: Maybe<CircleJoinRequestWhereInput>;
  circleInvites_every?: Maybe<CircleInviteWhereInput>;
  circleInvites_some?: Maybe<CircleInviteWhereInput>;
  circleInvites_none?: Maybe<CircleInviteWhereInput>;
  circles_every?: Maybe<CircleWhereInput>;
  circles_some?: Maybe<CircleWhereInput>;
  circles_none?: Maybe<CircleWhereInput>;
  circlesOwned_every?: Maybe<CircleWhereInput>;
  circlesOwned_some?: Maybe<CircleWhereInput>;
  circlesOwned_none?: Maybe<CircleWhereInput>;
  dots_every?: Maybe<DotWhereInput>;
  dots_some?: Maybe<DotWhereInput>;
  dots_none?: Maybe<DotWhereInput>;
  followedCharities_every?: Maybe<CharityWhereInput>;
  followedCharities_some?: Maybe<CharityWhereInput>;
  followedCharities_none?: Maybe<CharityWhereInput>;
  funds_every?: Maybe<ChargeWhereInput>;
  funds_some?: Maybe<ChargeWhereInput>;
  funds_none?: Maybe<ChargeWhereInput>;
  halos_every?: Maybe<HaloWhereInput>;
  halos_some?: Maybe<HaloWhereInput>;
  halos_none?: Maybe<HaloWhereInput>;
  identity?: Maybe<IdentityWhereInput>;
  loops_every?: Maybe<LoopWhereInput>;
  loops_some?: Maybe<LoopWhereInput>;
  loops_none?: Maybe<LoopWhereInput>;
  preferences?: Maybe<PreferencesWhereInput>;
  transactions_every?: Maybe<TransactionWhereInput>;
  transactions_some?: Maybe<TransactionWhereInput>;
  transactions_none?: Maybe<TransactionWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface CircleJoinRequestUpdateWithWhereUniqueWithoutUserInput {
  where: CircleJoinRequestWhereUniqueInput;
  data: CircleJoinRequestUpdateWithoutUserDataInput;
}

export interface CharityAuthHistoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  charity?: Maybe<CharityWhereInput>;
  AND?: Maybe<CharityAuthHistoryWhereInput[] | CharityAuthHistoryWhereInput>;
  OR?: Maybe<CharityAuthHistoryWhereInput[] | CharityAuthHistoryWhereInput>;
  NOT?: Maybe<CharityAuthHistoryWhereInput[] | CharityAuthHistoryWhereInput>;
}

export interface CircleJoinRequestUpdateWithoutUserDataInput {
  circle?: Maybe<CircleUpdateOneRequiredWithoutJoinRequestsInput>;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface CircleUpdateOneRequiredWithoutJoinRequestsInput {
  create?: Maybe<CircleCreateWithoutJoinRequestsInput>;
  update?: Maybe<CircleUpdateWithoutJoinRequestsDataInput>;
  upsert?: Maybe<CircleUpsertWithoutJoinRequestsInput>;
  connect?: Maybe<CircleWhereUniqueInput>;
}

export interface EventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  goal_not?: Maybe<Int>;
  goal_in?: Maybe<Int[] | Int>;
  goal_not_in?: Maybe<Int[] | Int>;
  goal_lt?: Maybe<Int>;
  goal_lte?: Maybe<Int>;
  goal_gt?: Maybe<Int>;
  goal_gte?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  multiplier_not?: Maybe<Int>;
  multiplier_in?: Maybe<Int[] | Int>;
  multiplier_not_in?: Maybe<Int[] | Int>;
  multiplier_lt?: Maybe<Int>;
  multiplier_lte?: Maybe<Int>;
  multiplier_gt?: Maybe<Int>;
  multiplier_gte?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEvent_not?: Maybe<String>;
  specialEvent_in?: Maybe<String[] | String>;
  specialEvent_not_in?: Maybe<String[] | String>;
  specialEvent_lt?: Maybe<String>;
  specialEvent_lte?: Maybe<String>;
  specialEvent_gt?: Maybe<String>;
  specialEvent_gte?: Maybe<String>;
  specialEvent_contains?: Maybe<String>;
  specialEvent_not_contains?: Maybe<String>;
  specialEvent_starts_with?: Maybe<String>;
  specialEvent_not_starts_with?: Maybe<String>;
  specialEvent_ends_with?: Maybe<String>;
  specialEvent_not_ends_with?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventDescription_not?: Maybe<String>;
  specialEventDescription_in?: Maybe<String[] | String>;
  specialEventDescription_not_in?: Maybe<String[] | String>;
  specialEventDescription_lt?: Maybe<String>;
  specialEventDescription_lte?: Maybe<String>;
  specialEventDescription_gt?: Maybe<String>;
  specialEventDescription_gte?: Maybe<String>;
  specialEventDescription_contains?: Maybe<String>;
  specialEventDescription_not_contains?: Maybe<String>;
  specialEventDescription_starts_with?: Maybe<String>;
  specialEventDescription_not_starts_with?: Maybe<String>;
  specialEventDescription_ends_with?: Maybe<String>;
  specialEventDescription_not_ends_with?: Maybe<String>;
  specialEventName?: Maybe<String>;
  specialEventName_not?: Maybe<String>;
  specialEventName_in?: Maybe<String[] | String>;
  specialEventName_not_in?: Maybe<String[] | String>;
  specialEventName_lt?: Maybe<String>;
  specialEventName_lte?: Maybe<String>;
  specialEventName_gt?: Maybe<String>;
  specialEventName_gte?: Maybe<String>;
  specialEventName_contains?: Maybe<String>;
  specialEventName_not_contains?: Maybe<String>;
  specialEventName_starts_with?: Maybe<String>;
  specialEventName_not_starts_with?: Maybe<String>;
  specialEventName_ends_with?: Maybe<String>;
  specialEventName_not_ends_with?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorName_not?: Maybe<String>;
  sponsorName_in?: Maybe<String[] | String>;
  sponsorName_not_in?: Maybe<String[] | String>;
  sponsorName_lt?: Maybe<String>;
  sponsorName_lte?: Maybe<String>;
  sponsorName_gt?: Maybe<String>;
  sponsorName_gte?: Maybe<String>;
  sponsorName_contains?: Maybe<String>;
  sponsorName_not_contains?: Maybe<String>;
  sponsorName_starts_with?: Maybe<String>;
  sponsorName_not_starts_with?: Maybe<String>;
  sponsorName_ends_with?: Maybe<String>;
  sponsorName_not_ends_with?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  sponsorWebsite_not?: Maybe<String>;
  sponsorWebsite_in?: Maybe<String[] | String>;
  sponsorWebsite_not_in?: Maybe<String[] | String>;
  sponsorWebsite_lt?: Maybe<String>;
  sponsorWebsite_lte?: Maybe<String>;
  sponsorWebsite_gt?: Maybe<String>;
  sponsorWebsite_gte?: Maybe<String>;
  sponsorWebsite_contains?: Maybe<String>;
  sponsorWebsite_not_contains?: Maybe<String>;
  sponsorWebsite_starts_with?: Maybe<String>;
  sponsorWebsite_not_starts_with?: Maybe<String>;
  sponsorWebsite_ends_with?: Maybe<String>;
  sponsorWebsite_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  charity?: Maybe<CharityWhereInput>;
  donations_every?: Maybe<TransferWhereInput>;
  donations_some?: Maybe<TransferWhereInput>;
  donations_none?: Maybe<TransferWhereInput>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export interface CircleUpdateWithoutJoinRequestsDataInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
  invites?: Maybe<CircleInviteUpdateManyWithoutCircleInput>;
  members?: Maybe<UserUpdateManyWithoutCirclesInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutCirclesOwnedInput>;
}

export interface CircleJoinRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CircleJoinRequestWhereInput>;
  AND?: Maybe<
    | CircleJoinRequestSubscriptionWhereInput[]
    | CircleJoinRequestSubscriptionWhereInput
  >;
  OR?: Maybe<
    | CircleJoinRequestSubscriptionWhereInput[]
    | CircleJoinRequestSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CircleJoinRequestSubscriptionWhereInput[]
    | CircleJoinRequestSubscriptionWhereInput
  >;
}

export interface CircleInviteUpdateManyWithoutCircleInput {
  create?: Maybe<
    | CircleInviteCreateWithoutCircleInput[]
    | CircleInviteCreateWithoutCircleInput
  >;
  delete?: Maybe<CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput>;
  connect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
  set?: Maybe<CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput>;
  disconnect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
  update?: Maybe<
    | CircleInviteUpdateWithWhereUniqueWithoutCircleInput[]
    | CircleInviteUpdateWithWhereUniqueWithoutCircleInput
  >;
  upsert?: Maybe<
    | CircleInviteUpsertWithWhereUniqueWithoutCircleInput[]
    | CircleInviteUpsertWithWhereUniqueWithoutCircleInput
  >;
  deleteMany?: Maybe<
    CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput
  >;
}

export interface TransferWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  chargeBalance?: Maybe<Int>;
  chargeBalance_not?: Maybe<Int>;
  chargeBalance_in?: Maybe<Int[] | Int>;
  chargeBalance_not_in?: Maybe<Int[] | Int>;
  chargeBalance_lt?: Maybe<Int>;
  chargeBalance_lte?: Maybe<Int>;
  chargeBalance_gt?: Maybe<Int>;
  chargeBalance_gte?: Maybe<Int>;
  firstOfBatch?: Maybe<Boolean>;
  firstOfBatch_not?: Maybe<Boolean>;
  transferID?: Maybe<String>;
  transferID_not?: Maybe<String>;
  transferID_in?: Maybe<String[] | String>;
  transferID_not_in?: Maybe<String[] | String>;
  transferID_lt?: Maybe<String>;
  transferID_lte?: Maybe<String>;
  transferID_gt?: Maybe<String>;
  transferID_gte?: Maybe<String>;
  transferID_contains?: Maybe<String>;
  transferID_not_contains?: Maybe<String>;
  transferID_starts_with?: Maybe<String>;
  transferID_not_starts_with?: Maybe<String>;
  transferID_ends_with?: Maybe<String>;
  transferID_not_ends_with?: Maybe<String>;
  event?: Maybe<EventWhereInput>;
  source?: Maybe<ChargeWhereInput>;
  transaction?: Maybe<TransactionWhereInput>;
  AND?: Maybe<TransferWhereInput[] | TransferWhereInput>;
  OR?: Maybe<TransferWhereInput[] | TransferWhereInput>;
  NOT?: Maybe<TransferWhereInput[] | TransferWhereInput>;
}

export interface CircleInviteUpdateWithWhereUniqueWithoutCircleInput {
  where: CircleInviteWhereUniqueInput;
  data: CircleInviteUpdateWithoutCircleDataInput;
}

export interface CharityAuthHistorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CharityAuthHistoryWhereInput>;
  AND?: Maybe<
    | CharityAuthHistorySubscriptionWhereInput[]
    | CharityAuthHistorySubscriptionWhereInput
  >;
  OR?: Maybe<
    | CharityAuthHistorySubscriptionWhereInput[]
    | CharityAuthHistorySubscriptionWhereInput
  >;
  NOT?: Maybe<
    | CharityAuthHistorySubscriptionWhereInput[]
    | CharityAuthHistorySubscriptionWhereInput
  >;
}

export interface CircleInviteUpdateWithoutCircleDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutCircleInvitesInput>;
}

export interface ChargeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChargeWhereInput>;
  AND?: Maybe<ChargeSubscriptionWhereInput[] | ChargeSubscriptionWhereInput>;
  OR?: Maybe<ChargeSubscriptionWhereInput[] | ChargeSubscriptionWhereInput>;
  NOT?: Maybe<ChargeSubscriptionWhereInput[] | ChargeSubscriptionWhereInput>;
}

export interface UserUpdateOneRequiredWithoutCircleInvitesInput {
  create?: Maybe<UserCreateWithoutCircleInvitesInput>;
  update?: Maybe<UserUpdateWithoutCircleInvitesDataInput>;
  upsert?: Maybe<UserUpsertWithoutCircleInvitesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface UserUpdateWithoutCircleInvitesDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface TransferUpdateManyMutationInput {
  amount?: Maybe<Int>;
  chargeBalance?: Maybe<Int>;
  firstOfBatch?: Maybe<Boolean>;
  transferID?: Maybe<String>;
}

export interface CircleUpdateManyWithoutMembersInput {
  create?: Maybe<
    CircleCreateWithoutMembersInput[] | CircleCreateWithoutMembersInput
  >;
  delete?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  connect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  set?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  disconnect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  update?: Maybe<
    | CircleUpdateWithWhereUniqueWithoutMembersInput[]
    | CircleUpdateWithWhereUniqueWithoutMembersInput
  >;
  upsert?: Maybe<
    | CircleUpsertWithWhereUniqueWithoutMembersInput[]
    | CircleUpsertWithWhereUniqueWithoutMembersInput
  >;
  deleteMany?: Maybe<CircleScalarWhereInput[] | CircleScalarWhereInput>;
  updateMany?: Maybe<
    | CircleUpdateManyWithWhereNestedInput[]
    | CircleUpdateManyWithWhereNestedInput
  >;
}

export interface TransferUpdateInput {
  amount?: Maybe<Int>;
  chargeBalance?: Maybe<Int>;
  firstOfBatch?: Maybe<Boolean>;
  transferID?: Maybe<String>;
  event?: Maybe<EventUpdateOneWithoutDonationsInput>;
  source?: Maybe<ChargeUpdateOneWithoutDonationsInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutDonationsInput>;
}

export interface CircleUpdateWithWhereUniqueWithoutMembersInput {
  where: CircleWhereUniqueInput;
  data: CircleUpdateWithoutMembersDataInput;
}

export interface TransactionUpdateManyMutationInput {
  balance?: Maybe<Int>;
}

export interface CircleUpdateWithoutMembersDataInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteUpdateManyWithoutCircleInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutCirclesOwnedInput>;
}

export interface TransactionUpdateInput {
  balance?: Maybe<Int>;
  donations?: Maybe<TransferUpdateManyWithoutTransactionInput>;
  funds?: Maybe<ChargeUpdateOneWithoutTransactionInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
}

export interface CircleJoinRequestUpdateManyWithoutCircleInput {
  create?: Maybe<
    | CircleJoinRequestCreateWithoutCircleInput[]
    | CircleJoinRequestCreateWithoutCircleInput
  >;
  delete?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  connect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  set?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
  update?: Maybe<
    | CircleJoinRequestUpdateWithWhereUniqueWithoutCircleInput[]
    | CircleJoinRequestUpdateWithWhereUniqueWithoutCircleInput
  >;
  upsert?: Maybe<
    | CircleJoinRequestUpsertWithWhereUniqueWithoutCircleInput[]
    | CircleJoinRequestUpsertWithWhereUniqueWithoutCircleInput
  >;
  deleteMany?: Maybe<
    CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput
  >;
}

export interface PreferencesUpdateManyMutationInput {
  allowDonationEmails?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
}

export interface CircleJoinRequestUpdateWithWhereUniqueWithoutCircleInput {
  where: CircleJoinRequestWhereUniqueInput;
  data: CircleJoinRequestUpdateWithoutCircleDataInput;
}

export interface UserUpsertWithoutPreferencesInput {
  update: UserUpdateWithoutPreferencesDataInput;
  create: UserCreateWithoutPreferencesInput;
}

export interface CircleJoinRequestUpdateWithoutCircleDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutCircleJoinRequestsInput>;
}

export interface UserUpdateOneRequiredWithoutPreferencesInput {
  create?: Maybe<UserCreateWithoutPreferencesInput>;
  update?: Maybe<UserUpdateWithoutPreferencesDataInput>;
  upsert?: Maybe<UserUpsertWithoutPreferencesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutCircleJoinRequestsInput {
  create?: Maybe<UserCreateWithoutCircleJoinRequestsInput>;
  update?: Maybe<UserUpdateWithoutCircleJoinRequestsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCircleJoinRequestsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface PreferencesUpdateInput {
  allowDonationEmails?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
  user?: Maybe<UserUpdateOneRequiredWithoutPreferencesInput>;
}

export interface UserUpdateWithoutCircleJoinRequestsDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface UserCreateOneWithoutPreferencesInput {
  create?: Maybe<UserCreateWithoutPreferencesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleInviteUpdateManyWithoutUserInput {
  create?: Maybe<
    CircleInviteCreateWithoutUserInput[] | CircleInviteCreateWithoutUserInput
  >;
  delete?: Maybe<CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput>;
  connect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
  set?: Maybe<CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput>;
  disconnect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
  update?: Maybe<
    | CircleInviteUpdateWithWhereUniqueWithoutUserInput[]
    | CircleInviteUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | CircleInviteUpsertWithWhereUniqueWithoutUserInput[]
    | CircleInviteUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput
  >;
}

export interface PreferencesCreateInput {
  id?: Maybe<ID_Input>;
  allowDonationEmails?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
  user: UserCreateOneWithoutPreferencesInput;
}

export interface CircleInviteUpdateWithWhereUniqueWithoutUserInput {
  where: CircleInviteWhereUniqueInput;
  data: CircleInviteUpdateWithoutUserDataInput;
}

export interface UserUpsertWithoutLoopsInput {
  update: UserUpdateWithoutLoopsDataInput;
  create: UserCreateWithoutLoopsInput;
}

export interface CircleInviteUpdateWithoutUserDataInput {
  circle?: Maybe<CircleUpdateOneRequiredWithoutInvitesInput>;
}

export interface UserUpdateWithoutLoopsDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface CircleUpdateOneRequiredWithoutInvitesInput {
  create?: Maybe<CircleCreateWithoutInvitesInput>;
  update?: Maybe<CircleUpdateWithoutInvitesDataInput>;
  upsert?: Maybe<CircleUpsertWithoutInvitesInput>;
  connect?: Maybe<CircleWhereUniqueInput>;
}

export interface LoopUpdateInput {
  count?: Maybe<Int>;
  event?: Maybe<EventUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutLoopsInput>;
}

export interface CircleUpdateWithoutInvitesDataInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutCircleInput>;
  members?: Maybe<UserUpdateManyWithoutCirclesInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutCirclesOwnedInput>;
}

export interface UserCreateWithoutLoopsInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface UserUpdateManyWithoutCirclesInput {
  create?: Maybe<
    UserCreateWithoutCirclesInput[] | UserCreateWithoutCirclesInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutCirclesInput[]
    | UserUpdateWithWhereUniqueWithoutCirclesInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutCirclesInput[]
    | UserUpsertWithWhereUniqueWithoutCirclesInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface LoopCreateInput {
  id?: Maybe<ID_Input>;
  count: Int;
  event: EventCreateOneInput;
  user: UserCreateOneWithoutLoopsInput;
}

export interface UserUpdateWithWhereUniqueWithoutCirclesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCirclesDataInput;
}

export interface IdentityUpdateManyMutationInput {
  provider?: Maybe<IdentityProvider>;
  providerID?: Maybe<String>;
}

export interface UserUpdateWithoutCirclesDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface UserUpdateWithoutIdentityDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface CircleUpdateManyWithoutOwnerInput {
  create?: Maybe<
    CircleCreateWithoutOwnerInput[] | CircleCreateWithoutOwnerInput
  >;
  delete?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  connect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  set?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  disconnect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
  update?: Maybe<
    | CircleUpdateWithWhereUniqueWithoutOwnerInput[]
    | CircleUpdateWithWhereUniqueWithoutOwnerInput
  >;
  upsert?: Maybe<
    | CircleUpsertWithWhereUniqueWithoutOwnerInput[]
    | CircleUpsertWithWhereUniqueWithoutOwnerInput
  >;
  deleteMany?: Maybe<CircleScalarWhereInput[] | CircleScalarWhereInput>;
  updateMany?: Maybe<
    | CircleUpdateManyWithWhereNestedInput[]
    | CircleUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateOneRequiredWithoutIdentityInput {
  create?: Maybe<UserCreateWithoutIdentityInput>;
  update?: Maybe<UserUpdateWithoutIdentityDataInput>;
  upsert?: Maybe<UserUpsertWithoutIdentityInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleUpdateWithWhereUniqueWithoutOwnerInput {
  where: CircleWhereUniqueInput;
  data: CircleUpdateWithoutOwnerDataInput;
}

export interface UserCreateWithoutIdentityInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface CircleUpdateWithoutOwnerDataInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteUpdateManyWithoutCircleInput>;
  members?: Maybe<UserUpdateManyWithoutCirclesInput>;
}

export type LoopWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CircleUpsertWithWhereUniqueWithoutOwnerInput {
  where: CircleWhereUniqueInput;
  update: CircleUpdateWithoutOwnerDataInput;
  create: CircleCreateWithoutOwnerInput;
}

export interface HaloUpdateManyMutationInput {
  key?: Maybe<String>;
  tier?: Maybe<String>;
}

export interface UserCreateWithoutDotsInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export type PreferencesWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface CircleUpdateManyWithWhereNestedInput {
  where: CircleScalarWhereInput;
  data: CircleUpdateManyDataInput;
}

export interface UserUpdateOneRequiredWithoutHalosInput {
  create?: Maybe<UserCreateWithoutHalosInput>;
  update?: Maybe<UserUpdateWithoutHalosDataInput>;
  upsert?: Maybe<UserUpsertWithoutHalosInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleUpdateManyDataInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
}

export interface UserCreateWithoutHalosInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface DotUpdateManyWithoutUserInput {
  create?: Maybe<DotCreateWithoutUserInput[] | DotCreateWithoutUserInput>;
  delete?: Maybe<DotWhereUniqueInput[] | DotWhereUniqueInput>;
  connect?: Maybe<DotWhereUniqueInput[] | DotWhereUniqueInput>;
  set?: Maybe<DotWhereUniqueInput[] | DotWhereUniqueInput>;
  disconnect?: Maybe<DotWhereUniqueInput[] | DotWhereUniqueInput>;
  update?: Maybe<
    | DotUpdateWithWhereUniqueWithoutUserInput[]
    | DotUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | DotUpsertWithWhereUniqueWithoutUserInput[]
    | DotUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<DotScalarWhereInput[] | DotScalarWhereInput>;
  updateMany?: Maybe<
    DotUpdateManyWithWhereNestedInput[] | DotUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateOneWithoutHalosInput {
  create?: Maybe<UserCreateWithoutHalosInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface DotUpdateWithWhereUniqueWithoutUserInput {
  where: DotWhereUniqueInput;
  data: DotUpdateWithoutUserDataInput;
}

export interface EventUpdateManyMutationInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
}

export interface DotUpdateWithoutUserDataInput {
  action?: Maybe<String>;
  amount?: Maybe<Int>;
  total?: Maybe<Int>;
}

export interface EventUpdateInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  charity?: Maybe<CharityUpdateOneRequiredWithoutEventsInput>;
  donations?: Maybe<TransferUpdateManyWithoutEventInput>;
}

export interface DotUpsertWithWhereUniqueWithoutUserInput {
  where: DotWhereUniqueInput;
  update: DotUpdateWithoutUserDataInput;
  create: DotCreateWithoutUserInput;
}

export interface UserUpsertWithoutDotsInput {
  update: UserUpdateWithoutDotsDataInput;
  create: UserCreateWithoutDotsInput;
}

export interface DotScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  action?: Maybe<String>;
  action_not?: Maybe<String>;
  action_in?: Maybe<String[] | String>;
  action_not_in?: Maybe<String[] | String>;
  action_lt?: Maybe<String>;
  action_lte?: Maybe<String>;
  action_gt?: Maybe<String>;
  action_gte?: Maybe<String>;
  action_contains?: Maybe<String>;
  action_not_contains?: Maybe<String>;
  action_starts_with?: Maybe<String>;
  action_not_starts_with?: Maybe<String>;
  action_ends_with?: Maybe<String>;
  action_not_ends_with?: Maybe<String>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  total?: Maybe<Int>;
  total_not?: Maybe<Int>;
  total_in?: Maybe<Int[] | Int>;
  total_not_in?: Maybe<Int[] | Int>;
  total_lt?: Maybe<Int>;
  total_lte?: Maybe<Int>;
  total_gt?: Maybe<Int>;
  total_gte?: Maybe<Int>;
  AND?: Maybe<DotScalarWhereInput[] | DotScalarWhereInput>;
  OR?: Maybe<DotScalarWhereInput[] | DotScalarWhereInput>;
  NOT?: Maybe<DotScalarWhereInput[] | DotScalarWhereInput>;
}

export interface UserUpdateWithoutDotsDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface DotUpdateManyWithWhereNestedInput {
  where: DotScalarWhereInput;
  data: DotUpdateManyDataInput;
}

export interface DotUpdateInput {
  action?: Maybe<String>;
  amount?: Maybe<Int>;
  total?: Maybe<Int>;
  user?: Maybe<UserUpdateOneRequiredWithoutDotsInput>;
}

export interface DotUpdateManyDataInput {
  action?: Maybe<String>;
  amount?: Maybe<Int>;
  total?: Maybe<Int>;
}

export interface ChargeCreateInput {
  id?: Maybe<ID_Input>;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
  donations?: Maybe<TransferCreateManyWithoutSourceInput>;
  transaction: TransactionCreateOneWithoutFundsInput;
  user: UserCreateOneWithoutFundsInput;
}

export interface IdentityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  provider?: Maybe<IdentityProvider>;
  provider_not?: Maybe<IdentityProvider>;
  provider_in?: Maybe<IdentityProvider[] | IdentityProvider>;
  provider_not_in?: Maybe<IdentityProvider[] | IdentityProvider>;
  providerID?: Maybe<String>;
  providerID_not?: Maybe<String>;
  providerID_in?: Maybe<String[] | String>;
  providerID_not_in?: Maybe<String[] | String>;
  providerID_lt?: Maybe<String>;
  providerID_lte?: Maybe<String>;
  providerID_gt?: Maybe<String>;
  providerID_gte?: Maybe<String>;
  providerID_contains?: Maybe<String>;
  providerID_not_contains?: Maybe<String>;
  providerID_starts_with?: Maybe<String>;
  providerID_not_starts_with?: Maybe<String>;
  providerID_ends_with?: Maybe<String>;
  providerID_not_ends_with?: Maybe<String>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<IdentityWhereInput[] | IdentityWhereInput>;
  OR?: Maybe<IdentityWhereInput[] | IdentityWhereInput>;
  NOT?: Maybe<IdentityWhereInput[] | IdentityWhereInput>;
}

export interface TransferCreateWithoutSourceInput {
  id?: Maybe<ID_Input>;
  amount: Int;
  chargeBalance: Int;
  firstOfBatch: Boolean;
  transferID: String;
  event?: Maybe<EventCreateOneWithoutDonationsInput>;
  transaction: TransactionCreateOneWithoutDonationsInput;
}

export interface LoopWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  count?: Maybe<Int>;
  count_not?: Maybe<Int>;
  count_in?: Maybe<Int[] | Int>;
  count_not_in?: Maybe<Int[] | Int>;
  count_lt?: Maybe<Int>;
  count_lte?: Maybe<Int>;
  count_gt?: Maybe<Int>;
  count_gte?: Maybe<Int>;
  event?: Maybe<EventWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<LoopWhereInput[] | LoopWhereInput>;
  OR?: Maybe<LoopWhereInput[] | LoopWhereInput>;
  NOT?: Maybe<LoopWhereInput[] | LoopWhereInput>;
}

export interface EventCreateWithoutDonationsInput {
  id?: Maybe<ID_Input>;
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate: DateTimeInput;
  charity: CharityCreateOneWithoutEventsInput;
}

export interface ChargeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  amountAdded?: Maybe<Int>;
  amountAdded_not?: Maybe<Int>;
  amountAdded_in?: Maybe<Int[] | Int>;
  amountAdded_not_in?: Maybe<Int[] | Int>;
  amountAdded_lt?: Maybe<Int>;
  amountAdded_lte?: Maybe<Int>;
  amountAdded_gt?: Maybe<Int>;
  amountAdded_gte?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  amountNet_not?: Maybe<Int>;
  amountNet_in?: Maybe<Int[] | Int>;
  amountNet_not_in?: Maybe<Int[] | Int>;
  amountNet_lt?: Maybe<Int>;
  amountNet_lte?: Maybe<Int>;
  amountNet_gt?: Maybe<Int>;
  amountNet_gte?: Maybe<Int>;
  chargeID?: Maybe<String>;
  chargeID_not?: Maybe<String>;
  chargeID_in?: Maybe<String[] | String>;
  chargeID_not_in?: Maybe<String[] | String>;
  chargeID_lt?: Maybe<String>;
  chargeID_lte?: Maybe<String>;
  chargeID_gt?: Maybe<String>;
  chargeID_gte?: Maybe<String>;
  chargeID_contains?: Maybe<String>;
  chargeID_not_contains?: Maybe<String>;
  chargeID_starts_with?: Maybe<String>;
  chargeID_not_starts_with?: Maybe<String>;
  chargeID_ends_with?: Maybe<String>;
  chargeID_not_ends_with?: Maybe<String>;
  donations_every?: Maybe<TransferWhereInput>;
  donations_some?: Maybe<TransferWhereInput>;
  donations_none?: Maybe<TransferWhereInput>;
  transaction?: Maybe<TransactionWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<ChargeWhereInput[] | ChargeWhereInput>;
  OR?: Maybe<ChargeWhereInput[] | ChargeWhereInput>;
  NOT?: Maybe<ChargeWhereInput[] | ChargeWhereInput>;
}

export interface CharityCreateWithoutEventsInput {
  id?: Maybe<ID_Input>;
  acronym?: Maybe<String>;
  banner?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein: String;
  email: String;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  mission?: Maybe<String>;
  name: String;
  phoneNumber?: Maybe<String>;
  representative: String;
  verified?: Maybe<Boolean>;
  website: String;
  authHistory?: Maybe<CharityAuthHistoryCreateManyWithoutCharityInput>;
  followers?: Maybe<UserCreateManyWithoutFollowedCharitiesInput>;
}

export interface UserCreateOneWithoutDotsInput {
  create?: Maybe<UserCreateWithoutDotsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CharityAuthHistoryCreateWithoutCharityInput {
  id?: Maybe<ID_Input>;
}

export interface EventUpdateWithWhereUniqueWithoutCharityInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutCharityDataInput;
}

export interface UserCreateWithoutFollowedCharitiesInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface EventUpdateWithoutCharityDataInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  donations?: Maybe<TransferUpdateManyWithoutEventInput>;
}

export interface CircleJoinRequestCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  circle: CircleCreateOneWithoutJoinRequestsInput;
}

export interface TransferUpdateManyWithoutEventInput {
  create?: Maybe<
    TransferCreateWithoutEventInput[] | TransferCreateWithoutEventInput
  >;
  delete?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  connect?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  set?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  disconnect?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  update?: Maybe<
    | TransferUpdateWithWhereUniqueWithoutEventInput[]
    | TransferUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | TransferUpsertWithWhereUniqueWithoutEventInput[]
    | TransferUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<TransferScalarWhereInput[] | TransferScalarWhereInput>;
  updateMany?: Maybe<
    | TransferUpdateManyWithWhereNestedInput[]
    | TransferUpdateManyWithWhereNestedInput
  >;
}

export interface CircleCreateWithoutJoinRequestsInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  name: String;
  open?: Maybe<Boolean>;
  invites?: Maybe<CircleInviteCreateManyWithoutCircleInput>;
  members?: Maybe<UserCreateManyWithoutCirclesInput>;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface TransferUpdateWithWhereUniqueWithoutEventInput {
  where: TransferWhereUniqueInput;
  data: TransferUpdateWithoutEventDataInput;
}

export interface CircleInviteCreateWithoutCircleInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutCircleInvitesInput;
}

export interface TransferUpdateWithoutEventDataInput {
  amount?: Maybe<Int>;
  chargeBalance?: Maybe<Int>;
  firstOfBatch?: Maybe<Boolean>;
  transferID?: Maybe<String>;
  source?: Maybe<ChargeUpdateOneWithoutDonationsInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutDonationsInput>;
}

export interface UserCreateWithoutCircleInvitesInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface ChargeUpdateOneWithoutDonationsInput {
  create?: Maybe<ChargeCreateWithoutDonationsInput>;
  update?: Maybe<ChargeUpdateWithoutDonationsDataInput>;
  upsert?: Maybe<ChargeUpsertWithoutDonationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ChargeWhereUniqueInput>;
}

export interface CircleCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  name: String;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestCreateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteCreateManyWithoutCircleInput>;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface ChargeUpdateWithoutDonationsDataInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutFundsInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutFundsInput>;
}

export interface CircleJoinRequestCreateWithoutCircleInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutCircleJoinRequestsInput;
}

export interface TransactionUpdateOneRequiredWithoutFundsInput {
  create?: Maybe<TransactionCreateWithoutFundsInput>;
  update?: Maybe<TransactionUpdateWithoutFundsDataInput>;
  upsert?: Maybe<TransactionUpsertWithoutFundsInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface UserCreateWithoutCircleJoinRequestsInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface TransactionUpdateWithoutFundsDataInput {
  balance?: Maybe<Int>;
  donations?: Maybe<TransferUpdateManyWithoutTransactionInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
}

export interface CircleInviteCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  circle: CircleCreateOneWithoutInvitesInput;
}

export interface TransferUpdateManyWithoutTransactionInput {
  create?: Maybe<
    | TransferCreateWithoutTransactionInput[]
    | TransferCreateWithoutTransactionInput
  >;
  delete?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  connect?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  set?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  disconnect?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  update?: Maybe<
    | TransferUpdateWithWhereUniqueWithoutTransactionInput[]
    | TransferUpdateWithWhereUniqueWithoutTransactionInput
  >;
  upsert?: Maybe<
    | TransferUpsertWithWhereUniqueWithoutTransactionInput[]
    | TransferUpsertWithWhereUniqueWithoutTransactionInput
  >;
  deleteMany?: Maybe<TransferScalarWhereInput[] | TransferScalarWhereInput>;
  updateMany?: Maybe<
    | TransferUpdateManyWithWhereNestedInput[]
    | TransferUpdateManyWithWhereNestedInput
  >;
}

export interface CircleCreateWithoutInvitesInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  name: String;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestCreateManyWithoutCircleInput>;
  members?: Maybe<UserCreateManyWithoutCirclesInput>;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface TransferUpdateWithWhereUniqueWithoutTransactionInput {
  where: TransferWhereUniqueInput;
  data: TransferUpdateWithoutTransactionDataInput;
}

export interface UserCreateWithoutCirclesInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface TransferUpdateWithoutTransactionDataInput {
  amount?: Maybe<Int>;
  chargeBalance?: Maybe<Int>;
  firstOfBatch?: Maybe<Boolean>;
  transferID?: Maybe<String>;
  event?: Maybe<EventUpdateOneWithoutDonationsInput>;
  source?: Maybe<ChargeUpdateOneWithoutDonationsInput>;
}

export interface CircleCreateWithoutOwnerInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  name: String;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestCreateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteCreateManyWithoutCircleInput>;
  members?: Maybe<UserCreateManyWithoutCirclesInput>;
}

export interface TransferUpsertWithWhereUniqueWithoutTransactionInput {
  where: TransferWhereUniqueInput;
  update: TransferUpdateWithoutTransactionDataInput;
  create: TransferCreateWithoutTransactionInput;
}

export interface DotCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  action: String;
  amount: Int;
  total: Int;
}

export interface TransferScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  chargeBalance?: Maybe<Int>;
  chargeBalance_not?: Maybe<Int>;
  chargeBalance_in?: Maybe<Int[] | Int>;
  chargeBalance_not_in?: Maybe<Int[] | Int>;
  chargeBalance_lt?: Maybe<Int>;
  chargeBalance_lte?: Maybe<Int>;
  chargeBalance_gt?: Maybe<Int>;
  chargeBalance_gte?: Maybe<Int>;
  firstOfBatch?: Maybe<Boolean>;
  firstOfBatch_not?: Maybe<Boolean>;
  transferID?: Maybe<String>;
  transferID_not?: Maybe<String>;
  transferID_in?: Maybe<String[] | String>;
  transferID_not_in?: Maybe<String[] | String>;
  transferID_lt?: Maybe<String>;
  transferID_lte?: Maybe<String>;
  transferID_gt?: Maybe<String>;
  transferID_gte?: Maybe<String>;
  transferID_contains?: Maybe<String>;
  transferID_not_contains?: Maybe<String>;
  transferID_starts_with?: Maybe<String>;
  transferID_not_starts_with?: Maybe<String>;
  transferID_ends_with?: Maybe<String>;
  transferID_not_ends_with?: Maybe<String>;
  AND?: Maybe<TransferScalarWhereInput[] | TransferScalarWhereInput>;
  OR?: Maybe<TransferScalarWhereInput[] | TransferScalarWhereInput>;
  NOT?: Maybe<TransferScalarWhereInput[] | TransferScalarWhereInput>;
}

export interface CharityCreateWithoutFollowersInput {
  id?: Maybe<ID_Input>;
  acronym?: Maybe<String>;
  banner?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein: String;
  email: String;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  mission?: Maybe<String>;
  name: String;
  phoneNumber?: Maybe<String>;
  representative: String;
  verified?: Maybe<Boolean>;
  website: String;
  authHistory?: Maybe<CharityAuthHistoryCreateManyWithoutCharityInput>;
  events?: Maybe<EventCreateManyWithoutCharityInput>;
}

export interface TransferUpdateManyWithWhereNestedInput {
  where: TransferScalarWhereInput;
  data: TransferUpdateManyDataInput;
}

export interface EventCreateWithoutCharityInput {
  id?: Maybe<ID_Input>;
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate: DateTimeInput;
  donations?: Maybe<TransferCreateManyWithoutEventInput>;
}

export interface TransferUpdateManyDataInput {
  amount?: Maybe<Int>;
  chargeBalance?: Maybe<Int>;
  firstOfBatch?: Maybe<Boolean>;
  transferID?: Maybe<String>;
}

export interface TransferCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  amount: Int;
  chargeBalance: Int;
  firstOfBatch: Boolean;
  transferID: String;
  source?: Maybe<ChargeCreateOneWithoutDonationsInput>;
  transaction: TransactionCreateOneWithoutDonationsInput;
}

export interface UserUpdateOneRequiredWithoutTransactionsInput {
  create?: Maybe<UserCreateWithoutTransactionsInput>;
  update?: Maybe<UserUpdateWithoutTransactionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutTransactionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ChargeCreateWithoutDonationsInput {
  id?: Maybe<ID_Input>;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
  transaction: TransactionCreateOneWithoutFundsInput;
  user: UserCreateOneWithoutFundsInput;
}

export interface UserUpdateWithoutTransactionsDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
}

export interface TransactionCreateWithoutFundsInput {
  id?: Maybe<ID_Input>;
  balance: Int;
  donations?: Maybe<TransferCreateManyWithoutTransactionInput>;
  user: UserCreateOneWithoutTransactionsInput;
}

export interface ChargeUpdateManyWithoutUserInput {
  create?: Maybe<ChargeCreateWithoutUserInput[] | ChargeCreateWithoutUserInput>;
  delete?: Maybe<ChargeWhereUniqueInput[] | ChargeWhereUniqueInput>;
  connect?: Maybe<ChargeWhereUniqueInput[] | ChargeWhereUniqueInput>;
  set?: Maybe<ChargeWhereUniqueInput[] | ChargeWhereUniqueInput>;
  disconnect?: Maybe<ChargeWhereUniqueInput[] | ChargeWhereUniqueInput>;
  update?: Maybe<
    | ChargeUpdateWithWhereUniqueWithoutUserInput[]
    | ChargeUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ChargeUpsertWithWhereUniqueWithoutUserInput[]
    | ChargeUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<ChargeScalarWhereInput[] | ChargeScalarWhereInput>;
  updateMany?: Maybe<
    | ChargeUpdateManyWithWhereNestedInput[]
    | ChargeUpdateManyWithWhereNestedInput
  >;
}

export interface TransferCreateWithoutTransactionInput {
  id?: Maybe<ID_Input>;
  amount: Int;
  chargeBalance: Int;
  firstOfBatch: Boolean;
  transferID: String;
  event?: Maybe<EventCreateOneWithoutDonationsInput>;
  source?: Maybe<ChargeCreateOneWithoutDonationsInput>;
}

export interface ChargeUpdateWithWhereUniqueWithoutUserInput {
  where: ChargeWhereUniqueInput;
  data: ChargeUpdateWithoutUserDataInput;
}

export interface UserCreateWithoutTransactionsInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
}

export interface ChargeUpdateWithoutUserDataInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
  donations?: Maybe<TransferUpdateManyWithoutSourceInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutFundsInput>;
}

export interface ChargeCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
  donations?: Maybe<TransferCreateManyWithoutSourceInput>;
  transaction: TransactionCreateOneWithoutFundsInput;
}

export interface ChargeUpsertWithWhereUniqueWithoutUserInput {
  where: ChargeWhereUniqueInput;
  update: ChargeUpdateWithoutUserDataInput;
  create: ChargeCreateWithoutUserInput;
}

export interface HaloCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  key: String;
  tier?: Maybe<String>;
}

export interface ChargeScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  amountAdded?: Maybe<Int>;
  amountAdded_not?: Maybe<Int>;
  amountAdded_in?: Maybe<Int[] | Int>;
  amountAdded_not_in?: Maybe<Int[] | Int>;
  amountAdded_lt?: Maybe<Int>;
  amountAdded_lte?: Maybe<Int>;
  amountAdded_gt?: Maybe<Int>;
  amountAdded_gte?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  amountNet_not?: Maybe<Int>;
  amountNet_in?: Maybe<Int[] | Int>;
  amountNet_not_in?: Maybe<Int[] | Int>;
  amountNet_lt?: Maybe<Int>;
  amountNet_lte?: Maybe<Int>;
  amountNet_gt?: Maybe<Int>;
  amountNet_gte?: Maybe<Int>;
  chargeID?: Maybe<String>;
  chargeID_not?: Maybe<String>;
  chargeID_in?: Maybe<String[] | String>;
  chargeID_not_in?: Maybe<String[] | String>;
  chargeID_lt?: Maybe<String>;
  chargeID_lte?: Maybe<String>;
  chargeID_gt?: Maybe<String>;
  chargeID_gte?: Maybe<String>;
  chargeID_contains?: Maybe<String>;
  chargeID_not_contains?: Maybe<String>;
  chargeID_starts_with?: Maybe<String>;
  chargeID_not_starts_with?: Maybe<String>;
  chargeID_ends_with?: Maybe<String>;
  chargeID_not_ends_with?: Maybe<String>;
  AND?: Maybe<ChargeScalarWhereInput[] | ChargeScalarWhereInput>;
  OR?: Maybe<ChargeScalarWhereInput[] | ChargeScalarWhereInput>;
  NOT?: Maybe<ChargeScalarWhereInput[] | ChargeScalarWhereInput>;
}

export interface IdentityCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  provider: IdentityProvider;
  providerID: String;
}

export interface ChargeUpdateManyWithWhereNestedInput {
  where: ChargeScalarWhereInput;
  data: ChargeUpdateManyDataInput;
}

export interface LoopCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  count: Int;
  event: EventCreateOneInput;
}

export interface ChargeUpdateManyDataInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
}

export interface EventCreateInput {
  id?: Maybe<ID_Input>;
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate: DateTimeInput;
  charity: CharityCreateOneWithoutEventsInput;
  donations?: Maybe<TransferCreateManyWithoutEventInput>;
}

export interface HaloUpdateManyWithoutUserInput {
  create?: Maybe<HaloCreateWithoutUserInput[] | HaloCreateWithoutUserInput>;
  delete?: Maybe<HaloWhereUniqueInput[] | HaloWhereUniqueInput>;
  connect?: Maybe<HaloWhereUniqueInput[] | HaloWhereUniqueInput>;
  set?: Maybe<HaloWhereUniqueInput[] | HaloWhereUniqueInput>;
  disconnect?: Maybe<HaloWhereUniqueInput[] | HaloWhereUniqueInput>;
  update?: Maybe<
    | HaloUpdateWithWhereUniqueWithoutUserInput[]
    | HaloUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | HaloUpsertWithWhereUniqueWithoutUserInput[]
    | HaloUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<HaloScalarWhereInput[] | HaloScalarWhereInput>;
  updateMany?: Maybe<
    HaloUpdateManyWithWhereNestedInput[] | HaloUpdateManyWithWhereNestedInput
  >;
}

export interface PreferencesCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  allowDonationEmails?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
}

export interface HaloUpdateWithWhereUniqueWithoutUserInput {
  where: HaloWhereUniqueInput;
  data: HaloUpdateWithoutUserDataInput;
}

export interface UserCreateWithoutFundsInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface HaloUpdateWithoutUserDataInput {
  key?: Maybe<String>;
  tier?: Maybe<String>;
}

export interface TransactionCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  balance: Int;
  donations?: Maybe<TransferCreateManyWithoutTransactionInput>;
  funds?: Maybe<ChargeCreateOneWithoutTransactionInput>;
}

export interface HaloUpsertWithWhereUniqueWithoutUserInput {
  where: HaloWhereUniqueInput;
  update: HaloUpdateWithoutUserDataInput;
  create: HaloCreateWithoutUserInput;
}

export interface ChargeCreateWithoutTransactionInput {
  id?: Maybe<ID_Input>;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
  donations?: Maybe<TransferCreateManyWithoutSourceInput>;
  user: UserCreateOneWithoutFundsInput;
}

export interface HaloScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  tier?: Maybe<String>;
  tier_not?: Maybe<String>;
  tier_in?: Maybe<String[] | String>;
  tier_not_in?: Maybe<String[] | String>;
  tier_lt?: Maybe<String>;
  tier_lte?: Maybe<String>;
  tier_gt?: Maybe<String>;
  tier_gte?: Maybe<String>;
  tier_contains?: Maybe<String>;
  tier_not_contains?: Maybe<String>;
  tier_starts_with?: Maybe<String>;
  tier_not_starts_with?: Maybe<String>;
  tier_ends_with?: Maybe<String>;
  tier_not_ends_with?: Maybe<String>;
  AND?: Maybe<HaloScalarWhereInput[] | HaloScalarWhereInput>;
  OR?: Maybe<HaloScalarWhereInput[] | HaloScalarWhereInput>;
  NOT?: Maybe<HaloScalarWhereInput[] | HaloScalarWhereInput>;
}

export interface TransactionCreateWithoutDonationsInput {
  id?: Maybe<ID_Input>;
  balance: Int;
  funds?: Maybe<ChargeCreateOneWithoutTransactionInput>;
  user: UserCreateOneWithoutTransactionsInput;
}

export interface HaloUpdateManyWithWhereNestedInput {
  where: HaloScalarWhereInput;
  data: HaloUpdateManyDataInput;
}

export interface UserCreateWithoutCirclesOwnedInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface HaloUpdateManyDataInput {
  key?: Maybe<String>;
  tier?: Maybe<String>;
}

export interface TransferUpdateManyWithoutSourceInput {
  create?: Maybe<
    TransferCreateWithoutSourceInput[] | TransferCreateWithoutSourceInput
  >;
  delete?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  connect?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  set?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  disconnect?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
  update?: Maybe<
    | TransferUpdateWithWhereUniqueWithoutSourceInput[]
    | TransferUpdateWithWhereUniqueWithoutSourceInput
  >;
  upsert?: Maybe<
    | TransferUpsertWithWhereUniqueWithoutSourceInput[]
    | TransferUpsertWithWhereUniqueWithoutSourceInput
  >;
  deleteMany?: Maybe<TransferScalarWhereInput[] | TransferScalarWhereInput>;
  updateMany?: Maybe<
    | TransferUpdateManyWithWhereNestedInput[]
    | TransferUpdateManyWithWhereNestedInput
  >;
}

export interface IdentityUpdateOneRequiredWithoutUserInput {
  create?: Maybe<IdentityCreateWithoutUserInput>;
  update?: Maybe<IdentityUpdateWithoutUserDataInput>;
  upsert?: Maybe<IdentityUpsertWithoutUserInput>;
  connect?: Maybe<IdentityWhereUniqueInput>;
}

export interface TransferUpdateWithoutSourceDataInput {
  amount?: Maybe<Int>;
  chargeBalance?: Maybe<Int>;
  firstOfBatch?: Maybe<Boolean>;
  transferID?: Maybe<String>;
  event?: Maybe<EventUpdateOneWithoutDonationsInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutDonationsInput>;
}

export interface IdentityUpdateWithoutUserDataInput {
  provider?: Maybe<IdentityProvider>;
  providerID?: Maybe<String>;
}

export interface EventUpdateWithoutDonationsDataInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  charity?: Maybe<CharityUpdateOneRequiredWithoutEventsInput>;
}

export interface IdentityUpsertWithoutUserInput {
  update: IdentityUpdateWithoutUserDataInput;
  create: IdentityCreateWithoutUserInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface LoopUpdateManyWithoutUserInput {
  create?: Maybe<LoopCreateWithoutUserInput[] | LoopCreateWithoutUserInput>;
  delete?: Maybe<LoopWhereUniqueInput[] | LoopWhereUniqueInput>;
  connect?: Maybe<LoopWhereUniqueInput[] | LoopWhereUniqueInput>;
  set?: Maybe<LoopWhereUniqueInput[] | LoopWhereUniqueInput>;
  disconnect?: Maybe<LoopWhereUniqueInput[] | LoopWhereUniqueInput>;
  update?: Maybe<
    | LoopUpdateWithWhereUniqueWithoutUserInput[]
    | LoopUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | LoopUpsertWithWhereUniqueWithoutUserInput[]
    | LoopUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<LoopScalarWhereInput[] | LoopScalarWhereInput>;
  updateMany?: Maybe<
    LoopUpdateManyWithWhereNestedInput[] | LoopUpdateManyWithWhereNestedInput
  >;
}

export interface CircleWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  open?: Maybe<Boolean>;
  open_not?: Maybe<Boolean>;
  joinRequests_every?: Maybe<CircleJoinRequestWhereInput>;
  joinRequests_some?: Maybe<CircleJoinRequestWhereInput>;
  joinRequests_none?: Maybe<CircleJoinRequestWhereInput>;
  invites_every?: Maybe<CircleInviteWhereInput>;
  invites_some?: Maybe<CircleInviteWhereInput>;
  invites_none?: Maybe<CircleInviteWhereInput>;
  members_every?: Maybe<UserWhereInput>;
  members_some?: Maybe<UserWhereInput>;
  members_none?: Maybe<UserWhereInput>;
  owner?: Maybe<UserWhereInput>;
  AND?: Maybe<CircleWhereInput[] | CircleWhereInput>;
  OR?: Maybe<CircleWhereInput[] | CircleWhereInput>;
  NOT?: Maybe<CircleWhereInput[] | CircleWhereInput>;
}

export interface LoopUpdateWithWhereUniqueWithoutUserInput {
  where: LoopWhereUniqueInput;
  data: LoopUpdateWithoutUserDataInput;
}

export interface LoopSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<LoopWhereInput>;
  AND?: Maybe<LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput>;
  OR?: Maybe<LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput>;
  NOT?: Maybe<LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput>;
}

export interface LoopUpdateWithoutUserDataInput {
  count?: Maybe<Int>;
  event?: Maybe<EventUpdateOneRequiredInput>;
}

export interface HaloSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<HaloWhereInput>;
  AND?: Maybe<HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput>;
  OR?: Maybe<HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput>;
  NOT?: Maybe<HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput>;
}

export interface EventUpdateOneRequiredInput {
  create?: Maybe<EventCreateInput>;
  update?: Maybe<EventUpdateDataInput>;
  upsert?: Maybe<EventUpsertNestedInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface DotSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<DotWhereInput>;
  AND?: Maybe<DotSubscriptionWhereInput[] | DotSubscriptionWhereInput>;
  OR?: Maybe<DotSubscriptionWhereInput[] | DotSubscriptionWhereInput>;
  NOT?: Maybe<DotSubscriptionWhereInput[] | DotSubscriptionWhereInput>;
}

export interface EventUpdateDataInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  charity?: Maybe<CharityUpdateOneRequiredWithoutEventsInput>;
  donations?: Maybe<TransferUpdateManyWithoutEventInput>;
}

export interface CircleSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CircleWhereInput>;
  AND?: Maybe<CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput>;
  OR?: Maybe<CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput>;
  NOT?: Maybe<CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput>;
}

export interface EventUpsertNestedInput {
  update: EventUpdateDataInput;
  create: EventCreateInput;
}

export interface UserUpdateManyMutationInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
}

export interface LoopUpsertWithWhereUniqueWithoutUserInput {
  where: LoopWhereUniqueInput;
  update: LoopUpdateWithoutUserDataInput;
  create: LoopCreateWithoutUserInput;
}

export type CharityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  ein?: Maybe<String>;
  email?: Maybe<String>;
}>;

export interface LoopScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  count?: Maybe<Int>;
  count_not?: Maybe<Int>;
  count_in?: Maybe<Int[] | Int>;
  count_not_in?: Maybe<Int[] | Int>;
  count_lt?: Maybe<Int>;
  count_lte?: Maybe<Int>;
  count_gt?: Maybe<Int>;
  count_gte?: Maybe<Int>;
  AND?: Maybe<LoopScalarWhereInput[] | LoopScalarWhereInput>;
  OR?: Maybe<LoopScalarWhereInput[] | LoopScalarWhereInput>;
  NOT?: Maybe<LoopScalarWhereInput[] | LoopScalarWhereInput>;
}

export type CharityAuthHistoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface LoopUpdateManyWithWhereNestedInput {
  where: LoopScalarWhereInput;
  data: LoopUpdateManyDataInput;
}

export type CircleWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface LoopUpdateManyDataInput {
  count?: Maybe<Int>;
}

export type CircleInviteWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PreferencesUpdateOneRequiredWithoutUserInput {
  create?: Maybe<PreferencesCreateWithoutUserInput>;
  update?: Maybe<PreferencesUpdateWithoutUserDataInput>;
  upsert?: Maybe<PreferencesUpsertWithoutUserInput>;
  connect?: Maybe<PreferencesWhereUniqueInput>;
}

export type CircleJoinRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PreferencesUpdateWithoutUserDataInput {
  allowDonationEmails?: Maybe<Boolean>;
  publicProfile?: Maybe<Boolean>;
}

export type DotWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PreferencesUpsertWithoutUserInput {
  update: PreferencesUpdateWithoutUserDataInput;
  create: PreferencesCreateWithoutUserInput;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput;
  create: UserCreateWithoutTransactionsInput;
}

export type HaloWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TransactionUpsertWithoutFundsInput {
  update: TransactionUpdateWithoutFundsDataInput;
  create: TransactionCreateWithoutFundsInput;
}

export type IdentityWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  providerID?: Maybe<String>;
}>;

export interface UserUpdateOneRequiredWithoutFundsInput {
  create?: Maybe<UserCreateWithoutFundsInput>;
  update?: Maybe<UserUpdateWithoutFundsDataInput>;
  upsert?: Maybe<UserUpsertWithoutFundsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateOneWithoutIdentityInput {
  create?: Maybe<UserCreateWithoutIdentityInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutFundsDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutHalosInput {
  update: UserUpdateWithoutHalosDataInput;
  create: UserCreateWithoutHalosInput;
}

export interface TransactionUpdateManyWithoutUserInput {
  create?: Maybe<
    TransactionCreateWithoutUserInput[] | TransactionCreateWithoutUserInput
  >;
  delete?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  set?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  disconnect?: Maybe<
    TransactionWhereUniqueInput[] | TransactionWhereUniqueInput
  >;
  update?: Maybe<
    | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    | TransactionUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    | TransactionUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    TransactionScalarWhereInput[] | TransactionScalarWhereInput
  >;
  updateMany?: Maybe<
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput
  >;
}

export interface HaloUpdateInput {
  key?: Maybe<String>;
  tier?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutHalosInput>;
}

export interface TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutUserDataInput;
}

export interface HaloCreateInput {
  id?: Maybe<ID_Input>;
  key: String;
  tier?: Maybe<String>;
  user: UserCreateOneWithoutHalosInput;
}

export interface TransactionUpdateWithoutUserDataInput {
  balance?: Maybe<Int>;
  donations?: Maybe<TransferUpdateManyWithoutTransactionInput>;
  funds?: Maybe<ChargeUpdateOneWithoutTransactionInput>;
}

export interface DotUpdateManyMutationInput {
  action?: Maybe<String>;
  amount?: Maybe<Int>;
  total?: Maybe<Int>;
}

export interface ChargeUpdateOneWithoutTransactionInput {
  create?: Maybe<ChargeCreateWithoutTransactionInput>;
  update?: Maybe<ChargeUpdateWithoutTransactionDataInput>;
  upsert?: Maybe<ChargeUpsertWithoutTransactionInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ChargeWhereUniqueInput>;
}

export interface UserUpdateOneRequiredWithoutDotsInput {
  create?: Maybe<UserCreateWithoutDotsInput>;
  update?: Maybe<UserUpdateWithoutDotsDataInput>;
  upsert?: Maybe<UserUpsertWithoutDotsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ChargeUpdateWithoutTransactionDataInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
  donations?: Maybe<TransferUpdateManyWithoutSourceInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutFundsInput>;
}

export interface TransferCreateManyWithoutSourceInput {
  create?: Maybe<
    TransferCreateWithoutSourceInput[] | TransferCreateWithoutSourceInput
  >;
  connect?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
}

export interface ChargeUpsertWithoutTransactionInput {
  update: ChargeUpdateWithoutTransactionDataInput;
  create: ChargeCreateWithoutTransactionInput;
}

export interface CharityCreateOneWithoutEventsInput {
  create?: Maybe<CharityCreateWithoutEventsInput>;
  connect?: Maybe<CharityWhereUniqueInput>;
}

export interface TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutUserDataInput;
  create: TransactionCreateWithoutUserInput;
}

export interface UserCreateManyWithoutFollowedCharitiesInput {
  create?: Maybe<
    | UserCreateWithoutFollowedCharitiesInput[]
    | UserCreateWithoutFollowedCharitiesInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface TransactionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  balance?: Maybe<Int>;
  balance_not?: Maybe<Int>;
  balance_in?: Maybe<Int[] | Int>;
  balance_not_in?: Maybe<Int[] | Int>;
  balance_lt?: Maybe<Int>;
  balance_lte?: Maybe<Int>;
  balance_gt?: Maybe<Int>;
  balance_gte?: Maybe<Int>;
  AND?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  OR?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  NOT?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
}

export interface CircleCreateOneWithoutJoinRequestsInput {
  create?: Maybe<CircleCreateWithoutJoinRequestsInput>;
  connect?: Maybe<CircleWhereUniqueInput>;
}

export interface TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput;
  data: TransactionUpdateManyDataInput;
}

export interface UserCreateOneWithoutCircleInvitesInput {
  create?: Maybe<UserCreateWithoutCircleInvitesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TransactionUpdateManyDataInput {
  balance?: Maybe<Int>;
}

export interface CircleJoinRequestCreateManyWithoutCircleInput {
  create?: Maybe<
    | CircleJoinRequestCreateWithoutCircleInput[]
    | CircleJoinRequestCreateWithoutCircleInput
  >;
  connect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
}

export interface UserUpsertWithoutFundsInput {
  update: UserUpdateWithoutFundsDataInput;
  create: UserCreateWithoutFundsInput;
}

export interface CircleInviteCreateManyWithoutUserInput {
  create?: Maybe<
    CircleInviteCreateWithoutUserInput[] | CircleInviteCreateWithoutUserInput
  >;
  connect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
}

export interface ChargeUpsertWithoutDonationsInput {
  update: ChargeUpdateWithoutDonationsDataInput;
  create: ChargeCreateWithoutDonationsInput;
}

export interface UserCreateManyWithoutCirclesInput {
  create?: Maybe<
    UserCreateWithoutCirclesInput[] | UserCreateWithoutCirclesInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface TransactionUpdateOneRequiredWithoutDonationsInput {
  create?: Maybe<TransactionCreateWithoutDonationsInput>;
  update?: Maybe<TransactionUpdateWithoutDonationsDataInput>;
  upsert?: Maybe<TransactionUpsertWithoutDonationsInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface DotCreateManyWithoutUserInput {
  create?: Maybe<DotCreateWithoutUserInput[] | DotCreateWithoutUserInput>;
  connect?: Maybe<DotWhereUniqueInput[] | DotWhereUniqueInput>;
}

export interface TransactionUpdateWithoutDonationsDataInput {
  balance?: Maybe<Int>;
  funds?: Maybe<ChargeUpdateOneWithoutTransactionInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
}

export interface EventCreateManyWithoutCharityInput {
  create?: Maybe<
    EventCreateWithoutCharityInput[] | EventCreateWithoutCharityInput
  >;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface TransactionUpsertWithoutDonationsInput {
  update: TransactionUpdateWithoutDonationsDataInput;
  create: TransactionCreateWithoutDonationsInput;
}

export interface ChargeCreateOneWithoutDonationsInput {
  create?: Maybe<ChargeCreateWithoutDonationsInput>;
  connect?: Maybe<ChargeWhereUniqueInput>;
}

export interface TransferUpsertWithWhereUniqueWithoutEventInput {
  where: TransferWhereUniqueInput;
  update: TransferUpdateWithoutEventDataInput;
  create: TransferCreateWithoutEventInput;
}

export interface TransferCreateManyWithoutTransactionInput {
  create?: Maybe<
    | TransferCreateWithoutTransactionInput[]
    | TransferCreateWithoutTransactionInput
  >;
  connect?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
}

export interface EventUpsertWithWhereUniqueWithoutCharityInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutCharityDataInput;
  create: EventCreateWithoutCharityInput;
}

export interface ChargeCreateManyWithoutUserInput {
  create?: Maybe<ChargeCreateWithoutUserInput[] | ChargeCreateWithoutUserInput>;
  connect?: Maybe<ChargeWhereUniqueInput[] | ChargeWhereUniqueInput>;
}

export interface EventScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  endDate?: Maybe<DateTimeInput>;
  endDate_not?: Maybe<DateTimeInput>;
  endDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  endDate_lt?: Maybe<DateTimeInput>;
  endDate_lte?: Maybe<DateTimeInput>;
  endDate_gt?: Maybe<DateTimeInput>;
  endDate_gte?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  goal_not?: Maybe<Int>;
  goal_in?: Maybe<Int[] | Int>;
  goal_not_in?: Maybe<Int[] | Int>;
  goal_lt?: Maybe<Int>;
  goal_lte?: Maybe<Int>;
  goal_gt?: Maybe<Int>;
  goal_gte?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  multiplier_not?: Maybe<Int>;
  multiplier_in?: Maybe<Int[] | Int>;
  multiplier_not_in?: Maybe<Int[] | Int>;
  multiplier_lt?: Maybe<Int>;
  multiplier_lte?: Maybe<Int>;
  multiplier_gt?: Maybe<Int>;
  multiplier_gte?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEvent_not?: Maybe<String>;
  specialEvent_in?: Maybe<String[] | String>;
  specialEvent_not_in?: Maybe<String[] | String>;
  specialEvent_lt?: Maybe<String>;
  specialEvent_lte?: Maybe<String>;
  specialEvent_gt?: Maybe<String>;
  specialEvent_gte?: Maybe<String>;
  specialEvent_contains?: Maybe<String>;
  specialEvent_not_contains?: Maybe<String>;
  specialEvent_starts_with?: Maybe<String>;
  specialEvent_not_starts_with?: Maybe<String>;
  specialEvent_ends_with?: Maybe<String>;
  specialEvent_not_ends_with?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventDescription_not?: Maybe<String>;
  specialEventDescription_in?: Maybe<String[] | String>;
  specialEventDescription_not_in?: Maybe<String[] | String>;
  specialEventDescription_lt?: Maybe<String>;
  specialEventDescription_lte?: Maybe<String>;
  specialEventDescription_gt?: Maybe<String>;
  specialEventDescription_gte?: Maybe<String>;
  specialEventDescription_contains?: Maybe<String>;
  specialEventDescription_not_contains?: Maybe<String>;
  specialEventDescription_starts_with?: Maybe<String>;
  specialEventDescription_not_starts_with?: Maybe<String>;
  specialEventDescription_ends_with?: Maybe<String>;
  specialEventDescription_not_ends_with?: Maybe<String>;
  specialEventName?: Maybe<String>;
  specialEventName_not?: Maybe<String>;
  specialEventName_in?: Maybe<String[] | String>;
  specialEventName_not_in?: Maybe<String[] | String>;
  specialEventName_lt?: Maybe<String>;
  specialEventName_lte?: Maybe<String>;
  specialEventName_gt?: Maybe<String>;
  specialEventName_gte?: Maybe<String>;
  specialEventName_contains?: Maybe<String>;
  specialEventName_not_contains?: Maybe<String>;
  specialEventName_starts_with?: Maybe<String>;
  specialEventName_not_starts_with?: Maybe<String>;
  specialEventName_ends_with?: Maybe<String>;
  specialEventName_not_ends_with?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorName_not?: Maybe<String>;
  sponsorName_in?: Maybe<String[] | String>;
  sponsorName_not_in?: Maybe<String[] | String>;
  sponsorName_lt?: Maybe<String>;
  sponsorName_lte?: Maybe<String>;
  sponsorName_gt?: Maybe<String>;
  sponsorName_gte?: Maybe<String>;
  sponsorName_contains?: Maybe<String>;
  sponsorName_not_contains?: Maybe<String>;
  sponsorName_starts_with?: Maybe<String>;
  sponsorName_not_starts_with?: Maybe<String>;
  sponsorName_ends_with?: Maybe<String>;
  sponsorName_not_ends_with?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  sponsorWebsite_not?: Maybe<String>;
  sponsorWebsite_in?: Maybe<String[] | String>;
  sponsorWebsite_not_in?: Maybe<String[] | String>;
  sponsorWebsite_lt?: Maybe<String>;
  sponsorWebsite_lte?: Maybe<String>;
  sponsorWebsite_gt?: Maybe<String>;
  sponsorWebsite_gte?: Maybe<String>;
  sponsorWebsite_contains?: Maybe<String>;
  sponsorWebsite_not_contains?: Maybe<String>;
  sponsorWebsite_starts_with?: Maybe<String>;
  sponsorWebsite_not_starts_with?: Maybe<String>;
  sponsorWebsite_ends_with?: Maybe<String>;
  sponsorWebsite_not_ends_with?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
  startDate_not?: Maybe<DateTimeInput>;
  startDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  startDate_lt?: Maybe<DateTimeInput>;
  startDate_lte?: Maybe<DateTimeInput>;
  startDate_gt?: Maybe<DateTimeInput>;
  startDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  OR?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  NOT?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
}

export interface IdentityCreateOneWithoutUserInput {
  create?: Maybe<IdentityCreateWithoutUserInput>;
  connect?: Maybe<IdentityWhereUniqueInput>;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface EventCreateOneInput {
  create?: Maybe<EventCreateInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateManyDataInput {
  endDate?: Maybe<DateTimeInput>;
  goal?: Maybe<Int>;
  multiplier?: Maybe<Int>;
  specialEvent?: Maybe<String>;
  specialEventDescription?: Maybe<String>;
  specialEventName?: Maybe<String>;
  sponsorName?: Maybe<String>;
  sponsorWebsite?: Maybe<String>;
  startDate?: Maybe<DateTimeInput>;
}

export interface UserCreateOneWithoutFundsInput {
  create?: Maybe<UserCreateWithoutFundsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CharityUpsertWithWhereUniqueWithoutFollowersInput {
  where: CharityWhereUniqueInput;
  update: CharityUpdateWithoutFollowersDataInput;
  create: CharityCreateWithoutFollowersInput;
}

export interface ChargeCreateOneWithoutTransactionInput {
  create?: Maybe<ChargeCreateWithoutTransactionInput>;
  connect?: Maybe<ChargeWhereUniqueInput>;
}

export interface CharityScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  acronym?: Maybe<String>;
  acronym_not?: Maybe<String>;
  acronym_in?: Maybe<String[] | String>;
  acronym_not_in?: Maybe<String[] | String>;
  acronym_lt?: Maybe<String>;
  acronym_lte?: Maybe<String>;
  acronym_gt?: Maybe<String>;
  acronym_gte?: Maybe<String>;
  acronym_contains?: Maybe<String>;
  acronym_not_contains?: Maybe<String>;
  acronym_starts_with?: Maybe<String>;
  acronym_not_starts_with?: Maybe<String>;
  acronym_ends_with?: Maybe<String>;
  acronym_not_ends_with?: Maybe<String>;
  banner?: Maybe<String>;
  banner_not?: Maybe<String>;
  banner_in?: Maybe<String[] | String>;
  banner_not_in?: Maybe<String[] | String>;
  banner_lt?: Maybe<String>;
  banner_lte?: Maybe<String>;
  banner_gt?: Maybe<String>;
  banner_gte?: Maybe<String>;
  banner_contains?: Maybe<String>;
  banner_not_contains?: Maybe<String>;
  banner_starts_with?: Maybe<String>;
  banner_not_starts_with?: Maybe<String>;
  banner_ends_with?: Maybe<String>;
  banner_not_ends_with?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  bannerCredit_not?: Maybe<String>;
  bannerCredit_in?: Maybe<String[] | String>;
  bannerCredit_not_in?: Maybe<String[] | String>;
  bannerCredit_lt?: Maybe<String>;
  bannerCredit_lte?: Maybe<String>;
  bannerCredit_gt?: Maybe<String>;
  bannerCredit_gte?: Maybe<String>;
  bannerCredit_contains?: Maybe<String>;
  bannerCredit_not_contains?: Maybe<String>;
  bannerCredit_starts_with?: Maybe<String>;
  bannerCredit_not_starts_with?: Maybe<String>;
  bannerCredit_ends_with?: Maybe<String>;
  bannerCredit_not_ends_with?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  connectedAccountID_not?: Maybe<String>;
  connectedAccountID_in?: Maybe<String[] | String>;
  connectedAccountID_not_in?: Maybe<String[] | String>;
  connectedAccountID_lt?: Maybe<String>;
  connectedAccountID_lte?: Maybe<String>;
  connectedAccountID_gt?: Maybe<String>;
  connectedAccountID_gte?: Maybe<String>;
  connectedAccountID_contains?: Maybe<String>;
  connectedAccountID_not_contains?: Maybe<String>;
  connectedAccountID_starts_with?: Maybe<String>;
  connectedAccountID_not_starts_with?: Maybe<String>;
  connectedAccountID_ends_with?: Maybe<String>;
  connectedAccountID_not_ends_with?: Maybe<String>;
  ein?: Maybe<String>;
  ein_not?: Maybe<String>;
  ein_in?: Maybe<String[] | String>;
  ein_not_in?: Maybe<String[] | String>;
  ein_lt?: Maybe<String>;
  ein_lte?: Maybe<String>;
  ein_gt?: Maybe<String>;
  ein_gte?: Maybe<String>;
  ein_contains?: Maybe<String>;
  ein_not_contains?: Maybe<String>;
  ein_starts_with?: Maybe<String>;
  ein_not_starts_with?: Maybe<String>;
  ein_ends_with?: Maybe<String>;
  ein_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesAdministrative_not?: Maybe<Float>;
  expensesAdministrative_in?: Maybe<Float[] | Float>;
  expensesAdministrative_not_in?: Maybe<Float[] | Float>;
  expensesAdministrative_lt?: Maybe<Float>;
  expensesAdministrative_lte?: Maybe<Float>;
  expensesAdministrative_gt?: Maybe<Float>;
  expensesAdministrative_gte?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesFundraising_not?: Maybe<Float>;
  expensesFundraising_in?: Maybe<Float[] | Float>;
  expensesFundraising_not_in?: Maybe<Float[] | Float>;
  expensesFundraising_lt?: Maybe<Float>;
  expensesFundraising_lte?: Maybe<Float>;
  expensesFundraising_gt?: Maybe<Float>;
  expensesFundraising_gte?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesOther_not?: Maybe<Float>;
  expensesOther_in?: Maybe<Float[] | Float>;
  expensesOther_not_in?: Maybe<Float[] | Float>;
  expensesOther_lt?: Maybe<Float>;
  expensesOther_lte?: Maybe<Float>;
  expensesOther_gt?: Maybe<Float>;
  expensesOther_gte?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesProgram_not?: Maybe<Float>;
  expensesProgram_in?: Maybe<Float[] | Float>;
  expensesProgram_not_in?: Maybe<Float[] | Float>;
  expensesProgram_lt?: Maybe<Float>;
  expensesProgram_lte?: Maybe<Float>;
  expensesProgram_gt?: Maybe<Float>;
  expensesProgram_gte?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  expensesUpdated_not?: Maybe<String>;
  expensesUpdated_in?: Maybe<String[] | String>;
  expensesUpdated_not_in?: Maybe<String[] | String>;
  expensesUpdated_lt?: Maybe<String>;
  expensesUpdated_lte?: Maybe<String>;
  expensesUpdated_gt?: Maybe<String>;
  expensesUpdated_gte?: Maybe<String>;
  expensesUpdated_contains?: Maybe<String>;
  expensesUpdated_not_contains?: Maybe<String>;
  expensesUpdated_starts_with?: Maybe<String>;
  expensesUpdated_not_starts_with?: Maybe<String>;
  expensesUpdated_ends_with?: Maybe<String>;
  expensesUpdated_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  mission?: Maybe<String>;
  mission_not?: Maybe<String>;
  mission_in?: Maybe<String[] | String>;
  mission_not_in?: Maybe<String[] | String>;
  mission_lt?: Maybe<String>;
  mission_lte?: Maybe<String>;
  mission_gt?: Maybe<String>;
  mission_gte?: Maybe<String>;
  mission_contains?: Maybe<String>;
  mission_not_contains?: Maybe<String>;
  mission_starts_with?: Maybe<String>;
  mission_not_starts_with?: Maybe<String>;
  mission_ends_with?: Maybe<String>;
  mission_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  representative?: Maybe<String>;
  representative_not?: Maybe<String>;
  representative_in?: Maybe<String[] | String>;
  representative_not_in?: Maybe<String[] | String>;
  representative_lt?: Maybe<String>;
  representative_lte?: Maybe<String>;
  representative_gt?: Maybe<String>;
  representative_gte?: Maybe<String>;
  representative_contains?: Maybe<String>;
  representative_not_contains?: Maybe<String>;
  representative_starts_with?: Maybe<String>;
  representative_not_starts_with?: Maybe<String>;
  representative_ends_with?: Maybe<String>;
  representative_not_ends_with?: Maybe<String>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  AND?: Maybe<CharityScalarWhereInput[] | CharityScalarWhereInput>;
  OR?: Maybe<CharityScalarWhereInput[] | CharityScalarWhereInput>;
  NOT?: Maybe<CharityScalarWhereInput[] | CharityScalarWhereInput>;
}

export interface UserCreateOneWithoutCirclesOwnedInput {
  create?: Maybe<UserCreateWithoutCirclesOwnedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CharityUpdateManyWithWhereNestedInput {
  where: CharityScalarWhereInput;
  data: CharityUpdateManyDataInput;
}

export interface TransferUpdateWithWhereUniqueWithoutSourceInput {
  where: TransferWhereUniqueInput;
  data: TransferUpdateWithoutSourceDataInput;
}

export interface CharityUpdateManyDataInput {
  acronym?: Maybe<String>;
  banner?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  email?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  representative?: Maybe<String>;
  verified?: Maybe<Boolean>;
  website?: Maybe<String>;
}

export interface CharityUpdateOneRequiredWithoutEventsInput {
  create?: Maybe<CharityCreateWithoutEventsInput>;
  update?: Maybe<CharityUpdateWithoutEventsDataInput>;
  upsert?: Maybe<CharityUpsertWithoutEventsInput>;
  connect?: Maybe<CharityWhereUniqueInput>;
}

export interface UserUpsertWithWhereUniqueWithoutCirclesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCirclesDataInput;
  create: UserCreateWithoutCirclesInput;
}

export interface CircleJoinRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  circle?: Maybe<CircleWhereInput>;
  user?: Maybe<UserWhereInput>;
  AND?: Maybe<CircleJoinRequestWhereInput[] | CircleJoinRequestWhereInput>;
  OR?: Maybe<CircleJoinRequestWhereInput[] | CircleJoinRequestWhereInput>;
  NOT?: Maybe<CircleJoinRequestWhereInput[] | CircleJoinRequestWhereInput>;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameFirst_not?: Maybe<String>;
  nameFirst_in?: Maybe<String[] | String>;
  nameFirst_not_in?: Maybe<String[] | String>;
  nameFirst_lt?: Maybe<String>;
  nameFirst_lte?: Maybe<String>;
  nameFirst_gt?: Maybe<String>;
  nameFirst_gte?: Maybe<String>;
  nameFirst_contains?: Maybe<String>;
  nameFirst_not_contains?: Maybe<String>;
  nameFirst_starts_with?: Maybe<String>;
  nameFirst_not_starts_with?: Maybe<String>;
  nameFirst_ends_with?: Maybe<String>;
  nameFirst_not_ends_with?: Maybe<String>;
  nameLast?: Maybe<String>;
  nameLast_not?: Maybe<String>;
  nameLast_in?: Maybe<String[] | String>;
  nameLast_not_in?: Maybe<String[] | String>;
  nameLast_lt?: Maybe<String>;
  nameLast_lte?: Maybe<String>;
  nameLast_gt?: Maybe<String>;
  nameLast_gte?: Maybe<String>;
  nameLast_contains?: Maybe<String>;
  nameLast_not_contains?: Maybe<String>;
  nameLast_starts_with?: Maybe<String>;
  nameLast_not_starts_with?: Maybe<String>;
  nameLast_ends_with?: Maybe<String>;
  nameLast_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  securityToken?: Maybe<Int>;
  securityToken_not?: Maybe<Int>;
  securityToken_in?: Maybe<Int[] | Int>;
  securityToken_not_in?: Maybe<Int[] | Int>;
  securityToken_lt?: Maybe<Int>;
  securityToken_lte?: Maybe<Int>;
  securityToken_gt?: Maybe<Int>;
  securityToken_gte?: Maybe<Int>;
  username?: Maybe<String>;
  username_not?: Maybe<String>;
  username_in?: Maybe<String[] | String>;
  username_not_in?: Maybe<String[] | String>;
  username_lt?: Maybe<String>;
  username_lte?: Maybe<String>;
  username_gt?: Maybe<String>;
  username_gte?: Maybe<String>;
  username_contains?: Maybe<String>;
  username_not_contains?: Maybe<String>;
  username_starts_with?: Maybe<String>;
  username_not_starts_with?: Maybe<String>;
  username_ends_with?: Maybe<String>;
  username_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface CharityWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  acronym?: Maybe<String>;
  acronym_not?: Maybe<String>;
  acronym_in?: Maybe<String[] | String>;
  acronym_not_in?: Maybe<String[] | String>;
  acronym_lt?: Maybe<String>;
  acronym_lte?: Maybe<String>;
  acronym_gt?: Maybe<String>;
  acronym_gte?: Maybe<String>;
  acronym_contains?: Maybe<String>;
  acronym_not_contains?: Maybe<String>;
  acronym_starts_with?: Maybe<String>;
  acronym_not_starts_with?: Maybe<String>;
  acronym_ends_with?: Maybe<String>;
  acronym_not_ends_with?: Maybe<String>;
  banner?: Maybe<String>;
  banner_not?: Maybe<String>;
  banner_in?: Maybe<String[] | String>;
  banner_not_in?: Maybe<String[] | String>;
  banner_lt?: Maybe<String>;
  banner_lte?: Maybe<String>;
  banner_gt?: Maybe<String>;
  banner_gte?: Maybe<String>;
  banner_contains?: Maybe<String>;
  banner_not_contains?: Maybe<String>;
  banner_starts_with?: Maybe<String>;
  banner_not_starts_with?: Maybe<String>;
  banner_ends_with?: Maybe<String>;
  banner_not_ends_with?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  bannerCredit_not?: Maybe<String>;
  bannerCredit_in?: Maybe<String[] | String>;
  bannerCredit_not_in?: Maybe<String[] | String>;
  bannerCredit_lt?: Maybe<String>;
  bannerCredit_lte?: Maybe<String>;
  bannerCredit_gt?: Maybe<String>;
  bannerCredit_gte?: Maybe<String>;
  bannerCredit_contains?: Maybe<String>;
  bannerCredit_not_contains?: Maybe<String>;
  bannerCredit_starts_with?: Maybe<String>;
  bannerCredit_not_starts_with?: Maybe<String>;
  bannerCredit_ends_with?: Maybe<String>;
  bannerCredit_not_ends_with?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  connectedAccountID_not?: Maybe<String>;
  connectedAccountID_in?: Maybe<String[] | String>;
  connectedAccountID_not_in?: Maybe<String[] | String>;
  connectedAccountID_lt?: Maybe<String>;
  connectedAccountID_lte?: Maybe<String>;
  connectedAccountID_gt?: Maybe<String>;
  connectedAccountID_gte?: Maybe<String>;
  connectedAccountID_contains?: Maybe<String>;
  connectedAccountID_not_contains?: Maybe<String>;
  connectedAccountID_starts_with?: Maybe<String>;
  connectedAccountID_not_starts_with?: Maybe<String>;
  connectedAccountID_ends_with?: Maybe<String>;
  connectedAccountID_not_ends_with?: Maybe<String>;
  ein?: Maybe<String>;
  ein_not?: Maybe<String>;
  ein_in?: Maybe<String[] | String>;
  ein_not_in?: Maybe<String[] | String>;
  ein_lt?: Maybe<String>;
  ein_lte?: Maybe<String>;
  ein_gt?: Maybe<String>;
  ein_gte?: Maybe<String>;
  ein_contains?: Maybe<String>;
  ein_not_contains?: Maybe<String>;
  ein_starts_with?: Maybe<String>;
  ein_not_starts_with?: Maybe<String>;
  ein_ends_with?: Maybe<String>;
  ein_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesAdministrative_not?: Maybe<Float>;
  expensesAdministrative_in?: Maybe<Float[] | Float>;
  expensesAdministrative_not_in?: Maybe<Float[] | Float>;
  expensesAdministrative_lt?: Maybe<Float>;
  expensesAdministrative_lte?: Maybe<Float>;
  expensesAdministrative_gt?: Maybe<Float>;
  expensesAdministrative_gte?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesFundraising_not?: Maybe<Float>;
  expensesFundraising_in?: Maybe<Float[] | Float>;
  expensesFundraising_not_in?: Maybe<Float[] | Float>;
  expensesFundraising_lt?: Maybe<Float>;
  expensesFundraising_lte?: Maybe<Float>;
  expensesFundraising_gt?: Maybe<Float>;
  expensesFundraising_gte?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesOther_not?: Maybe<Float>;
  expensesOther_in?: Maybe<Float[] | Float>;
  expensesOther_not_in?: Maybe<Float[] | Float>;
  expensesOther_lt?: Maybe<Float>;
  expensesOther_lte?: Maybe<Float>;
  expensesOther_gt?: Maybe<Float>;
  expensesOther_gte?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesProgram_not?: Maybe<Float>;
  expensesProgram_in?: Maybe<Float[] | Float>;
  expensesProgram_not_in?: Maybe<Float[] | Float>;
  expensesProgram_lt?: Maybe<Float>;
  expensesProgram_lte?: Maybe<Float>;
  expensesProgram_gt?: Maybe<Float>;
  expensesProgram_gte?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  expensesUpdated_not?: Maybe<String>;
  expensesUpdated_in?: Maybe<String[] | String>;
  expensesUpdated_not_in?: Maybe<String[] | String>;
  expensesUpdated_lt?: Maybe<String>;
  expensesUpdated_lte?: Maybe<String>;
  expensesUpdated_gt?: Maybe<String>;
  expensesUpdated_gte?: Maybe<String>;
  expensesUpdated_contains?: Maybe<String>;
  expensesUpdated_not_contains?: Maybe<String>;
  expensesUpdated_starts_with?: Maybe<String>;
  expensesUpdated_not_starts_with?: Maybe<String>;
  expensesUpdated_ends_with?: Maybe<String>;
  expensesUpdated_not_ends_with?: Maybe<String>;
  location?: Maybe<String>;
  location_not?: Maybe<String>;
  location_in?: Maybe<String[] | String>;
  location_not_in?: Maybe<String[] | String>;
  location_lt?: Maybe<String>;
  location_lte?: Maybe<String>;
  location_gt?: Maybe<String>;
  location_gte?: Maybe<String>;
  location_contains?: Maybe<String>;
  location_not_contains?: Maybe<String>;
  location_starts_with?: Maybe<String>;
  location_not_starts_with?: Maybe<String>;
  location_ends_with?: Maybe<String>;
  location_not_ends_with?: Maybe<String>;
  logo?: Maybe<String>;
  logo_not?: Maybe<String>;
  logo_in?: Maybe<String[] | String>;
  logo_not_in?: Maybe<String[] | String>;
  logo_lt?: Maybe<String>;
  logo_lte?: Maybe<String>;
  logo_gt?: Maybe<String>;
  logo_gte?: Maybe<String>;
  logo_contains?: Maybe<String>;
  logo_not_contains?: Maybe<String>;
  logo_starts_with?: Maybe<String>;
  logo_not_starts_with?: Maybe<String>;
  logo_ends_with?: Maybe<String>;
  logo_not_ends_with?: Maybe<String>;
  mission?: Maybe<String>;
  mission_not?: Maybe<String>;
  mission_in?: Maybe<String[] | String>;
  mission_not_in?: Maybe<String[] | String>;
  mission_lt?: Maybe<String>;
  mission_lte?: Maybe<String>;
  mission_gt?: Maybe<String>;
  mission_gte?: Maybe<String>;
  mission_contains?: Maybe<String>;
  mission_not_contains?: Maybe<String>;
  mission_starts_with?: Maybe<String>;
  mission_not_starts_with?: Maybe<String>;
  mission_ends_with?: Maybe<String>;
  mission_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  phoneNumber_not?: Maybe<String>;
  phoneNumber_in?: Maybe<String[] | String>;
  phoneNumber_not_in?: Maybe<String[] | String>;
  phoneNumber_lt?: Maybe<String>;
  phoneNumber_lte?: Maybe<String>;
  phoneNumber_gt?: Maybe<String>;
  phoneNumber_gte?: Maybe<String>;
  phoneNumber_contains?: Maybe<String>;
  phoneNumber_not_contains?: Maybe<String>;
  phoneNumber_starts_with?: Maybe<String>;
  phoneNumber_not_starts_with?: Maybe<String>;
  phoneNumber_ends_with?: Maybe<String>;
  phoneNumber_not_ends_with?: Maybe<String>;
  representative?: Maybe<String>;
  representative_not?: Maybe<String>;
  representative_in?: Maybe<String[] | String>;
  representative_not_in?: Maybe<String[] | String>;
  representative_lt?: Maybe<String>;
  representative_lte?: Maybe<String>;
  representative_gt?: Maybe<String>;
  representative_gte?: Maybe<String>;
  representative_contains?: Maybe<String>;
  representative_not_contains?: Maybe<String>;
  representative_starts_with?: Maybe<String>;
  representative_not_starts_with?: Maybe<String>;
  representative_ends_with?: Maybe<String>;
  representative_not_ends_with?: Maybe<String>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  authHistory_every?: Maybe<CharityAuthHistoryWhereInput>;
  authHistory_some?: Maybe<CharityAuthHistoryWhereInput>;
  authHistory_none?: Maybe<CharityAuthHistoryWhereInput>;
  events_every?: Maybe<EventWhereInput>;
  events_some?: Maybe<EventWhereInput>;
  events_none?: Maybe<EventWhereInput>;
  followers_every?: Maybe<UserWhereInput>;
  followers_some?: Maybe<UserWhereInput>;
  followers_none?: Maybe<UserWhereInput>;
  AND?: Maybe<CharityWhereInput[] | CharityWhereInput>;
  OR?: Maybe<CharityWhereInput[] | CharityWhereInput>;
  NOT?: Maybe<CharityWhereInput[] | CharityWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface CharitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CharityWhereInput>;
  AND?: Maybe<CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput>;
  OR?: Maybe<CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput>;
  NOT?: Maybe<CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput>;
}

export interface UserUpdateManyDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
}

export interface TransferCreateInput {
  id?: Maybe<ID_Input>;
  amount: Int;
  chargeBalance: Int;
  firstOfBatch: Boolean;
  transferID: String;
  event?: Maybe<EventCreateOneWithoutDonationsInput>;
  source?: Maybe<ChargeCreateOneWithoutDonationsInput>;
  transaction: TransactionCreateOneWithoutDonationsInput;
}

export interface UserUpdateOneRequiredWithoutCirclesOwnedInput {
  create?: Maybe<UserCreateWithoutCirclesOwnedInput>;
  update?: Maybe<UserUpdateWithoutCirclesOwnedDataInput>;
  upsert?: Maybe<UserUpsertWithoutCirclesOwnedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPreferencesDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface UserUpdateWithoutCirclesOwnedDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  halos?: Maybe<HaloUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface LoopUpdateManyMutationInput {
  count?: Maybe<Int>;
}

export interface UserUpsertWithoutCirclesOwnedInput {
  update: UserUpdateWithoutCirclesOwnedDataInput;
  create: UserCreateWithoutCirclesOwnedInput;
}

export interface UserCreateOneWithoutLoopsInput {
  create?: Maybe<UserCreateWithoutLoopsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleUpsertWithoutInvitesInput {
  update: CircleUpdateWithoutInvitesDataInput;
  create: CircleCreateWithoutInvitesInput;
}

export interface IdentityUpdateInput {
  provider?: Maybe<IdentityProvider>;
  providerID?: Maybe<String>;
  user?: Maybe<UserUpdateOneRequiredWithoutIdentityInput>;
}

export interface CircleInviteUpsertWithWhereUniqueWithoutUserInput {
  where: CircleInviteWhereUniqueInput;
  update: CircleInviteUpdateWithoutUserDataInput;
  create: CircleInviteCreateWithoutUserInput;
}

export interface UserUpdateWithoutHalosDataInput {
  bio?: Maybe<String>;
  email?: Maybe<String>;
  nameFirst?: Maybe<String>;
  nameLast?: Maybe<String>;
  picture?: Maybe<String>;
  securityToken?: Maybe<Int>;
  username?: Maybe<String>;
  circleJoinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteUpdateManyWithoutUserInput>;
  circles?: Maybe<CircleUpdateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleUpdateManyWithoutOwnerInput>;
  dots?: Maybe<DotUpdateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityUpdateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeUpdateManyWithoutUserInput>;
  identity?: Maybe<IdentityUpdateOneRequiredWithoutUserInput>;
  loops?: Maybe<LoopUpdateManyWithoutUserInput>;
  preferences?: Maybe<PreferencesUpdateOneRequiredWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
}

export interface CircleInviteScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput>;
  OR?: Maybe<CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput>;
  NOT?: Maybe<CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput>;
}

export type TransferWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpsertWithoutCircleJoinRequestsInput {
  update: UserUpdateWithoutCircleJoinRequestsDataInput;
  create: UserCreateWithoutCircleJoinRequestsInput;
}

export interface CharityAuthHistoryCreateManyWithoutCharityInput {
  create?: Maybe<
    | CharityAuthHistoryCreateWithoutCharityInput[]
    | CharityAuthHistoryCreateWithoutCharityInput
  >;
  connect?: Maybe<
    CharityAuthHistoryWhereUniqueInput[] | CharityAuthHistoryWhereUniqueInput
  >;
}

export interface CircleJoinRequestUpsertWithWhereUniqueWithoutCircleInput {
  where: CircleJoinRequestWhereUniqueInput;
  update: CircleJoinRequestUpdateWithoutCircleDataInput;
  create: CircleJoinRequestCreateWithoutCircleInput;
}

export interface CircleInviteCreateManyWithoutCircleInput {
  create?: Maybe<
    | CircleInviteCreateWithoutCircleInput[]
    | CircleInviteCreateWithoutCircleInput
  >;
  connect?: Maybe<
    CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput
  >;
}

export interface CircleJoinRequestScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput
  >;
  OR?: Maybe<
    CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput
  >;
  NOT?: Maybe<
    CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput
  >;
}

export interface UserCreateOneWithoutCircleJoinRequestsInput {
  create?: Maybe<UserCreateWithoutCircleJoinRequestsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleUpsertWithWhereUniqueWithoutMembersInput {
  where: CircleWhereUniqueInput;
  update: CircleUpdateWithoutMembersDataInput;
  create: CircleCreateWithoutMembersInput;
}

export interface CircleCreateManyWithoutOwnerInput {
  create?: Maybe<
    CircleCreateWithoutOwnerInput[] | CircleCreateWithoutOwnerInput
  >;
  connect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
}

export interface UserUpsertWithoutCircleInvitesInput {
  update: UserUpdateWithoutCircleInvitesDataInput;
  create: UserCreateWithoutCircleInvitesInput;
}

export interface TransferCreateManyWithoutEventInput {
  create?: Maybe<
    TransferCreateWithoutEventInput[] | TransferCreateWithoutEventInput
  >;
  connect?: Maybe<TransferWhereUniqueInput[] | TransferWhereUniqueInput>;
}

export interface CircleInviteUpsertWithWhereUniqueWithoutCircleInput {
  where: CircleInviteWhereUniqueInput;
  update: CircleInviteUpdateWithoutCircleDataInput;
  create: CircleInviteCreateWithoutCircleInput;
}

export interface UserCreateOneWithoutTransactionsInput {
  create?: Maybe<UserCreateWithoutTransactionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface CircleUpsertWithoutJoinRequestsInput {
  update: CircleUpdateWithoutJoinRequestsDataInput;
  create: CircleCreateWithoutJoinRequestsInput;
}

export interface LoopCreateManyWithoutUserInput {
  create?: Maybe<LoopCreateWithoutUserInput[] | LoopCreateWithoutUserInput>;
  connect?: Maybe<LoopWhereUniqueInput[] | LoopWhereUniqueInput>;
}

export interface CircleJoinRequestUpsertWithWhereUniqueWithoutUserInput {
  where: CircleJoinRequestWhereUniqueInput;
  update: CircleJoinRequestUpdateWithoutUserDataInput;
  create: CircleJoinRequestCreateWithoutUserInput;
}

export interface TransactionCreateManyWithoutUserInput {
  create?: Maybe<
    TransactionCreateWithoutUserInput[] | TransactionCreateWithoutUserInput
  >;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
}

export interface UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFollowedCharitiesDataInput;
  create: UserCreateWithoutFollowedCharitiesInput;
}

export interface ChargeUpdateInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
  donations?: Maybe<TransferUpdateManyWithoutSourceInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutFundsInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutFundsInput>;
}

export interface CharityUpsertWithoutEventsInput {
  update: CharityUpdateWithoutEventsDataInput;
  create: CharityCreateWithoutEventsInput;
}

export interface TransferSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TransferWhereInput>;
  AND?: Maybe<
    TransferSubscriptionWhereInput[] | TransferSubscriptionWhereInput
  >;
  OR?: Maybe<TransferSubscriptionWhereInput[] | TransferSubscriptionWhereInput>;
  NOT?: Maybe<
    TransferSubscriptionWhereInput[] | TransferSubscriptionWhereInput
  >;
}

export interface EventUpsertWithoutDonationsInput {
  update: EventUpdateWithoutDonationsDataInput;
  create: EventCreateWithoutDonationsInput;
}

export interface CircleInviteSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CircleInviteWhereInput>;
  AND?: Maybe<
    CircleInviteSubscriptionWhereInput[] | CircleInviteSubscriptionWhereInput
  >;
  OR?: Maybe<
    CircleInviteSubscriptionWhereInput[] | CircleInviteSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CircleInviteSubscriptionWhereInput[] | CircleInviteSubscriptionWhereInput
  >;
}

export interface TransferUpsertWithWhereUniqueWithoutSourceInput {
  where: TransferWhereUniqueInput;
  update: TransferUpdateWithoutSourceDataInput;
  create: TransferCreateWithoutSourceInput;
}

export interface TransactionCreateInput {
  id?: Maybe<ID_Input>;
  balance: Int;
  donations?: Maybe<TransferCreateManyWithoutTransactionInput>;
  funds?: Maybe<ChargeCreateOneWithoutTransactionInput>;
  user: UserCreateOneWithoutTransactionsInput;
}

export interface ChargeUpdateManyMutationInput {
  amountAdded?: Maybe<Int>;
  amountNet?: Maybe<Int>;
  chargeID?: Maybe<String>;
}

export interface UserUpdateOneRequiredWithoutLoopsInput {
  create?: Maybe<UserCreateWithoutLoopsInput>;
  update?: Maybe<UserUpdateWithoutLoopsDataInput>;
  upsert?: Maybe<UserUpsertWithoutLoopsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface DotCreateInput {
  id?: Maybe<ID_Input>;
  action: String;
  amount: Int;
  total: Int;
  user: UserCreateOneWithoutDotsInput;
}

export interface IdentityCreateInput {
  id?: Maybe<ID_Input>;
  provider: IdentityProvider;
  providerID: String;
  user: UserCreateOneWithoutIdentityInput;
}

export interface CircleJoinRequestUpdateInput {
  circle?: Maybe<CircleUpdateOneRequiredWithoutJoinRequestsInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutCircleJoinRequestsInput>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  username?: Maybe<String>;
}>;

export interface CharityCreateInput {
  id?: Maybe<ID_Input>;
  acronym?: Maybe<String>;
  banner?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein: String;
  email: String;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  mission?: Maybe<String>;
  name: String;
  phoneNumber?: Maybe<String>;
  representative: String;
  verified?: Maybe<Boolean>;
  website: String;
  authHistory?: Maybe<CharityAuthHistoryCreateManyWithoutCharityInput>;
  events?: Maybe<EventCreateManyWithoutCharityInput>;
  followers?: Maybe<UserCreateManyWithoutFollowedCharitiesInput>;
}

export interface CircleJoinRequestCreateManyWithoutUserInput {
  create?: Maybe<
    | CircleJoinRequestCreateWithoutUserInput[]
    | CircleJoinRequestCreateWithoutUserInput
  >;
  connect?: Maybe<
    CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput
  >;
}

export interface CharityUpdateInput {
  acronym?: Maybe<String>;
  banner?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  email?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  representative?: Maybe<String>;
  verified?: Maybe<Boolean>;
  website?: Maybe<String>;
  authHistory?: Maybe<CharityAuthHistoryUpdateManyWithoutCharityInput>;
  events?: Maybe<EventUpdateManyWithoutCharityInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowedCharitiesInput>;
}

export interface CircleCreateOneWithoutInvitesInput {
  create?: Maybe<CircleCreateWithoutInvitesInput>;
  connect?: Maybe<CircleWhereUniqueInput>;
}

export interface CharityUpdateManyMutationInput {
  acronym?: Maybe<String>;
  banner?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  email?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  representative?: Maybe<String>;
  verified?: Maybe<Boolean>;
  website?: Maybe<String>;
}

export interface TransactionCreateOneWithoutFundsInput {
  create?: Maybe<TransactionCreateWithoutFundsInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface CharityAuthHistoryCreateInput {
  id?: Maybe<ID_Input>;
  charity: CharityCreateOneWithoutAuthHistoryInput;
}

export interface PreferencesCreateOneWithoutUserInput {
  create?: Maybe<PreferencesCreateWithoutUserInput>;
  connect?: Maybe<PreferencesWhereUniqueInput>;
}

export interface CharityCreateOneWithoutAuthHistoryInput {
  create?: Maybe<CharityCreateWithoutAuthHistoryInput>;
  connect?: Maybe<CharityWhereUniqueInput>;
}

export interface EventUpdateOneWithoutDonationsInput {
  create?: Maybe<EventCreateWithoutDonationsInput>;
  update?: Maybe<EventUpdateWithoutDonationsDataInput>;
  upsert?: Maybe<EventUpsertWithoutDonationsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface CharityCreateWithoutAuthHistoryInput {
  id?: Maybe<ID_Input>;
  acronym?: Maybe<String>;
  banner?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein: String;
  email: String;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  mission?: Maybe<String>;
  name: String;
  phoneNumber?: Maybe<String>;
  representative: String;
  verified?: Maybe<Boolean>;
  website: String;
  events?: Maybe<EventCreateManyWithoutCharityInput>;
  followers?: Maybe<UserCreateManyWithoutFollowedCharitiesInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface CharityAuthHistoryUpdateInput {
  charity?: Maybe<CharityUpdateOneRequiredWithoutAuthHistoryInput>;
}

export interface UserUpsertWithoutIdentityInput {
  update: UserUpdateWithoutIdentityDataInput;
  create: UserCreateWithoutIdentityInput;
}

export interface CharityUpdateOneRequiredWithoutAuthHistoryInput {
  create?: Maybe<CharityCreateWithoutAuthHistoryInput>;
  update?: Maybe<CharityUpdateWithoutAuthHistoryDataInput>;
  upsert?: Maybe<CharityUpsertWithoutAuthHistoryInput>;
  connect?: Maybe<CharityWhereUniqueInput>;
}

export interface EventCreateOneWithoutDonationsInput {
  create?: Maybe<EventCreateWithoutDonationsInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface CharityUpdateWithoutAuthHistoryDataInput {
  acronym?: Maybe<String>;
  banner?: Maybe<String>;
  bannerCredit?: Maybe<String>;
  connectedAccountID?: Maybe<String>;
  ein?: Maybe<String>;
  email?: Maybe<String>;
  expensesAdministrative?: Maybe<Float>;
  expensesFundraising?: Maybe<Float>;
  expensesOther?: Maybe<Float>;
  expensesProgram?: Maybe<Float>;
  expensesUpdated?: Maybe<String>;
  location?: Maybe<String>;
  logo?: Maybe<String>;
  mission?: Maybe<String>;
  name?: Maybe<String>;
  phoneNumber?: Maybe<String>;
  representative?: Maybe<String>;
  verified?: Maybe<Boolean>;
  website?: Maybe<String>;
  events?: Maybe<EventUpdateManyWithoutCharityInput>;
  followers?: Maybe<UserUpdateManyWithoutFollowedCharitiesInput>;
}

export interface CharityCreateManyWithoutFollowersInput {
  create?: Maybe<
    CharityCreateWithoutFollowersInput[] | CharityCreateWithoutFollowersInput
  >;
  connect?: Maybe<CharityWhereUniqueInput[] | CharityWhereUniqueInput>;
}

export interface CharityUpsertWithoutAuthHistoryInput {
  update: CharityUpdateWithoutAuthHistoryDataInput;
  create: CharityCreateWithoutAuthHistoryInput;
}

export interface TransactionCreateOneWithoutDonationsInput {
  create?: Maybe<TransactionCreateWithoutDonationsInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface CircleCreateInput {
  id?: Maybe<ID_Input>;
  description?: Maybe<String>;
  name: String;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestCreateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteCreateManyWithoutCircleInput>;
  members?: Maybe<UserCreateManyWithoutCirclesInput>;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface UserCreateWithoutPreferencesInput {
  id?: Maybe<ID_Input>;
  bio?: Maybe<String>;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: Maybe<String>;
  securityToken: Int;
  username: String;
  circleJoinRequests?: Maybe<CircleJoinRequestCreateManyWithoutUserInput>;
  circleInvites?: Maybe<CircleInviteCreateManyWithoutUserInput>;
  circles?: Maybe<CircleCreateManyWithoutMembersInput>;
  circlesOwned?: Maybe<CircleCreateManyWithoutOwnerInput>;
  dots?: Maybe<DotCreateManyWithoutUserInput>;
  followedCharities?: Maybe<CharityCreateManyWithoutFollowersInput>;
  funds?: Maybe<ChargeCreateManyWithoutUserInput>;
  halos?: Maybe<HaloCreateManyWithoutUserInput>;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: Maybe<LoopCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
}

export interface CircleInviteUpdateInput {
  circle?: Maybe<CircleUpdateOneRequiredWithoutInvitesInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutCircleInvitesInput>;
}

export interface CircleInviteCreateInput {
  id?: Maybe<ID_Input>;
  circle: CircleCreateOneWithoutInvitesInput;
  user: UserCreateOneWithoutCircleInvitesInput;
}

export interface CircleUpdateManyMutationInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
}

export interface CircleUpdateInput {
  description?: Maybe<String>;
  name?: Maybe<String>;
  open?: Maybe<Boolean>;
  joinRequests?: Maybe<CircleJoinRequestUpdateManyWithoutCircleInput>;
  invites?: Maybe<CircleInviteUpdateManyWithoutCircleInput>;
  members?: Maybe<UserUpdateManyWithoutCirclesInput>;
  owner?: Maybe<UserUpdateOneRequiredWithoutCirclesOwnedInput>;
}

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface IdentitySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<IdentityWhereInput>;
  AND?: Maybe<
    IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput
  >;
  OR?: Maybe<IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput>;
  NOT?: Maybe<
    IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput
  >;
}

export interface HaloCreateManyWithoutUserInput {
  create?: Maybe<HaloCreateWithoutUserInput[] | HaloCreateWithoutUserInput>;
  connect?: Maybe<HaloWhereUniqueInput[] | HaloWhereUniqueInput>;
}

export interface CircleCreateManyWithoutMembersInput {
  create?: Maybe<
    CircleCreateWithoutMembersInput[] | CircleCreateWithoutMembersInput
  >;
  connect?: Maybe<CircleWhereUniqueInput[] | CircleWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  email: () => Promise<String>;
  nameFirst: () => Promise<String>;
  nameLast: () => Promise<String>;
  picture: () => Promise<String>;
  securityToken: () => Promise<Int>;
  username: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bio: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameLast: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  securityToken: () => Promise<AsyncIterator<Int>>;
  username: () => Promise<AsyncIterator<String>>;
}

export interface ChargeEdge {
  node: Charge;
  cursor: String;
}

export interface ChargeEdgePromise extends Promise<ChargeEdge>, Fragmentable {
  node: <T = ChargePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChargeEdgeSubscription
  extends Promise<AsyncIterator<ChargeEdge>>,
    Fragmentable {
  node: <T = ChargeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Transfer {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amount: Int;
  chargeBalance: Int;
  firstOfBatch: Boolean;
  transferID: String;
}

export interface TransferPromise extends Promise<Transfer>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  chargeBalance: () => Promise<Int>;
  firstOfBatch: () => Promise<Boolean>;
  transferID: () => Promise<String>;
  event: <T = EventPromise>() => T;
  source: <T = ChargePromise>() => T;
  transaction: <T = TransactionPromise>() => T;
}

export interface TransferSubscription
  extends Promise<AsyncIterator<Transfer>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  chargeBalance: () => Promise<AsyncIterator<Int>>;
  firstOfBatch: () => Promise<AsyncIterator<Boolean>>;
  transferID: () => Promise<AsyncIterator<String>>;
  event: <T = EventSubscription>() => T;
  source: <T = ChargeSubscription>() => T;
  transaction: <T = TransactionSubscription>() => T;
}

export interface TransferNullablePromise
  extends Promise<Transfer | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  chargeBalance: () => Promise<Int>;
  firstOfBatch: () => Promise<Boolean>;
  transferID: () => Promise<String>;
  event: <T = EventPromise>() => T;
  source: <T = ChargePromise>() => T;
  transaction: <T = TransactionPromise>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface Event {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  endDate: DateTimeOutput;
  goal: Int;
  multiplier?: Int;
  specialEvent?: String;
  specialEventDescription?: String;
  specialEventName?: String;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeOutput;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  goal: () => Promise<Int>;
  multiplier: () => Promise<Int>;
  specialEvent: () => Promise<String>;
  specialEventDescription: () => Promise<String>;
  specialEventName: () => Promise<String>;
  sponsorName: () => Promise<String>;
  sponsorWebsite: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  charity: <T = CharityPromise>() => T;
  donations: <T = FragmentableArray<Transfer>>(args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  goal: () => Promise<AsyncIterator<Int>>;
  multiplier: () => Promise<AsyncIterator<Int>>;
  specialEvent: () => Promise<AsyncIterator<String>>;
  specialEventDescription: () => Promise<AsyncIterator<String>>;
  specialEventName: () => Promise<AsyncIterator<String>>;
  sponsorName: () => Promise<AsyncIterator<String>>;
  sponsorWebsite: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  charity: <T = CharitySubscription>() => T;
  donations: <T = Promise<AsyncIterator<TransferSubscription>>>(args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  goal: () => Promise<Int>;
  multiplier: () => Promise<Int>;
  specialEvent: () => Promise<String>;
  specialEventDescription: () => Promise<String>;
  specialEventName: () => Promise<String>;
  sponsorName: () => Promise<String>;
  sponsorWebsite: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  charity: <T = CharityPromise>() => T;
  donations: <T = FragmentableArray<Transfer>>(args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChargeConnection {
  pageInfo: PageInfo;
  edges: ChargeEdge[];
}

export interface ChargeConnectionPromise
  extends Promise<ChargeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChargeEdge>>() => T;
  aggregate: <T = AggregateChargePromise>() => T;
}

export interface ChargeConnectionSubscription
  extends Promise<AsyncIterator<ChargeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChargeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChargeSubscription>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Transaction {
  id: ID_Output;
  createdAt: DateTimeOutput;
  balance: Int;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  balance: () => Promise<Int>;
  donations: <T = FragmentableArray<Transfer>>(args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = ChargePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  balance: () => Promise<AsyncIterator<Int>>;
  donations: <T = Promise<AsyncIterator<TransferSubscription>>>(args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = ChargeSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface TransactionNullablePromise
  extends Promise<Transaction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  balance: () => Promise<Int>;
  donations: <T = FragmentableArray<Transfer>>(args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = ChargePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface Charge {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
}

export interface ChargePromise extends Promise<Charge>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amountAdded: () => Promise<Int>;
  amountNet: () => Promise<Int>;
  chargeID: () => Promise<String>;
  donations: <T = FragmentableArray<Transfer>>(args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface ChargeSubscription
  extends Promise<AsyncIterator<Charge>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amountAdded: () => Promise<AsyncIterator<Int>>;
  amountNet: () => Promise<AsyncIterator<Int>>;
  chargeID: () => Promise<AsyncIterator<String>>;
  donations: <T = Promise<AsyncIterator<TransferSubscription>>>(args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface ChargeNullablePromise
  extends Promise<Charge | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amountAdded: () => Promise<Int>;
  amountNet: () => Promise<Int>;
  chargeID: () => Promise<String>;
  donations: <T = FragmentableArray<Transfer>>(args?: {
    where?: TransferWhereInput;
    orderBy?: TransferOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface TransferEdge {
  node: Transfer;
  cursor: String;
}

export interface TransferEdgePromise
  extends Promise<TransferEdge>,
    Fragmentable {
  node: <T = TransferPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransferEdgeSubscription
  extends Promise<AsyncIterator<TransferEdge>>,
    Fragmentable {
  node: <T = TransferSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ChargeSubscriptionPayload {
  mutation: MutationType;
  node: Charge;
  updatedFields: String[];
  previousValues: ChargePreviousValues;
}

export interface ChargeSubscriptionPayloadPromise
  extends Promise<ChargeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChargePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChargePreviousValuesPromise>() => T;
}

export interface ChargeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChargeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChargeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChargePreviousValuesSubscription>() => T;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ChargePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amountAdded: Int;
  amountNet: Int;
  chargeID: String;
}

export interface ChargePreviousValuesPromise
  extends Promise<ChargePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amountAdded: () => Promise<Int>;
  amountNet: () => Promise<Int>;
  chargeID: () => Promise<String>;
}

export interface ChargePreviousValuesSubscription
  extends Promise<AsyncIterator<ChargePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amountAdded: () => Promise<AsyncIterator<Int>>;
  amountNet: () => Promise<AsyncIterator<Int>>;
  chargeID: () => Promise<AsyncIterator<String>>;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface TransferConnection {
  pageInfo: PageInfo;
  edges: TransferEdge[];
}

export interface TransferConnectionPromise
  extends Promise<TransferConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransferEdge>>() => T;
  aggregate: <T = AggregateTransferPromise>() => T;
}

export interface TransferConnectionSubscription
  extends Promise<AsyncIterator<TransferConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransferEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransferSubscription>() => T;
}

export interface TransactionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  balance: Int;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  balance: () => Promise<Int>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  balance: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PreferencesEdge {
  node: Preferences;
  cursor: String;
}

export interface PreferencesEdgePromise
  extends Promise<PreferencesEdge>,
    Fragmentable {
  node: <T = PreferencesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PreferencesEdgeSubscription
  extends Promise<AsyncIterator<PreferencesEdge>>,
    Fragmentable {
  node: <T = PreferencesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePreferences {
  count: Int;
}

export interface AggregatePreferencesPromise
  extends Promise<AggregatePreferences>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePreferencesSubscription
  extends Promise<AsyncIterator<AggregatePreferences>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateLoop {
  count: Int;
}

export interface AggregateLoopPromise
  extends Promise<AggregateLoop>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoopSubscription
  extends Promise<AsyncIterator<AggregateLoop>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PreferencesConnection {
  pageInfo: PageInfo;
  edges: PreferencesEdge[];
}

export interface PreferencesConnectionPromise
  extends Promise<PreferencesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PreferencesEdge>>() => T;
  aggregate: <T = AggregatePreferencesPromise>() => T;
}

export interface PreferencesConnectionSubscription
  extends Promise<AsyncIterator<PreferencesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PreferencesEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePreferencesSubscription>() => T;
}

export interface LoopConnection {
  pageInfo: PageInfo;
  edges: LoopEdge[];
}

export interface LoopConnectionPromise
  extends Promise<LoopConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoopEdge>>() => T;
  aggregate: <T = AggregateLoopPromise>() => T;
}

export interface LoopConnectionSubscription
  extends Promise<AsyncIterator<LoopConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoopEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoopSubscription>() => T;
}

export interface CharitySubscriptionPayload {
  mutation: MutationType;
  node: Charity;
  updatedFields: String[];
  previousValues: CharityPreviousValues;
}

export interface CharitySubscriptionPayloadPromise
  extends Promise<CharitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharityPreviousValuesPromise>() => T;
}

export interface CharitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharityPreviousValuesSubscription>() => T;
}

export interface IdentityEdge {
  node: Identity;
  cursor: String;
}

export interface IdentityEdgePromise
  extends Promise<IdentityEdge>,
    Fragmentable {
  node: <T = IdentityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IdentityEdgeSubscription
  extends Promise<AsyncIterator<IdentityEdge>>,
    Fragmentable {
  node: <T = IdentitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharityPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  acronym?: String;
  banner?: String;
  bannerCredit?: String;
  connectedAccountID?: String;
  ein: String;
  email: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location?: String;
  logo?: String;
  mission?: String;
  name: String;
  phoneNumber?: String;
  representative: String;
  verified?: Boolean;
  website: String;
}

export interface CharityPreviousValuesPromise
  extends Promise<CharityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  acronym: () => Promise<String>;
  banner: () => Promise<String>;
  bannerCredit: () => Promise<String>;
  connectedAccountID: () => Promise<String>;
  ein: () => Promise<String>;
  email: () => Promise<String>;
  expensesAdministrative: () => Promise<Float>;
  expensesFundraising: () => Promise<Float>;
  expensesOther: () => Promise<Float>;
  expensesProgram: () => Promise<Float>;
  expensesUpdated: () => Promise<String>;
  location: () => Promise<String>;
  logo: () => Promise<String>;
  mission: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  representative: () => Promise<String>;
  verified: () => Promise<Boolean>;
  website: () => Promise<String>;
}

export interface CharityPreviousValuesSubscription
  extends Promise<AsyncIterator<CharityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  acronym: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
  bannerCredit: () => Promise<AsyncIterator<String>>;
  connectedAccountID: () => Promise<AsyncIterator<String>>;
  ein: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  expensesAdministrative: () => Promise<AsyncIterator<Float>>;
  expensesFundraising: () => Promise<AsyncIterator<Float>>;
  expensesOther: () => Promise<AsyncIterator<Float>>;
  expensesProgram: () => Promise<AsyncIterator<Float>>;
  expensesUpdated: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  mission: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  representative: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  website: () => Promise<AsyncIterator<String>>;
}

export interface Charity {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  acronym?: String;
  banner?: String;
  bannerCredit?: String;
  connectedAccountID?: String;
  ein: String;
  email: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location?: String;
  logo?: String;
  mission?: String;
  name: String;
  phoneNumber?: String;
  representative: String;
  verified?: Boolean;
  website: String;
}

export interface CharityPromise extends Promise<Charity>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  acronym: () => Promise<String>;
  banner: () => Promise<String>;
  bannerCredit: () => Promise<String>;
  connectedAccountID: () => Promise<String>;
  ein: () => Promise<String>;
  email: () => Promise<String>;
  expensesAdministrative: () => Promise<Float>;
  expensesFundraising: () => Promise<Float>;
  expensesOther: () => Promise<Float>;
  expensesProgram: () => Promise<Float>;
  expensesUpdated: () => Promise<String>;
  location: () => Promise<String>;
  logo: () => Promise<String>;
  mission: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  representative: () => Promise<String>;
  verified: () => Promise<Boolean>;
  website: () => Promise<String>;
  authHistory: <T = FragmentableArray<CharityAuthHistory>>(args?: {
    where?: CharityAuthHistoryWhereInput;
    orderBy?: CharityAuthHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CharitySubscription
  extends Promise<AsyncIterator<Charity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  acronym: () => Promise<AsyncIterator<String>>;
  banner: () => Promise<AsyncIterator<String>>;
  bannerCredit: () => Promise<AsyncIterator<String>>;
  connectedAccountID: () => Promise<AsyncIterator<String>>;
  ein: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  expensesAdministrative: () => Promise<AsyncIterator<Float>>;
  expensesFundraising: () => Promise<AsyncIterator<Float>>;
  expensesOther: () => Promise<AsyncIterator<Float>>;
  expensesProgram: () => Promise<AsyncIterator<Float>>;
  expensesUpdated: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  logo: () => Promise<AsyncIterator<String>>;
  mission: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  representative: () => Promise<AsyncIterator<String>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  website: () => Promise<AsyncIterator<String>>;
  authHistory: <
    T = Promise<AsyncIterator<CharityAuthHistorySubscription>>
  >(args?: {
    where?: CharityAuthHistoryWhereInput;
    orderBy?: CharityAuthHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CharityNullablePromise
  extends Promise<Charity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  acronym: () => Promise<String>;
  banner: () => Promise<String>;
  bannerCredit: () => Promise<String>;
  connectedAccountID: () => Promise<String>;
  ein: () => Promise<String>;
  email: () => Promise<String>;
  expensesAdministrative: () => Promise<Float>;
  expensesFundraising: () => Promise<Float>;
  expensesOther: () => Promise<Float>;
  expensesProgram: () => Promise<Float>;
  expensesUpdated: () => Promise<String>;
  location: () => Promise<String>;
  logo: () => Promise<String>;
  mission: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  representative: () => Promise<String>;
  verified: () => Promise<Boolean>;
  website: () => Promise<String>;
  authHistory: <T = FragmentableArray<CharityAuthHistory>>(args?: {
    where?: CharityAuthHistoryWhereInput;
    orderBy?: CharityAuthHistoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  events: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followers: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Preferences {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  allowDonationEmails: Boolean;
  publicProfile: Boolean;
}

export interface PreferencesPromise extends Promise<Preferences>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  allowDonationEmails: () => Promise<Boolean>;
  publicProfile: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
}

export interface PreferencesSubscription
  extends Promise<AsyncIterator<Preferences>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  allowDonationEmails: () => Promise<AsyncIterator<Boolean>>;
  publicProfile: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
}

export interface PreferencesNullablePromise
  extends Promise<Preferences | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  allowDonationEmails: () => Promise<Boolean>;
  publicProfile: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
}

export interface HaloEdge {
  node: Halo;
  cursor: String;
}

export interface HaloEdgePromise extends Promise<HaloEdge>, Fragmentable {
  node: <T = HaloPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HaloEdgeSubscription
  extends Promise<AsyncIterator<HaloEdge>>,
    Fragmentable {
  node: <T = HaloSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharityAuthHistorySubscriptionPayload {
  mutation: MutationType;
  node: CharityAuthHistory;
  updatedFields: String[];
  previousValues: CharityAuthHistoryPreviousValues;
}

export interface CharityAuthHistorySubscriptionPayloadPromise
  extends Promise<CharityAuthHistorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharityAuthHistoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharityAuthHistoryPreviousValuesPromise>() => T;
}

export interface CharityAuthHistorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharityAuthHistorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharityAuthHistorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharityAuthHistoryPreviousValuesSubscription>() => T;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CharityAuthHistoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface CharityAuthHistoryPreviousValuesPromise
  extends Promise<CharityAuthHistoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface CharityAuthHistoryPreviousValuesSubscription
  extends Promise<AsyncIterator<CharityAuthHistoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface Loop {
  id: ID_Output;
  createdAt: DateTimeOutput;
  count: Int;
}

export interface LoopPromise extends Promise<Loop>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  count: () => Promise<Int>;
  event: <T = EventPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface LoopSubscription
  extends Promise<AsyncIterator<Loop>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  count: () => Promise<AsyncIterator<Int>>;
  event: <T = EventSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface LoopNullablePromise
  extends Promise<Loop | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  count: () => Promise<Int>;
  event: <T = EventPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface DotEdge {
  node: Dot;
  cursor: String;
}

export interface DotEdgePromise extends Promise<DotEdge>, Fragmentable {
  node: <T = DotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DotEdgeSubscription
  extends Promise<AsyncIterator<DotEdge>>,
    Fragmentable {
  node: <T = DotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CircleSubscriptionPayload {
  mutation: MutationType;
  node: Circle;
  updatedFields: String[];
  previousValues: CirclePreviousValues;
}

export interface CircleSubscriptionPayloadPromise
  extends Promise<CircleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CirclePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CirclePreviousValuesPromise>() => T;
}

export interface CircleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CircleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CircleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CirclePreviousValuesSubscription>() => T;
}

export interface AggregateCircleJoinRequest {
  count: Int;
}

export interface AggregateCircleJoinRequestPromise
  extends Promise<AggregateCircleJoinRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCircleJoinRequestSubscription
  extends Promise<AsyncIterator<AggregateCircleJoinRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CirclePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  name: String;
  open: Boolean;
}

export interface CirclePreviousValuesPromise
  extends Promise<CirclePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  open: () => Promise<Boolean>;
}

export interface CirclePreviousValuesSubscription
  extends Promise<AsyncIterator<CirclePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface CircleJoinRequestConnection {
  pageInfo: PageInfo;
  edges: CircleJoinRequestEdge[];
}

export interface CircleJoinRequestConnectionPromise
  extends Promise<CircleJoinRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CircleJoinRequestEdge>>() => T;
  aggregate: <T = AggregateCircleJoinRequestPromise>() => T;
}

export interface CircleJoinRequestConnectionSubscription
  extends Promise<AsyncIterator<CircleJoinRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CircleJoinRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCircleJoinRequestSubscription>() => T;
}

export interface Identity {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  provider: IdentityProvider;
  providerID: String;
}

export interface IdentityPromise extends Promise<Identity>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  provider: () => Promise<IdentityProvider>;
  providerID: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface IdentitySubscription
  extends Promise<AsyncIterator<Identity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  provider: () => Promise<AsyncIterator<IdentityProvider>>;
  providerID: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface IdentityNullablePromise
  extends Promise<Identity | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  provider: () => Promise<IdentityProvider>;
  providerID: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface CircleInviteEdge {
  node: CircleInvite;
  cursor: String;
}

export interface CircleInviteEdgePromise
  extends Promise<CircleInviteEdge>,
    Fragmentable {
  node: <T = CircleInvitePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CircleInviteEdgeSubscription
  extends Promise<AsyncIterator<CircleInviteEdge>>,
    Fragmentable {
  node: <T = CircleInviteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CircleInviteSubscriptionPayload {
  mutation: MutationType;
  node: CircleInvite;
  updatedFields: String[];
  previousValues: CircleInvitePreviousValues;
}

export interface CircleInviteSubscriptionPayloadPromise
  extends Promise<CircleInviteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CircleInvitePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CircleInvitePreviousValuesPromise>() => T;
}

export interface CircleInviteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CircleInviteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CircleInviteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CircleInvitePreviousValuesSubscription>() => T;
}

export interface AggregateCircle {
  count: Int;
}

export interface AggregateCirclePromise
  extends Promise<AggregateCircle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCircleSubscription
  extends Promise<AsyncIterator<AggregateCircle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CircleInvitePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleInvitePreviousValuesPromise
  extends Promise<CircleInvitePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CircleInvitePreviousValuesSubscription
  extends Promise<AsyncIterator<CircleInvitePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CircleConnection {
  pageInfo: PageInfo;
  edges: CircleEdge[];
}

export interface CircleConnectionPromise
  extends Promise<CircleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CircleEdge>>() => T;
  aggregate: <T = AggregateCirclePromise>() => T;
}

export interface CircleConnectionSubscription
  extends Promise<AsyncIterator<CircleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CircleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCircleSubscription>() => T;
}

export interface Halo {
  id: ID_Output;
  createdAt: DateTimeOutput;
  key: String;
  tier?: String;
}

export interface HaloPromise extends Promise<Halo>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  tier: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface HaloSubscription
  extends Promise<AsyncIterator<Halo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  tier: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface HaloNullablePromise
  extends Promise<Halo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  tier: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface CharityAuthHistoryEdge {
  node: CharityAuthHistory;
  cursor: String;
}

export interface CharityAuthHistoryEdgePromise
  extends Promise<CharityAuthHistoryEdge>,
    Fragmentable {
  node: <T = CharityAuthHistoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharityAuthHistoryEdgeSubscription
  extends Promise<AsyncIterator<CharityAuthHistoryEdge>>,
    Fragmentable {
  node: <T = CharityAuthHistorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CircleJoinRequestSubscriptionPayload {
  mutation: MutationType;
  node: CircleJoinRequest;
  updatedFields: String[];
  previousValues: CircleJoinRequestPreviousValues;
}

export interface CircleJoinRequestSubscriptionPayloadPromise
  extends Promise<CircleJoinRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CircleJoinRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CircleJoinRequestPreviousValuesPromise>() => T;
}

export interface CircleJoinRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CircleJoinRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CircleJoinRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CircleJoinRequestPreviousValuesSubscription>() => T;
}

export interface AggregateCharity {
  count: Int;
}

export interface AggregateCharityPromise
  extends Promise<AggregateCharity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharitySubscription
  extends Promise<AsyncIterator<AggregateCharity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CircleJoinRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleJoinRequestPreviousValuesPromise
  extends Promise<CircleJoinRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CircleJoinRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<CircleJoinRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CharityConnection {
  pageInfo: PageInfo;
  edges: CharityEdge[];
}

export interface CharityConnectionPromise
  extends Promise<CharityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharityEdge>>() => T;
  aggregate: <T = AggregateCharityPromise>() => T;
}

export interface CharityConnectionSubscription
  extends Promise<AsyncIterator<CharityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharitySubscription>() => T;
}

export interface TransferSubscriptionPayload {
  mutation: MutationType;
  node: Transfer;
  updatedFields: String[];
  previousValues: TransferPreviousValues;
}

export interface TransferSubscriptionPayloadPromise
  extends Promise<TransferSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransferPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransferPreviousValuesPromise>() => T;
}

export interface TransferSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransferSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransferSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransferPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface DotSubscriptionPayload {
  mutation: MutationType;
  node: Dot;
  updatedFields: String[];
  previousValues: DotPreviousValues;
}

export interface DotSubscriptionPayloadPromise
  extends Promise<DotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DotPreviousValuesPromise>() => T;
}

export interface DotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DotPreviousValuesSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface DotPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  action: String;
  amount: Int;
  total: Int;
}

export interface DotPreviousValuesPromise
  extends Promise<DotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
  amount: () => Promise<Int>;
  total: () => Promise<Int>;
}

export interface DotPreviousValuesSubscription
  extends Promise<AsyncIterator<DotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Dot {
  id: ID_Output;
  createdAt: DateTimeOutput;
  action: String;
  amount: Int;
  total: Int;
}

export interface DotPromise extends Promise<Dot>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
  amount: () => Promise<Int>;
  total: () => Promise<Int>;
  user: <T = UserPromise>() => T;
}

export interface DotSubscription
  extends Promise<AsyncIterator<Dot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
}

export interface DotNullablePromise extends Promise<Dot | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
  amount: () => Promise<Int>;
  total: () => Promise<Int>;
  user: <T = UserPromise>() => T;
}

export interface AggregateIdentity {
  count: Int;
}

export interface AggregateIdentityPromise
  extends Promise<AggregateIdentity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIdentitySubscription
  extends Promise<AsyncIterator<AggregateIdentity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface AggregateHalo {
  count: Int;
}

export interface AggregateHaloPromise
  extends Promise<AggregateHalo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHaloSubscription
  extends Promise<AsyncIterator<AggregateHalo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  endDate: DateTimeOutput;
  goal: Int;
  multiplier?: Int;
  specialEvent?: String;
  specialEventDescription?: String;
  specialEventName?: String;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeOutput;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  goal: () => Promise<Int>;
  multiplier: () => Promise<Int>;
  specialEvent: () => Promise<String>;
  specialEventDescription: () => Promise<String>;
  specialEventName: () => Promise<String>;
  sponsorName: () => Promise<String>;
  sponsorWebsite: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  goal: () => Promise<AsyncIterator<Int>>;
  multiplier: () => Promise<AsyncIterator<Int>>;
  specialEvent: () => Promise<AsyncIterator<String>>;
  specialEventDescription: () => Promise<AsyncIterator<String>>;
  specialEventName: () => Promise<AsyncIterator<String>>;
  sponsorName: () => Promise<AsyncIterator<String>>;
  sponsorWebsite: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharityAuthHistory {
  id: ID_Output;
  createdAt: DateTimeOutput;
}

export interface CharityAuthHistoryPromise
  extends Promise<CharityAuthHistory>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  charity: <T = CharityPromise>() => T;
}

export interface CharityAuthHistorySubscription
  extends Promise<AsyncIterator<CharityAuthHistory>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  charity: <T = CharitySubscription>() => T;
}

export interface CharityAuthHistoryNullablePromise
  extends Promise<CharityAuthHistory | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  charity: <T = CharityPromise>() => T;
}

export interface DotConnection {
  pageInfo: PageInfo;
  edges: DotEdge[];
}

export interface DotConnectionPromise
  extends Promise<DotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DotEdge>>() => T;
  aggregate: <T = AggregateDotPromise>() => T;
}

export interface DotConnectionSubscription
  extends Promise<AsyncIterator<DotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDotSubscription>() => T;
}

export interface HaloSubscriptionPayload {
  mutation: MutationType;
  node: Halo;
  updatedFields: String[];
  previousValues: HaloPreviousValues;
}

export interface HaloSubscriptionPayloadPromise
  extends Promise<HaloSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HaloPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HaloPreviousValuesPromise>() => T;
}

export interface HaloSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HaloSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HaloSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HaloPreviousValuesSubscription>() => T;
}

export interface AggregateCircleInvite {
  count: Int;
}

export interface AggregateCircleInvitePromise
  extends Promise<AggregateCircleInvite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCircleInviteSubscription
  extends Promise<AsyncIterator<AggregateCircleInvite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HaloPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  key: String;
  tier?: String;
}

export interface HaloPreviousValuesPromise
  extends Promise<HaloPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  tier: () => Promise<String>;
}

export interface HaloPreviousValuesSubscription
  extends Promise<AsyncIterator<HaloPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  tier: () => Promise<AsyncIterator<String>>;
}

export interface CircleEdge {
  node: Circle;
  cursor: String;
}

export interface CircleEdgePromise extends Promise<CircleEdge>, Fragmentable {
  node: <T = CirclePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CircleEdgeSubscription
  extends Promise<AsyncIterator<CircleEdge>>,
    Fragmentable {
  node: <T = CircleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CircleInvite {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleInvitePromise
  extends Promise<CircleInvite>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  circle: <T = CirclePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CircleInviteSubscription
  extends Promise<AsyncIterator<CircleInvite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  circle: <T = CircleSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface CircleInviteNullablePromise
  extends Promise<CircleInvite | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  circle: <T = CirclePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CharityAuthHistoryConnection {
  pageInfo: PageInfo;
  edges: CharityAuthHistoryEdge[];
}

export interface CharityAuthHistoryConnectionPromise
  extends Promise<CharityAuthHistoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharityAuthHistoryEdge>>() => T;
  aggregate: <T = AggregateCharityAuthHistoryPromise>() => T;
}

export interface CharityAuthHistoryConnectionSubscription
  extends Promise<AsyncIterator<CharityAuthHistoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<CharityAuthHistoryEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateCharityAuthHistorySubscription>() => T;
}

export interface IdentitySubscriptionPayload {
  mutation: MutationType;
  node: Identity;
  updatedFields: String[];
  previousValues: IdentityPreviousValues;
}

export interface IdentitySubscriptionPayloadPromise
  extends Promise<IdentitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IdentityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IdentityPreviousValuesPromise>() => T;
}

export interface IdentitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IdentitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IdentitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IdentityPreviousValuesSubscription>() => T;
}

export interface AggregateCharge {
  count: Int;
}

export interface AggregateChargePromise
  extends Promise<AggregateCharge>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChargeSubscription
  extends Promise<AsyncIterator<AggregateCharge>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface IdentityPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  provider: IdentityProvider;
  providerID: String;
}

export interface IdentityPreviousValuesPromise
  extends Promise<IdentityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  provider: () => Promise<IdentityProvider>;
  providerID: () => Promise<String>;
}

export interface IdentityPreviousValuesSubscription
  extends Promise<AsyncIterator<IdentityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  provider: () => Promise<AsyncIterator<IdentityProvider>>;
  providerID: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransfer {
  count: Int;
}

export interface AggregateTransferPromise
  extends Promise<AggregateTransfer>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransferSubscription
  extends Promise<AsyncIterator<AggregateTransfer>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Circle {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  name: String;
  open: Boolean;
}

export interface CirclePromise extends Promise<Circle>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  open: () => Promise<Boolean>;
  joinRequests: <T = FragmentableArray<CircleJoinRequest>>(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invites: <T = FragmentableArray<CircleInvite>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserPromise>() => T;
}

export interface CircleSubscription
  extends Promise<AsyncIterator<Circle>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
  joinRequests: <
    T = Promise<AsyncIterator<CircleJoinRequestSubscription>>
  >(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invites: <T = Promise<AsyncIterator<CircleInviteSubscription>>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserSubscription>() => T;
}

export interface CircleNullablePromise
  extends Promise<Circle | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  open: () => Promise<Boolean>;
  joinRequests: <T = FragmentableArray<CircleJoinRequest>>(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invites: <T = FragmentableArray<CircleInvite>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserPromise>() => T;
}

export interface IdentityConnection {
  pageInfo: PageInfo;
  edges: IdentityEdge[];
}

export interface IdentityConnectionPromise
  extends Promise<IdentityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IdentityEdge>>() => T;
  aggregate: <T = AggregateIdentityPromise>() => T;
}

export interface IdentityConnectionSubscription
  extends Promise<AsyncIterator<IdentityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IdentityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIdentitySubscription>() => T;
}

export interface LoopSubscriptionPayload {
  mutation: MutationType;
  node: Loop;
  updatedFields: String[];
  previousValues: LoopPreviousValues;
}

export interface LoopSubscriptionPayloadPromise
  extends Promise<LoopSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LoopPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoopPreviousValuesPromise>() => T;
}

export interface LoopSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoopSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoopSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoopPreviousValuesSubscription>() => T;
}

export interface AggregateDot {
  count: Int;
}

export interface AggregateDotPromise
  extends Promise<AggregateDot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDotSubscription
  extends Promise<AsyncIterator<AggregateDot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoopPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  count: Int;
}

export interface LoopPreviousValuesPromise
  extends Promise<LoopPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  count: () => Promise<Int>;
}

export interface LoopPreviousValuesSubscription
  extends Promise<AsyncIterator<LoopPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CircleInviteConnection {
  pageInfo: PageInfo;
  edges: CircleInviteEdge[];
}

export interface CircleInviteConnectionPromise
  extends Promise<CircleInviteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CircleInviteEdge>>() => T;
  aggregate: <T = AggregateCircleInvitePromise>() => T;
}

export interface CircleInviteConnectionSubscription
  extends Promise<AsyncIterator<CircleInviteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CircleInviteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCircleInviteSubscription>() => T;
}

export interface CircleJoinRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleJoinRequestPromise
  extends Promise<CircleJoinRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  circle: <T = CirclePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CircleJoinRequestSubscription
  extends Promise<AsyncIterator<CircleJoinRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  circle: <T = CircleSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface CircleJoinRequestNullablePromise
  extends Promise<CircleJoinRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  circle: <T = CirclePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CharityEdge {
  node: Charity;
  cursor: String;
}

export interface CharityEdgePromise extends Promise<CharityEdge>, Fragmentable {
  node: <T = CharityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharityEdgeSubscription
  extends Promise<AsyncIterator<CharityEdge>>,
    Fragmentable {
  node: <T = CharitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface LoopEdge {
  node: Loop;
  cursor: String;
}

export interface LoopEdgePromise extends Promise<LoopEdge>, Fragmentable {
  node: <T = LoopPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoopEdgeSubscription
  extends Promise<AsyncIterator<LoopEdge>>,
    Fragmentable {
  node: <T = LoopSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  email: () => Promise<String>;
  nameFirst: () => Promise<String>;
  nameLast: () => Promise<String>;
  picture: () => Promise<String>;
  securityToken: () => Promise<Int>;
  username: () => Promise<String>;
  circleJoinRequests: <T = FragmentableArray<CircleJoinRequest>>(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circleInvites: <T = FragmentableArray<CircleInvite>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circles: <T = FragmentableArray<Circle>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circlesOwned: <T = FragmentableArray<Circle>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dots: <T = FragmentableArray<Dot>>(args?: {
    where?: DotWhereInput;
    orderBy?: DotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followedCharities: <T = FragmentableArray<Charity>>(args?: {
    where?: CharityWhereInput;
    orderBy?: CharityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = FragmentableArray<Charge>>(args?: {
    where?: ChargeWhereInput;
    orderBy?: ChargeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  halos: <T = FragmentableArray<Halo>>(args?: {
    where?: HaloWhereInput;
    orderBy?: HaloOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  identity: <T = IdentityPromise>() => T;
  loops: <T = FragmentableArray<Loop>>(args?: {
    where?: LoopWhereInput;
    orderBy?: LoopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preferences: <T = PreferencesPromise>() => T;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bio: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameLast: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  securityToken: () => Promise<AsyncIterator<Int>>;
  username: () => Promise<AsyncIterator<String>>;
  circleJoinRequests: <
    T = Promise<AsyncIterator<CircleJoinRequestSubscription>>
  >(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circleInvites: <T = Promise<AsyncIterator<CircleInviteSubscription>>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circles: <T = Promise<AsyncIterator<CircleSubscription>>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circlesOwned: <T = Promise<AsyncIterator<CircleSubscription>>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dots: <T = Promise<AsyncIterator<DotSubscription>>>(args?: {
    where?: DotWhereInput;
    orderBy?: DotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followedCharities: <T = Promise<AsyncIterator<CharitySubscription>>>(args?: {
    where?: CharityWhereInput;
    orderBy?: CharityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = Promise<AsyncIterator<ChargeSubscription>>>(args?: {
    where?: ChargeWhereInput;
    orderBy?: ChargeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  halos: <T = Promise<AsyncIterator<HaloSubscription>>>(args?: {
    where?: HaloWhereInput;
    orderBy?: HaloOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  identity: <T = IdentitySubscription>() => T;
  loops: <T = Promise<AsyncIterator<LoopSubscription>>>(args?: {
    where?: LoopWhereInput;
    orderBy?: LoopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preferences: <T = PreferencesSubscription>() => T;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  email: () => Promise<String>;
  nameFirst: () => Promise<String>;
  nameLast: () => Promise<String>;
  picture: () => Promise<String>;
  securityToken: () => Promise<Int>;
  username: () => Promise<String>;
  circleJoinRequests: <T = FragmentableArray<CircleJoinRequest>>(args?: {
    where?: CircleJoinRequestWhereInput;
    orderBy?: CircleJoinRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circleInvites: <T = FragmentableArray<CircleInvite>>(args?: {
    where?: CircleInviteWhereInput;
    orderBy?: CircleInviteOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circles: <T = FragmentableArray<Circle>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  circlesOwned: <T = FragmentableArray<Circle>>(args?: {
    where?: CircleWhereInput;
    orderBy?: CircleOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  dots: <T = FragmentableArray<Dot>>(args?: {
    where?: DotWhereInput;
    orderBy?: DotOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  followedCharities: <T = FragmentableArray<Charity>>(args?: {
    where?: CharityWhereInput;
    orderBy?: CharityOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  funds: <T = FragmentableArray<Charge>>(args?: {
    where?: ChargeWhereInput;
    orderBy?: ChargeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  halos: <T = FragmentableArray<Halo>>(args?: {
    where?: HaloWhereInput;
    orderBy?: HaloOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  identity: <T = IdentityPromise>() => T;
  loops: <T = FragmentableArray<Loop>>(args?: {
    where?: LoopWhereInput;
    orderBy?: LoopOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  preferences: <T = PreferencesPromise>() => T;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PreferencesPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  allowDonationEmails: Boolean;
  publicProfile: Boolean;
}

export interface PreferencesPreviousValuesPromise
  extends Promise<PreferencesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  allowDonationEmails: () => Promise<Boolean>;
  publicProfile: () => Promise<Boolean>;
}

export interface PreferencesPreviousValuesSubscription
  extends Promise<AsyncIterator<PreferencesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  allowDonationEmails: () => Promise<AsyncIterator<Boolean>>;
  publicProfile: () => Promise<AsyncIterator<Boolean>>;
}

export interface PreferencesSubscriptionPayload {
  mutation: MutationType;
  node: Preferences;
  updatedFields: String[];
  previousValues: PreferencesPreviousValues;
}

export interface PreferencesSubscriptionPayloadPromise
  extends Promise<PreferencesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PreferencesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PreferencesPreviousValuesPromise>() => T;
}

export interface PreferencesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PreferencesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PreferencesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PreferencesPreviousValuesSubscription>() => T;
}

export interface HaloConnection {
  pageInfo: PageInfo;
  edges: HaloEdge[];
}

export interface HaloConnectionPromise
  extends Promise<HaloConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HaloEdge>>() => T;
  aggregate: <T = AggregateHaloPromise>() => T;
}

export interface HaloConnectionSubscription
  extends Promise<AsyncIterator<HaloConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HaloEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHaloSubscription>() => T;
}

export interface TransferPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amount: Int;
  chargeBalance: Int;
  firstOfBatch: Boolean;
  transferID: String;
}

export interface TransferPreviousValuesPromise
  extends Promise<TransferPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  chargeBalance: () => Promise<Int>;
  firstOfBatch: () => Promise<Boolean>;
  transferID: () => Promise<String>;
}

export interface TransferPreviousValuesSubscription
  extends Promise<AsyncIterator<TransferPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  chargeBalance: () => Promise<AsyncIterator<Int>>;
  firstOfBatch: () => Promise<AsyncIterator<Boolean>>;
  transferID: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCharityAuthHistory {
  count: Int;
}

export interface AggregateCharityAuthHistoryPromise
  extends Promise<AggregateCharityAuthHistory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharityAuthHistorySubscription
  extends Promise<AsyncIterator<AggregateCharityAuthHistory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CircleJoinRequestEdge {
  node: CircleJoinRequest;
  cursor: String;
}

export interface CircleJoinRequestEdgePromise
  extends Promise<CircleJoinRequestEdge>,
    Fragmentable {
  node: <T = CircleJoinRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CircleJoinRequestEdgeSubscription
  extends Promise<AsyncIterator<CircleJoinRequestEdge>>,
    Fragmentable {
  node: <T = CircleJoinRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Dot",
    embedded: false
  },
  {
    name: "Halo",
    embedded: false
  },
  {
    name: "Identity",
    embedded: false
  },
  {
    name: "Loop",
    embedded: false
  },
  {
    name: "Preferences",
    embedded: false
  },
  {
    name: "Circle",
    embedded: false
  },
  {
    name: "CircleJoinRequest",
    embedded: false
  },
  {
    name: "CircleInvite",
    embedded: false
  },
  {
    name: "Charity",
    embedded: false
  },
  {
    name: "CharityAuthHistory",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Transfer",
    embedded: false
  },
  {
    name: "Charge",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  },
  {
    name: "IdentityProvider",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
