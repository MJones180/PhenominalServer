// Code generated by Prisma (prisma@1.27.4). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  charity: (where?: CharityWhereInput) => Promise<boolean>;
  circle: (where?: CircleWhereInput) => Promise<boolean>;
  circleInvite: (where?: CircleInviteWhereInput) => Promise<boolean>;
  circleJoinRequest: (where?: CircleJoinRequestWhereInput) => Promise<boolean>;
  dot: (where?: DotWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  halo: (where?: HaloWhereInput) => Promise<boolean>;
  identity: (where?: IdentityWhereInput) => Promise<boolean>;
  loop: (where?: LoopWhereInput) => Promise<boolean>;
  preferences: (where?: PreferencesWhereInput) => Promise<boolean>;
  specialFundraiser: (where?: SpecialFundraiserWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  charity: (where: CharityWhereUniqueInput) => CharityPromise;
  charities: (
    args?: {
      where?: CharityWhereInput;
      orderBy?: CharityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Charity>;
  charitiesConnection: (
    args?: {
      where?: CharityWhereInput;
      orderBy?: CharityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CharityConnectionPromise;
  circle: (where: CircleWhereUniqueInput) => CirclePromise;
  circles: (
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Circle>;
  circlesConnection: (
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CircleConnectionPromise;
  circleInvite: (where: CircleInviteWhereUniqueInput) => CircleInvitePromise;
  circleInvites: (
    args?: {
      where?: CircleInviteWhereInput;
      orderBy?: CircleInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CircleInvite>;
  circleInvitesConnection: (
    args?: {
      where?: CircleInviteWhereInput;
      orderBy?: CircleInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CircleInviteConnectionPromise;
  circleJoinRequest: (
    where: CircleJoinRequestWhereUniqueInput
  ) => CircleJoinRequestPromise;
  circleJoinRequests: (
    args?: {
      where?: CircleJoinRequestWhereInput;
      orderBy?: CircleJoinRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<CircleJoinRequest>;
  circleJoinRequestsConnection: (
    args?: {
      where?: CircleJoinRequestWhereInput;
      orderBy?: CircleJoinRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CircleJoinRequestConnectionPromise;
  dot: (where: DotWhereUniqueInput) => DotPromise;
  dots: (
    args?: {
      where?: DotWhereInput;
      orderBy?: DotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Dot>;
  dotsConnection: (
    args?: {
      where?: DotWhereInput;
      orderBy?: DotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => DotConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventPromise;
  events: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Event>;
  eventsConnection: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EventConnectionPromise;
  halo: (where: HaloWhereUniqueInput) => HaloPromise;
  haloes: (
    args?: {
      where?: HaloWhereInput;
      orderBy?: HaloOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Halo>;
  haloesConnection: (
    args?: {
      where?: HaloWhereInput;
      orderBy?: HaloOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => HaloConnectionPromise;
  identity: (where: IdentityWhereUniqueInput) => IdentityPromise;
  identities: (
    args?: {
      where?: IdentityWhereInput;
      orderBy?: IdentityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Identity>;
  identitiesConnection: (
    args?: {
      where?: IdentityWhereInput;
      orderBy?: IdentityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => IdentityConnectionPromise;
  loop: (where: LoopWhereUniqueInput) => LoopPromise;
  loops: (
    args?: {
      where?: LoopWhereInput;
      orderBy?: LoopOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Loop>;
  loopsConnection: (
    args?: {
      where?: LoopWhereInput;
      orderBy?: LoopOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => LoopConnectionPromise;
  preferences: (where: PreferencesWhereUniqueInput) => PreferencesPromise;
  preferenceses: (
    args?: {
      where?: PreferencesWhereInput;
      orderBy?: PreferencesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Preferences>;
  preferencesesConnection: (
    args?: {
      where?: PreferencesWhereInput;
      orderBy?: PreferencesOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PreferencesConnectionPromise;
  specialFundraiser: (
    where: SpecialFundraiserWhereUniqueInput
  ) => SpecialFundraiserPromise;
  specialFundraisers: (
    args?: {
      where?: SpecialFundraiserWhereInput;
      orderBy?: SpecialFundraiserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<SpecialFundraiser>;
  specialFundraisersConnection: (
    args?: {
      where?: SpecialFundraiserWhereInput;
      orderBy?: SpecialFundraiserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => SpecialFundraiserConnectionPromise;
  transaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  transactions: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Transaction>;
  transactionsConnection: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransactionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createCharity: (data: CharityCreateInput) => CharityPromise;
  updateCharity: (
    args: { data: CharityUpdateInput; where: CharityWhereUniqueInput }
  ) => CharityPromise;
  updateManyCharities: (
    args: { data: CharityUpdateManyMutationInput; where?: CharityWhereInput }
  ) => BatchPayloadPromise;
  upsertCharity: (
    args: {
      where: CharityWhereUniqueInput;
      create: CharityCreateInput;
      update: CharityUpdateInput;
    }
  ) => CharityPromise;
  deleteCharity: (where: CharityWhereUniqueInput) => CharityPromise;
  deleteManyCharities: (where?: CharityWhereInput) => BatchPayloadPromise;
  createCircle: (data: CircleCreateInput) => CirclePromise;
  updateCircle: (
    args: { data: CircleUpdateInput; where: CircleWhereUniqueInput }
  ) => CirclePromise;
  updateManyCircles: (
    args: { data: CircleUpdateManyMutationInput; where?: CircleWhereInput }
  ) => BatchPayloadPromise;
  upsertCircle: (
    args: {
      where: CircleWhereUniqueInput;
      create: CircleCreateInput;
      update: CircleUpdateInput;
    }
  ) => CirclePromise;
  deleteCircle: (where: CircleWhereUniqueInput) => CirclePromise;
  deleteManyCircles: (where?: CircleWhereInput) => BatchPayloadPromise;
  createCircleInvite: (data: CircleInviteCreateInput) => CircleInvitePromise;
  updateCircleInvite: (
    args: { data: CircleInviteUpdateInput; where: CircleInviteWhereUniqueInput }
  ) => CircleInvitePromise;
  upsertCircleInvite: (
    args: {
      where: CircleInviteWhereUniqueInput;
      create: CircleInviteCreateInput;
      update: CircleInviteUpdateInput;
    }
  ) => CircleInvitePromise;
  deleteCircleInvite: (
    where: CircleInviteWhereUniqueInput
  ) => CircleInvitePromise;
  deleteManyCircleInvites: (
    where?: CircleInviteWhereInput
  ) => BatchPayloadPromise;
  createCircleJoinRequest: (
    data: CircleJoinRequestCreateInput
  ) => CircleJoinRequestPromise;
  updateCircleJoinRequest: (
    args: {
      data: CircleJoinRequestUpdateInput;
      where: CircleJoinRequestWhereUniqueInput;
    }
  ) => CircleJoinRequestPromise;
  upsertCircleJoinRequest: (
    args: {
      where: CircleJoinRequestWhereUniqueInput;
      create: CircleJoinRequestCreateInput;
      update: CircleJoinRequestUpdateInput;
    }
  ) => CircleJoinRequestPromise;
  deleteCircleJoinRequest: (
    where: CircleJoinRequestWhereUniqueInput
  ) => CircleJoinRequestPromise;
  deleteManyCircleJoinRequests: (
    where?: CircleJoinRequestWhereInput
  ) => BatchPayloadPromise;
  createDot: (data: DotCreateInput) => DotPromise;
  updateDot: (
    args: { data: DotUpdateInput; where: DotWhereUniqueInput }
  ) => DotPromise;
  updateManyDots: (
    args: { data: DotUpdateManyMutationInput; where?: DotWhereInput }
  ) => BatchPayloadPromise;
  upsertDot: (
    args: {
      where: DotWhereUniqueInput;
      create: DotCreateInput;
      update: DotUpdateInput;
    }
  ) => DotPromise;
  deleteDot: (where: DotWhereUniqueInput) => DotPromise;
  deleteManyDots: (where?: DotWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (
    args: { data: EventUpdateInput; where: EventWhereUniqueInput }
  ) => EventPromise;
  updateManyEvents: (
    args: { data: EventUpdateManyMutationInput; where?: EventWhereInput }
  ) => BatchPayloadPromise;
  upsertEvent: (
    args: {
      where: EventWhereUniqueInput;
      create: EventCreateInput;
      update: EventUpdateInput;
    }
  ) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createHalo: (data: HaloCreateInput) => HaloPromise;
  updateHalo: (
    args: { data: HaloUpdateInput; where: HaloWhereUniqueInput }
  ) => HaloPromise;
  updateManyHaloes: (
    args: { data: HaloUpdateManyMutationInput; where?: HaloWhereInput }
  ) => BatchPayloadPromise;
  upsertHalo: (
    args: {
      where: HaloWhereUniqueInput;
      create: HaloCreateInput;
      update: HaloUpdateInput;
    }
  ) => HaloPromise;
  deleteHalo: (where: HaloWhereUniqueInput) => HaloPromise;
  deleteManyHaloes: (where?: HaloWhereInput) => BatchPayloadPromise;
  createIdentity: (data: IdentityCreateInput) => IdentityPromise;
  updateIdentity: (
    args: { data: IdentityUpdateInput; where: IdentityWhereUniqueInput }
  ) => IdentityPromise;
  updateManyIdentities: (
    args: { data: IdentityUpdateManyMutationInput; where?: IdentityWhereInput }
  ) => BatchPayloadPromise;
  upsertIdentity: (
    args: {
      where: IdentityWhereUniqueInput;
      create: IdentityCreateInput;
      update: IdentityUpdateInput;
    }
  ) => IdentityPromise;
  deleteIdentity: (where: IdentityWhereUniqueInput) => IdentityPromise;
  deleteManyIdentities: (where?: IdentityWhereInput) => BatchPayloadPromise;
  createLoop: (data: LoopCreateInput) => LoopPromise;
  updateLoop: (
    args: { data: LoopUpdateInput; where: LoopWhereUniqueInput }
  ) => LoopPromise;
  updateManyLoops: (
    args: { data: LoopUpdateManyMutationInput; where?: LoopWhereInput }
  ) => BatchPayloadPromise;
  upsertLoop: (
    args: {
      where: LoopWhereUniqueInput;
      create: LoopCreateInput;
      update: LoopUpdateInput;
    }
  ) => LoopPromise;
  deleteLoop: (where: LoopWhereUniqueInput) => LoopPromise;
  deleteManyLoops: (where?: LoopWhereInput) => BatchPayloadPromise;
  createPreferences: (data: PreferencesCreateInput) => PreferencesPromise;
  updatePreferences: (
    args: { data: PreferencesUpdateInput; where: PreferencesWhereUniqueInput }
  ) => PreferencesPromise;
  updateManyPreferenceses: (
    args: {
      data: PreferencesUpdateManyMutationInput;
      where?: PreferencesWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertPreferences: (
    args: {
      where: PreferencesWhereUniqueInput;
      create: PreferencesCreateInput;
      update: PreferencesUpdateInput;
    }
  ) => PreferencesPromise;
  deletePreferences: (where: PreferencesWhereUniqueInput) => PreferencesPromise;
  deleteManyPreferenceses: (
    where?: PreferencesWhereInput
  ) => BatchPayloadPromise;
  createSpecialFundraiser: (
    data: SpecialFundraiserCreateInput
  ) => SpecialFundraiserPromise;
  updateSpecialFundraiser: (
    args: {
      data: SpecialFundraiserUpdateInput;
      where: SpecialFundraiserWhereUniqueInput;
    }
  ) => SpecialFundraiserPromise;
  updateManySpecialFundraisers: (
    args: {
      data: SpecialFundraiserUpdateManyMutationInput;
      where?: SpecialFundraiserWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertSpecialFundraiser: (
    args: {
      where: SpecialFundraiserWhereUniqueInput;
      create: SpecialFundraiserCreateInput;
      update: SpecialFundraiserUpdateInput;
    }
  ) => SpecialFundraiserPromise;
  deleteSpecialFundraiser: (
    where: SpecialFundraiserWhereUniqueInput
  ) => SpecialFundraiserPromise;
  deleteManySpecialFundraisers: (
    where?: SpecialFundraiserWhereInput
  ) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (
    args: { data: TransactionUpdateInput; where: TransactionWhereUniqueInput }
  ) => TransactionPromise;
  updateManyTransactions: (
    args: {
      data: TransactionUpdateManyMutationInput;
      where?: TransactionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTransaction: (
    args: {
      where: TransactionWhereUniqueInput;
      create: TransactionCreateInput;
      update: TransactionUpdateInput;
    }
  ) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  charity: (
    where?: CharitySubscriptionWhereInput
  ) => CharitySubscriptionPayloadSubscription;
  circle: (
    where?: CircleSubscriptionWhereInput
  ) => CircleSubscriptionPayloadSubscription;
  circleInvite: (
    where?: CircleInviteSubscriptionWhereInput
  ) => CircleInviteSubscriptionPayloadSubscription;
  circleJoinRequest: (
    where?: CircleJoinRequestSubscriptionWhereInput
  ) => CircleJoinRequestSubscriptionPayloadSubscription;
  dot: (
    where?: DotSubscriptionWhereInput
  ) => DotSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  halo: (
    where?: HaloSubscriptionWhereInput
  ) => HaloSubscriptionPayloadSubscription;
  identity: (
    where?: IdentitySubscriptionWhereInput
  ) => IdentitySubscriptionPayloadSubscription;
  loop: (
    where?: LoopSubscriptionWhereInput
  ) => LoopSubscriptionPayloadSubscription;
  preferences: (
    where?: PreferencesSubscriptionWhereInput
  ) => PreferencesSubscriptionPayloadSubscription;
  specialFundraiser: (
    where?: SpecialFundraiserSubscriptionWhereInput
  ) => SpecialFundraiserSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type DotOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "action_ASC"
  | "action_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "total_ASC"
  | "total_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type IdentityProvider = "FACEBOOK" | "GOOGLE";

export type CircleOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "open_ASC"
  | "open_DESC";

export type SpecialFundraiserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "email_ASC"
  | "email_DESC"
  | "nameFirst_ASC"
  | "nameFirst_DESC"
  | "nameLast_ASC"
  | "nameLast_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "securityToken_ASC"
  | "securityToken_DESC"
  | "username_ASC"
  | "username_DESC";

export type IdentityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "provider_ASC"
  | "provider_DESC"
  | "providerID_ASC"
  | "providerID_DESC";

export type CircleInviteOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type HaloOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "key_ASC"
  | "key_DESC"
  | "tier_ASC"
  | "tier_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransactionType = "DONATION" | "ADD_FUNDS";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "endDate_ASC"
  | "endDate_DESC"
  | "goal_ASC"
  | "goal_DESC"
  | "multiplier_ASC"
  | "multiplier_DESC"
  | "sponsorName_ASC"
  | "sponsorName_DESC"
  | "sponsorWebsite_ASC"
  | "sponsorWebsite_DESC"
  | "startDate_ASC"
  | "startDate_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "balance_ASC"
  | "balance_DESC"
  | "key_ASC"
  | "key_DESC"
  | "stripeID_ASC"
  | "stripeID_DESC"
  | "type_ASC"
  | "type_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CircleJoinRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CharityOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "acronym_ASC"
  | "acronym_DESC"
  | "bannerCredit_ASC"
  | "bannerCredit_DESC"
  | "ein_ASC"
  | "ein_DESC"
  | "expensesAdministrative_ASC"
  | "expensesAdministrative_DESC"
  | "expensesFundraising_ASC"
  | "expensesFundraising_DESC"
  | "expensesOther_ASC"
  | "expensesOther_DESC"
  | "expensesProgram_ASC"
  | "expensesProgram_DESC"
  | "expensesUpdated_ASC"
  | "expensesUpdated_DESC"
  | "location_ASC"
  | "location_DESC"
  | "mission_ASC"
  | "mission_DESC"
  | "name_ASC"
  | "name_DESC"
  | "phoneNumber_ASC"
  | "phoneNumber_DESC"
  | "website_ASC"
  | "website_DESC";

export type LoopOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "count_ASC"
  | "count_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PreferencesOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "allowDonationEmails_ASC"
  | "allowDonationEmails_DESC"
  | "publicProfile_ASC"
  | "publicProfile_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface UserUpdateWithWhereUniqueWithoutCirclesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutCirclesDataInput;
}

export type CharityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  ein?: String;
}>;

export interface DotUpdateManyWithoutUserInput {
  create?: DotCreateWithoutUserInput[] | DotCreateWithoutUserInput;
  delete?: DotWhereUniqueInput[] | DotWhereUniqueInput;
  connect?: DotWhereUniqueInput[] | DotWhereUniqueInput;
  set?: DotWhereUniqueInput[] | DotWhereUniqueInput;
  disconnect?: DotWhereUniqueInput[] | DotWhereUniqueInput;
  update?:
    | DotUpdateWithWhereUniqueWithoutUserInput[]
    | DotUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | DotUpsertWithWhereUniqueWithoutUserInput[]
    | DotUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: DotScalarWhereInput[] | DotScalarWhereInput;
  updateMany?:
    | DotUpdateManyWithWhereNestedInput[]
    | DotUpdateManyWithWhereNestedInput;
}

export interface LoopWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  count?: Int;
  count_not?: Int;
  count_in?: Int[] | Int;
  count_not_in?: Int[] | Int;
  count_lt?: Int;
  count_lte?: Int;
  count_gt?: Int;
  count_gte?: Int;
  event?: EventWhereInput;
  user?: UserWhereInput;
  AND?: LoopWhereInput[] | LoopWhereInput;
  OR?: LoopWhereInput[] | LoopWhereInput;
  NOT?: LoopWhereInput[] | LoopWhereInput;
}

export interface DotUpdateWithWhereUniqueWithoutUserInput {
  where: DotWhereUniqueInput;
  data: DotUpdateWithoutUserDataInput;
}

export interface TransactionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  balance?: Int;
  balance_not?: Int;
  balance_in?: Int[] | Int;
  balance_not_in?: Int[] | Int;
  balance_lt?: Int;
  balance_lte?: Int;
  balance_gt?: Int;
  balance_gte?: Int;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  stripeID?: String;
  stripeID_not?: String;
  stripeID_in?: String[] | String;
  stripeID_not_in?: String[] | String;
  stripeID_lt?: String;
  stripeID_lte?: String;
  stripeID_gt?: String;
  stripeID_gte?: String;
  stripeID_contains?: String;
  stripeID_not_contains?: String;
  stripeID_starts_with?: String;
  stripeID_not_starts_with?: String;
  stripeID_ends_with?: String;
  stripeID_not_ends_with?: String;
  type?: TransactionType;
  type_not?: TransactionType;
  type_in?: TransactionType[] | TransactionType;
  type_not_in?: TransactionType[] | TransactionType;
  event?: EventWhereInput;
  user?: UserWhereInput;
  AND?: TransactionWhereInput[] | TransactionWhereInput;
  OR?: TransactionWhereInput[] | TransactionWhereInput;
  NOT?: TransactionWhereInput[] | TransactionWhereInput;
}

export interface DotUpdateWithoutUserDataInput {
  action?: String;
  amount?: Int;
  total?: Int;
}

export interface SpecialFundraiserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  event?: EventWhereInput;
  AND?: SpecialFundraiserWhereInput[] | SpecialFundraiserWhereInput;
  OR?: SpecialFundraiserWhereInput[] | SpecialFundraiserWhereInput;
  NOT?: SpecialFundraiserWhereInput[] | SpecialFundraiserWhereInput;
}

export interface SpecialFundraiserUpsertWithoutEventInput {
  update: SpecialFundraiserUpdateWithoutEventDataInput;
  create: SpecialFundraiserCreateWithoutEventInput;
}

export interface EventUpdateManyMutationInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
}

export interface TransactionUpdateManyWithoutEventInput {
  create?:
    | TransactionCreateWithoutEventInput[]
    | TransactionCreateWithoutEventInput;
  delete?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  set?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  disconnect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  update?:
    | TransactionUpdateWithWhereUniqueWithoutEventInput[]
    | TransactionUpdateWithWhereUniqueWithoutEventInput;
  upsert?:
    | TransactionUpsertWithWhereUniqueWithoutEventInput[]
    | TransactionUpsertWithWhereUniqueWithoutEventInput;
  deleteMany?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  updateMany?:
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput;
}

export interface DotUpsertWithWhereUniqueWithoutUserInput {
  where: DotWhereUniqueInput;
  update: DotUpdateWithoutUserDataInput;
  create: DotCreateWithoutUserInput;
}

export interface TransactionUpdateWithWhereUniqueWithoutEventInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutEventDataInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface TransactionUpdateWithoutEventDataInput {
  amount?: Int;
  balance?: Int;
  key?: String;
  stripeID?: String;
  type?: TransactionType;
  user?: UserUpdateOneWithoutTransactionsInput;
}

export interface CircleInviteWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  circle?: CircleWhereInput;
  user?: UserWhereInput;
  AND?: CircleInviteWhereInput[] | CircleInviteWhereInput;
  OR?: CircleInviteWhereInput[] | CircleInviteWhereInput;
  NOT?: CircleInviteWhereInput[] | CircleInviteWhereInput;
}

export interface UserUpdateOneWithoutTransactionsInput {
  create?: UserCreateWithoutTransactionsInput;
  update?: UserUpdateWithoutTransactionsDataInput;
  upsert?: UserUpsertWithoutTransactionsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface PreferencesSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PreferencesWhereInput;
  AND?: PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput;
  OR?: PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput;
  NOT?: PreferencesSubscriptionWhereInput[] | PreferencesSubscriptionWhereInput;
}

export interface UserUpdateWithoutTransactionsDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
}

export interface IdentitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: IdentityWhereInput;
  AND?: IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput;
  OR?: IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput;
  NOT?: IdentitySubscriptionWhereInput[] | IdentitySubscriptionWhereInput;
}

export interface CircleJoinRequestUpdateManyWithoutUserInput {
  create?:
    | CircleJoinRequestCreateWithoutUserInput[]
    | CircleJoinRequestCreateWithoutUserInput;
  delete?:
    | CircleJoinRequestWhereUniqueInput[]
    | CircleJoinRequestWhereUniqueInput;
  connect?:
    | CircleJoinRequestWhereUniqueInput[]
    | CircleJoinRequestWhereUniqueInput;
  set?: CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput;
  disconnect?:
    | CircleJoinRequestWhereUniqueInput[]
    | CircleJoinRequestWhereUniqueInput;
  update?:
    | CircleJoinRequestUpdateWithWhereUniqueWithoutUserInput[]
    | CircleJoinRequestUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | CircleJoinRequestUpsertWithWhereUniqueWithoutUserInput[]
    | CircleJoinRequestUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?:
    | CircleJoinRequestScalarWhereInput[]
    | CircleJoinRequestScalarWhereInput;
}

export interface CircleJoinRequestWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  circle?: CircleWhereInput;
  user?: UserWhereInput;
  AND?: CircleJoinRequestWhereInput[] | CircleJoinRequestWhereInput;
  OR?: CircleJoinRequestWhereInput[] | CircleJoinRequestWhereInput;
  NOT?: CircleJoinRequestWhereInput[] | CircleJoinRequestWhereInput;
}

export interface CircleJoinRequestUpdateWithWhereUniqueWithoutUserInput {
  where: CircleJoinRequestWhereUniqueInput;
  data: CircleJoinRequestUpdateWithoutUserDataInput;
}

export interface HaloSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: HaloWhereInput;
  AND?: HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput;
  OR?: HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput;
  NOT?: HaloSubscriptionWhereInput[] | HaloSubscriptionWhereInput;
}

export interface CircleJoinRequestUpdateWithoutUserDataInput {
  circle?: CircleUpdateOneRequiredWithoutJoinRequestsInput;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EventWhereInput;
  AND?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  OR?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  NOT?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
}

export interface CircleUpdateOneRequiredWithoutJoinRequestsInput {
  create?: CircleCreateWithoutJoinRequestsInput;
  update?: CircleUpdateWithoutJoinRequestsDataInput;
  upsert?: CircleUpsertWithoutJoinRequestsInput;
  connect?: CircleWhereUniqueInput;
}

export interface CircleJoinRequestSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CircleJoinRequestWhereInput;
  AND?:
    | CircleJoinRequestSubscriptionWhereInput[]
    | CircleJoinRequestSubscriptionWhereInput;
  OR?:
    | CircleJoinRequestSubscriptionWhereInput[]
    | CircleJoinRequestSubscriptionWhereInput;
  NOT?:
    | CircleJoinRequestSubscriptionWhereInput[]
    | CircleJoinRequestSubscriptionWhereInput;
}

export interface CircleUpdateWithoutJoinRequestsDataInput {
  description?: String;
  name?: String;
  open?: Boolean;
  invites?: CircleInviteUpdateManyWithoutCircleInput;
  members?: UserUpdateManyWithoutCirclesInput;
  owner?: UserUpdateOneRequiredWithoutCirclesOwnedInput;
}

export interface CircleInviteSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CircleInviteWhereInput;
  AND?:
    | CircleInviteSubscriptionWhereInput[]
    | CircleInviteSubscriptionWhereInput;
  OR?:
    | CircleInviteSubscriptionWhereInput[]
    | CircleInviteSubscriptionWhereInput;
  NOT?:
    | CircleInviteSubscriptionWhereInput[]
    | CircleInviteSubscriptionWhereInput;
}

export interface CircleInviteUpdateManyWithoutCircleInput {
  create?:
    | CircleInviteCreateWithoutCircleInput[]
    | CircleInviteCreateWithoutCircleInput;
  delete?: CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput;
  connect?: CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput;
  set?: CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput;
  disconnect?: CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput;
  update?:
    | CircleInviteUpdateWithWhereUniqueWithoutCircleInput[]
    | CircleInviteUpdateWithWhereUniqueWithoutCircleInput;
  upsert?:
    | CircleInviteUpsertWithWhereUniqueWithoutCircleInput[]
    | CircleInviteUpsertWithWhereUniqueWithoutCircleInput;
  deleteMany?: CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput;
}

export interface CharitySubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CharityWhereInput;
  AND?: CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput;
  OR?: CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput;
  NOT?: CharitySubscriptionWhereInput[] | CharitySubscriptionWhereInput;
}

export interface CircleInviteUpdateWithWhereUniqueWithoutCircleInput {
  where: CircleInviteWhereUniqueInput;
  data: CircleInviteUpdateWithoutCircleDataInput;
}

export interface UserUpdateInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface CircleInviteUpdateWithoutCircleDataInput {
  user?: UserUpdateOneRequiredWithoutCircleInvitesInput;
}

export type CircleWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  name?: String;
}>;

export interface UserUpdateOneRequiredWithoutCircleInvitesInput {
  create?: UserCreateWithoutCircleInvitesInput;
  update?: UserUpdateWithoutCircleInvitesDataInput;
  upsert?: UserUpsertWithoutCircleInvitesInput;
  connect?: UserWhereUniqueInput;
}

export interface TransactionUpdateInput {
  amount?: Int;
  balance?: Int;
  key?: String;
  stripeID?: String;
  type?: TransactionType;
  event?: EventUpdateOneWithoutDonationsInput;
  user?: UserUpdateOneWithoutTransactionsInput;
}

export interface UserUpdateWithoutCircleInvitesDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export type CircleInviteWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CircleUpdateManyWithoutMembersInput {
  create?: CircleCreateWithoutMembersInput[] | CircleCreateWithoutMembersInput;
  delete?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  connect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  set?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  disconnect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  update?:
    | CircleUpdateWithWhereUniqueWithoutMembersInput[]
    | CircleUpdateWithWhereUniqueWithoutMembersInput;
  upsert?:
    | CircleUpsertWithWhereUniqueWithoutMembersInput[]
    | CircleUpsertWithWhereUniqueWithoutMembersInput;
  deleteMany?: CircleScalarWhereInput[] | CircleScalarWhereInput;
  updateMany?:
    | CircleUpdateManyWithWhereNestedInput[]
    | CircleUpdateManyWithWhereNestedInput;
}

export interface EventUpsertWithoutSpecialFundraiserInput {
  update: EventUpdateWithoutSpecialFundraiserDataInput;
  create: EventCreateWithoutSpecialFundraiserInput;
}

export interface CircleUpdateWithWhereUniqueWithoutMembersInput {
  where: CircleWhereUniqueInput;
  data: CircleUpdateWithoutMembersDataInput;
}

export type CircleJoinRequestWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CircleUpdateWithoutMembersDataInput {
  description?: String;
  name?: String;
  open?: Boolean;
  joinRequests?: CircleJoinRequestUpdateManyWithoutCircleInput;
  invites?: CircleInviteUpdateManyWithoutCircleInput;
  owner?: UserUpdateOneRequiredWithoutCirclesOwnedInput;
}

export interface SpecialFundraiserUpdateInput {
  description?: String;
  name?: String;
  event?: EventUpdateOneRequiredWithoutSpecialFundraiserInput;
}

export interface CircleJoinRequestUpdateManyWithoutCircleInput {
  create?:
    | CircleJoinRequestCreateWithoutCircleInput[]
    | CircleJoinRequestCreateWithoutCircleInput;
  delete?:
    | CircleJoinRequestWhereUniqueInput[]
    | CircleJoinRequestWhereUniqueInput;
  connect?:
    | CircleJoinRequestWhereUniqueInput[]
    | CircleJoinRequestWhereUniqueInput;
  set?: CircleJoinRequestWhereUniqueInput[] | CircleJoinRequestWhereUniqueInput;
  disconnect?:
    | CircleJoinRequestWhereUniqueInput[]
    | CircleJoinRequestWhereUniqueInput;
  update?:
    | CircleJoinRequestUpdateWithWhereUniqueWithoutCircleInput[]
    | CircleJoinRequestUpdateWithWhereUniqueWithoutCircleInput;
  upsert?:
    | CircleJoinRequestUpsertWithWhereUniqueWithoutCircleInput[]
    | CircleJoinRequestUpsertWithWhereUniqueWithoutCircleInput;
  deleteMany?:
    | CircleJoinRequestScalarWhereInput[]
    | CircleJoinRequestScalarWhereInput;
}

export type DotWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CircleJoinRequestUpdateWithWhereUniqueWithoutCircleInput {
  where: CircleJoinRequestWhereUniqueInput;
  data: CircleJoinRequestUpdateWithoutCircleDataInput;
}

export interface SpecialFundraiserCreateInput {
  description: String;
  name: String;
  event: EventCreateOneWithoutSpecialFundraiserInput;
}

export interface CircleJoinRequestUpdateWithoutCircleDataInput {
  user?: UserUpdateOneRequiredWithoutCircleJoinRequestsInput;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneRequiredWithoutCircleJoinRequestsInput {
  create?: UserCreateWithoutCircleJoinRequestsInput;
  update?: UserUpdateWithoutCircleJoinRequestsDataInput;
  upsert?: UserUpsertWithoutCircleJoinRequestsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutPreferencesDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface UserUpdateWithoutCircleJoinRequestsDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export type HaloWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CircleInviteUpdateManyWithoutUserInput {
  create?:
    | CircleInviteCreateWithoutUserInput[]
    | CircleInviteCreateWithoutUserInput;
  delete?: CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput;
  connect?: CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput;
  set?: CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput;
  disconnect?: CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput;
  update?:
    | CircleInviteUpdateWithWhereUniqueWithoutUserInput[]
    | CircleInviteUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | CircleInviteUpsertWithWhereUniqueWithoutUserInput[]
    | CircleInviteUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput;
}

export interface UserCreateWithoutPreferencesInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface CircleInviteUpdateWithWhereUniqueWithoutUserInput {
  where: CircleInviteWhereUniqueInput;
  data: CircleInviteUpdateWithoutUserDataInput;
}

export type IdentityWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  providerID?: String;
}>;

export interface CircleInviteUpdateWithoutUserDataInput {
  circle?: CircleUpdateOneRequiredWithoutInvitesInput;
}

export interface LoopUpdateManyMutationInput {
  count?: Int;
}

export interface CircleUpdateOneRequiredWithoutInvitesInput {
  create?: CircleCreateWithoutInvitesInput;
  update?: CircleUpdateWithoutInvitesDataInput;
  upsert?: CircleUpsertWithoutInvitesInput;
  connect?: CircleWhereUniqueInput;
}

export interface UserUpdateWithoutLoopsDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface CircleUpdateWithoutInvitesDataInput {
  description?: String;
  name?: String;
  open?: Boolean;
  joinRequests?: CircleJoinRequestUpdateManyWithoutCircleInput;
  members?: UserUpdateManyWithoutCirclesInput;
  owner?: UserUpdateOneRequiredWithoutCirclesOwnedInput;
}

export interface UserUpdateOneRequiredWithoutLoopsInput {
  create?: UserCreateWithoutLoopsInput;
  update?: UserUpdateWithoutLoopsDataInput;
  upsert?: UserUpsertWithoutLoopsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateManyWithoutCirclesInput {
  create?: UserCreateWithoutCirclesInput[] | UserCreateWithoutCirclesInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutCirclesInput[]
    | UserUpdateWithWhereUniqueWithoutCirclesInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutCirclesInput[]
    | UserUpsertWithWhereUniqueWithoutCirclesInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserCreateWithoutLoopsInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface HaloUpdateInput {
  key?: String;
  tier?: String;
  user?: UserUpdateOneRequiredWithoutHalosInput;
}

export interface UserCreateOneWithoutLoopsInput {
  create?: UserCreateWithoutLoopsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCirclesDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface IdentityUpdateManyMutationInput {
  provider?: IdentityProvider;
  providerID?: String;
}

export interface CircleUpdateManyWithoutOwnerInput {
  create?: CircleCreateWithoutOwnerInput[] | CircleCreateWithoutOwnerInput;
  delete?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  connect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  set?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  disconnect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
  update?:
    | CircleUpdateWithWhereUniqueWithoutOwnerInput[]
    | CircleUpdateWithWhereUniqueWithoutOwnerInput;
  upsert?:
    | CircleUpsertWithWhereUniqueWithoutOwnerInput[]
    | CircleUpsertWithWhereUniqueWithoutOwnerInput;
  deleteMany?: CircleScalarWhereInput[] | CircleScalarWhereInput;
  updateMany?:
    | CircleUpdateManyWithWhereNestedInput[]
    | CircleUpdateManyWithWhereNestedInput;
}

export type SpecialFundraiserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CircleUpdateWithWhereUniqueWithoutOwnerInput {
  where: CircleWhereUniqueInput;
  data: CircleUpdateWithoutOwnerDataInput;
}

export interface UserUpdateOneRequiredWithoutIdentityInput {
  create?: UserCreateWithoutIdentityInput;
  update?: UserUpdateWithoutIdentityDataInput;
  upsert?: UserUpsertWithoutIdentityInput;
  connect?: UserWhereUniqueInput;
}

export interface CircleUpdateWithoutOwnerDataInput {
  description?: String;
  name?: String;
  open?: Boolean;
  joinRequests?: CircleJoinRequestUpdateManyWithoutCircleInput;
  invites?: CircleInviteUpdateManyWithoutCircleInput;
  members?: UserUpdateManyWithoutCirclesInput;
}

export interface UserCreateWithoutIdentityInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface CircleUpsertWithWhereUniqueWithoutOwnerInput {
  where: CircleWhereUniqueInput;
  update: CircleUpdateWithoutOwnerDataInput;
  create: CircleCreateWithoutOwnerInput;
}

export interface UserCreateOneWithoutIdentityInput {
  create?: UserCreateWithoutIdentityInput;
  connect?: UserWhereUniqueInput;
}

export interface CircleScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  open?: Boolean;
  open_not?: Boolean;
  AND?: CircleScalarWhereInput[] | CircleScalarWhereInput;
  OR?: CircleScalarWhereInput[] | CircleScalarWhereInput;
  NOT?: CircleScalarWhereInput[] | CircleScalarWhereInput;
}

export interface HaloUpdateManyMutationInput {
  key?: String;
  tier?: String;
}

export interface CircleUpdateManyWithWhereNestedInput {
  where: CircleScalarWhereInput;
  data: CircleUpdateManyDataInput;
}

export interface UserUpsertWithoutHalosInput {
  update: UserUpdateWithoutHalosDataInput;
  create: UserCreateWithoutHalosInput;
}

export interface CircleUpdateManyDataInput {
  description?: String;
  name?: String;
  open?: Boolean;
}

export interface UserUpdateOneRequiredWithoutHalosInput {
  create?: UserCreateWithoutHalosInput;
  update?: UserUpdateWithoutHalosDataInput;
  upsert?: UserUpsertWithoutHalosInput;
  connect?: UserWhereUniqueInput;
}

export interface PreferencesWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  allowDonationEmails?: Boolean;
  allowDonationEmails_not?: Boolean;
  publicProfile?: Boolean;
  publicProfile_not?: Boolean;
  user?: UserWhereInput;
  AND?: PreferencesWhereInput[] | PreferencesWhereInput;
  OR?: PreferencesWhereInput[] | PreferencesWhereInput;
  NOT?: PreferencesWhereInput[] | PreferencesWhereInput;
}

export interface CharityCreateInput {
  acronym?: String;
  bannerCredit?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
  events?: EventCreateManyWithoutCharityInput;
  followers?: UserCreateManyWithoutFollowedCharitiesInput;
}

export interface IdentityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  provider?: IdentityProvider;
  provider_not?: IdentityProvider;
  provider_in?: IdentityProvider[] | IdentityProvider;
  provider_not_in?: IdentityProvider[] | IdentityProvider;
  providerID?: String;
  providerID_not?: String;
  providerID_in?: String[] | String;
  providerID_not_in?: String[] | String;
  providerID_lt?: String;
  providerID_lte?: String;
  providerID_gt?: String;
  providerID_gte?: String;
  providerID_contains?: String;
  providerID_not_contains?: String;
  providerID_starts_with?: String;
  providerID_not_starts_with?: String;
  providerID_ends_with?: String;
  providerID_not_ends_with?: String;
  user?: UserWhereInput;
  AND?: IdentityWhereInput[] | IdentityWhereInput;
  OR?: IdentityWhereInput[] | IdentityWhereInput;
  NOT?: IdentityWhereInput[] | IdentityWhereInput;
}

export interface EventCreateWithoutCharityInput {
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeInput;
  specialFundraiser?: SpecialFundraiserCreateOneWithoutEventInput;
  donations?: TransactionCreateManyWithoutEventInput;
}

export interface HaloWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  tier?: String;
  tier_not?: String;
  tier_in?: String[] | String;
  tier_not_in?: String[] | String;
  tier_lt?: String;
  tier_lte?: String;
  tier_gt?: String;
  tier_gte?: String;
  tier_contains?: String;
  tier_not_contains?: String;
  tier_starts_with?: String;
  tier_not_starts_with?: String;
  tier_ends_with?: String;
  tier_not_ends_with?: String;
  user?: UserWhereInput;
  AND?: HaloWhereInput[] | HaloWhereInput;
  OR?: HaloWhereInput[] | HaloWhereInput;
  NOT?: HaloWhereInput[] | HaloWhereInput;
}

export interface SpecialFundraiserCreateWithoutEventInput {
  description: String;
  name: String;
}

export interface UserCreateWithoutHalosInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface TransactionCreateWithoutEventInput {
  amount: Int;
  balance: Int;
  key: String;
  stripeID?: String;
  type: TransactionType;
  user?: UserCreateOneWithoutTransactionsInput;
}

export interface DotScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  action?: String;
  action_not?: String;
  action_in?: String[] | String;
  action_not_in?: String[] | String;
  action_lt?: String;
  action_lte?: String;
  action_gt?: String;
  action_gte?: String;
  action_contains?: String;
  action_not_contains?: String;
  action_starts_with?: String;
  action_not_starts_with?: String;
  action_ends_with?: String;
  action_not_ends_with?: String;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  total?: Int;
  total_not?: Int;
  total_in?: Int[] | Int;
  total_not_in?: Int[] | Int;
  total_lt?: Int;
  total_lte?: Int;
  total_gt?: Int;
  total_gte?: Int;
  AND?: DotScalarWhereInput[] | DotScalarWhereInput;
  OR?: DotScalarWhereInput[] | DotScalarWhereInput;
  NOT?: DotScalarWhereInput[] | DotScalarWhereInput;
}

export interface UserCreateWithoutTransactionsInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
}

export interface DotUpdateManyWithWhereNestedInput {
  where: DotScalarWhereInput;
  data: DotUpdateManyDataInput;
}

export interface CircleJoinRequestCreateWithoutUserInput {
  circle: CircleCreateOneWithoutJoinRequestsInput;
}

export interface DotUpdateManyDataInput {
  action?: String;
  amount?: Int;
  total?: Int;
}

export interface CircleCreateWithoutJoinRequestsInput {
  description?: String;
  name: String;
  open?: Boolean;
  invites?: CircleInviteCreateManyWithoutCircleInput;
  members?: UserCreateManyWithoutCirclesInput;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface CharityUpdateManyWithoutFollowersInput {
  create?:
    | CharityCreateWithoutFollowersInput[]
    | CharityCreateWithoutFollowersInput;
  delete?: CharityWhereUniqueInput[] | CharityWhereUniqueInput;
  connect?: CharityWhereUniqueInput[] | CharityWhereUniqueInput;
  set?: CharityWhereUniqueInput[] | CharityWhereUniqueInput;
  disconnect?: CharityWhereUniqueInput[] | CharityWhereUniqueInput;
  update?:
    | CharityUpdateWithWhereUniqueWithoutFollowersInput[]
    | CharityUpdateWithWhereUniqueWithoutFollowersInput;
  upsert?:
    | CharityUpsertWithWhereUniqueWithoutFollowersInput[]
    | CharityUpsertWithWhereUniqueWithoutFollowersInput;
  deleteMany?: CharityScalarWhereInput[] | CharityScalarWhereInput;
  updateMany?:
    | CharityUpdateManyWithWhereNestedInput[]
    | CharityUpdateManyWithWhereNestedInput;
}

export interface CircleInviteCreateWithoutCircleInput {
  user: UserCreateOneWithoutCircleInvitesInput;
}

export interface CharityUpdateWithWhereUniqueWithoutFollowersInput {
  where: CharityWhereUniqueInput;
  data: CharityUpdateWithoutFollowersDataInput;
}

export interface UserCreateWithoutCircleInvitesInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface CharityUpdateWithoutFollowersDataInput {
  acronym?: String;
  bannerCredit?: String;
  ein?: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location?: String;
  mission?: String;
  name?: String;
  phoneNumber?: String;
  website?: String;
  events?: EventUpdateManyWithoutCharityInput;
}

export interface CircleCreateWithoutMembersInput {
  description?: String;
  name: String;
  open?: Boolean;
  joinRequests?: CircleJoinRequestCreateManyWithoutCircleInput;
  invites?: CircleInviteCreateManyWithoutCircleInput;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface CharityUpsertWithWhereUniqueWithoutFollowersInput {
  where: CharityWhereUniqueInput;
  update: CharityUpdateWithoutFollowersDataInput;
  create: CharityCreateWithoutFollowersInput;
}

export interface CircleJoinRequestCreateWithoutCircleInput {
  user: UserCreateOneWithoutCircleJoinRequestsInput;
}

export interface CharityScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  acronym?: String;
  acronym_not?: String;
  acronym_in?: String[] | String;
  acronym_not_in?: String[] | String;
  acronym_lt?: String;
  acronym_lte?: String;
  acronym_gt?: String;
  acronym_gte?: String;
  acronym_contains?: String;
  acronym_not_contains?: String;
  acronym_starts_with?: String;
  acronym_not_starts_with?: String;
  acronym_ends_with?: String;
  acronym_not_ends_with?: String;
  bannerCredit?: String;
  bannerCredit_not?: String;
  bannerCredit_in?: String[] | String;
  bannerCredit_not_in?: String[] | String;
  bannerCredit_lt?: String;
  bannerCredit_lte?: String;
  bannerCredit_gt?: String;
  bannerCredit_gte?: String;
  bannerCredit_contains?: String;
  bannerCredit_not_contains?: String;
  bannerCredit_starts_with?: String;
  bannerCredit_not_starts_with?: String;
  bannerCredit_ends_with?: String;
  bannerCredit_not_ends_with?: String;
  ein?: String;
  ein_not?: String;
  ein_in?: String[] | String;
  ein_not_in?: String[] | String;
  ein_lt?: String;
  ein_lte?: String;
  ein_gt?: String;
  ein_gte?: String;
  ein_contains?: String;
  ein_not_contains?: String;
  ein_starts_with?: String;
  ein_not_starts_with?: String;
  ein_ends_with?: String;
  ein_not_ends_with?: String;
  expensesAdministrative?: Float;
  expensesAdministrative_not?: Float;
  expensesAdministrative_in?: Float[] | Float;
  expensesAdministrative_not_in?: Float[] | Float;
  expensesAdministrative_lt?: Float;
  expensesAdministrative_lte?: Float;
  expensesAdministrative_gt?: Float;
  expensesAdministrative_gte?: Float;
  expensesFundraising?: Float;
  expensesFundraising_not?: Float;
  expensesFundraising_in?: Float[] | Float;
  expensesFundraising_not_in?: Float[] | Float;
  expensesFundraising_lt?: Float;
  expensesFundraising_lte?: Float;
  expensesFundraising_gt?: Float;
  expensesFundraising_gte?: Float;
  expensesOther?: Float;
  expensesOther_not?: Float;
  expensesOther_in?: Float[] | Float;
  expensesOther_not_in?: Float[] | Float;
  expensesOther_lt?: Float;
  expensesOther_lte?: Float;
  expensesOther_gt?: Float;
  expensesOther_gte?: Float;
  expensesProgram?: Float;
  expensesProgram_not?: Float;
  expensesProgram_in?: Float[] | Float;
  expensesProgram_not_in?: Float[] | Float;
  expensesProgram_lt?: Float;
  expensesProgram_lte?: Float;
  expensesProgram_gt?: Float;
  expensesProgram_gte?: Float;
  expensesUpdated?: String;
  expensesUpdated_not?: String;
  expensesUpdated_in?: String[] | String;
  expensesUpdated_not_in?: String[] | String;
  expensesUpdated_lt?: String;
  expensesUpdated_lte?: String;
  expensesUpdated_gt?: String;
  expensesUpdated_gte?: String;
  expensesUpdated_contains?: String;
  expensesUpdated_not_contains?: String;
  expensesUpdated_starts_with?: String;
  expensesUpdated_not_starts_with?: String;
  expensesUpdated_ends_with?: String;
  expensesUpdated_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  mission?: String;
  mission_not?: String;
  mission_in?: String[] | String;
  mission_not_in?: String[] | String;
  mission_lt?: String;
  mission_lte?: String;
  mission_gt?: String;
  mission_gte?: String;
  mission_contains?: String;
  mission_not_contains?: String;
  mission_starts_with?: String;
  mission_not_starts_with?: String;
  mission_ends_with?: String;
  mission_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  phoneNumber?: String;
  phoneNumber_not?: String;
  phoneNumber_in?: String[] | String;
  phoneNumber_not_in?: String[] | String;
  phoneNumber_lt?: String;
  phoneNumber_lte?: String;
  phoneNumber_gt?: String;
  phoneNumber_gte?: String;
  phoneNumber_contains?: String;
  phoneNumber_not_contains?: String;
  phoneNumber_starts_with?: String;
  phoneNumber_not_starts_with?: String;
  phoneNumber_ends_with?: String;
  phoneNumber_not_ends_with?: String;
  website?: String;
  website_not?: String;
  website_in?: String[] | String;
  website_not_in?: String[] | String;
  website_lt?: String;
  website_lte?: String;
  website_gt?: String;
  website_gte?: String;
  website_contains?: String;
  website_not_contains?: String;
  website_starts_with?: String;
  website_not_starts_with?: String;
  website_ends_with?: String;
  website_not_ends_with?: String;
  AND?: CharityScalarWhereInput[] | CharityScalarWhereInput;
  OR?: CharityScalarWhereInput[] | CharityScalarWhereInput;
  NOT?: CharityScalarWhereInput[] | CharityScalarWhereInput;
}

export interface UserCreateWithoutCircleJoinRequestsInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface CharityUpdateManyWithWhereNestedInput {
  where: CharityScalarWhereInput;
  data: CharityUpdateManyDataInput;
}

export interface CircleInviteCreateWithoutUserInput {
  circle: CircleCreateOneWithoutInvitesInput;
}

export interface CharityUpdateManyDataInput {
  acronym?: String;
  bannerCredit?: String;
  ein?: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location?: String;
  mission?: String;
  name?: String;
  phoneNumber?: String;
  website?: String;
}

export interface CircleCreateWithoutInvitesInput {
  description?: String;
  name: String;
  open?: Boolean;
  joinRequests?: CircleJoinRequestCreateManyWithoutCircleInput;
  members?: UserCreateManyWithoutCirclesInput;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface HaloUpdateManyWithoutUserInput {
  create?: HaloCreateWithoutUserInput[] | HaloCreateWithoutUserInput;
  delete?: HaloWhereUniqueInput[] | HaloWhereUniqueInput;
  connect?: HaloWhereUniqueInput[] | HaloWhereUniqueInput;
  set?: HaloWhereUniqueInput[] | HaloWhereUniqueInput;
  disconnect?: HaloWhereUniqueInput[] | HaloWhereUniqueInput;
  update?:
    | HaloUpdateWithWhereUniqueWithoutUserInput[]
    | HaloUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | HaloUpsertWithWhereUniqueWithoutUserInput[]
    | HaloUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: HaloScalarWhereInput[] | HaloScalarWhereInput;
  updateMany?:
    | HaloUpdateManyWithWhereNestedInput[]
    | HaloUpdateManyWithWhereNestedInput;
}

export interface UserCreateWithoutCirclesInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface HaloUpdateWithWhereUniqueWithoutUserInput {
  where: HaloWhereUniqueInput;
  data: HaloUpdateWithoutUserDataInput;
}

export interface CircleCreateWithoutOwnerInput {
  description?: String;
  name: String;
  open?: Boolean;
  joinRequests?: CircleJoinRequestCreateManyWithoutCircleInput;
  invites?: CircleInviteCreateManyWithoutCircleInput;
  members?: UserCreateManyWithoutCirclesInput;
}

export interface HaloUpdateWithoutUserDataInput {
  key?: String;
  tier?: String;
}

export interface DotCreateWithoutUserInput {
  action: String;
  amount: Int;
  total: Int;
}

export interface HaloUpsertWithWhereUniqueWithoutUserInput {
  where: HaloWhereUniqueInput;
  update: HaloUpdateWithoutUserDataInput;
  create: HaloCreateWithoutUserInput;
}

export interface CharityCreateWithoutFollowersInput {
  acronym?: String;
  bannerCredit?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
  events?: EventCreateManyWithoutCharityInput;
}

export interface HaloScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  tier?: String;
  tier_not?: String;
  tier_in?: String[] | String;
  tier_not_in?: String[] | String;
  tier_lt?: String;
  tier_lte?: String;
  tier_gt?: String;
  tier_gte?: String;
  tier_contains?: String;
  tier_not_contains?: String;
  tier_starts_with?: String;
  tier_not_starts_with?: String;
  tier_ends_with?: String;
  tier_not_ends_with?: String;
  AND?: HaloScalarWhereInput[] | HaloScalarWhereInput;
  OR?: HaloScalarWhereInput[] | HaloScalarWhereInput;
  NOT?: HaloScalarWhereInput[] | HaloScalarWhereInput;
}

export interface HaloCreateWithoutUserInput {
  key: String;
  tier?: String;
}

export interface HaloUpdateManyWithWhereNestedInput {
  where: HaloScalarWhereInput;
  data: HaloUpdateManyDataInput;
}

export interface IdentityCreateWithoutUserInput {
  provider: IdentityProvider;
  providerID: String;
}

export interface HaloUpdateManyDataInput {
  key?: String;
  tier?: String;
}

export interface LoopCreateWithoutUserInput {
  count: Int;
  event: EventCreateOneInput;
}

export interface IdentityUpdateOneRequiredWithoutUserInput {
  create?: IdentityCreateWithoutUserInput;
  update?: IdentityUpdateWithoutUserDataInput;
  upsert?: IdentityUpsertWithoutUserInput;
  connect?: IdentityWhereUniqueInput;
}

export interface EventCreateInput {
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeInput;
  charity?: CharityCreateOneWithoutEventsInput;
  specialFundraiser?: SpecialFundraiserCreateOneWithoutEventInput;
  donations?: TransactionCreateManyWithoutEventInput;
}

export interface IdentityUpdateWithoutUserDataInput {
  provider?: IdentityProvider;
  providerID?: String;
}

export interface CharityCreateWithoutEventsInput {
  acronym?: String;
  bannerCredit?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
  followers?: UserCreateManyWithoutFollowedCharitiesInput;
}

export interface IdentityUpsertWithoutUserInput {
  update: IdentityUpdateWithoutUserDataInput;
  create: IdentityCreateWithoutUserInput;
}

export interface UserCreateWithoutFollowedCharitiesInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface LoopUpdateManyWithoutUserInput {
  create?: LoopCreateWithoutUserInput[] | LoopCreateWithoutUserInput;
  delete?: LoopWhereUniqueInput[] | LoopWhereUniqueInput;
  connect?: LoopWhereUniqueInput[] | LoopWhereUniqueInput;
  set?: LoopWhereUniqueInput[] | LoopWhereUniqueInput;
  disconnect?: LoopWhereUniqueInput[] | LoopWhereUniqueInput;
  update?:
    | LoopUpdateWithWhereUniqueWithoutUserInput[]
    | LoopUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | LoopUpsertWithWhereUniqueWithoutUserInput[]
    | LoopUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: LoopScalarWhereInput[] | LoopScalarWhereInput;
  updateMany?:
    | LoopUpdateManyWithWhereNestedInput[]
    | LoopUpdateManyWithWhereNestedInput;
}

export interface PreferencesCreateWithoutUserInput {
  allowDonationEmails?: Boolean;
  publicProfile?: Boolean;
}

export interface LoopUpdateWithWhereUniqueWithoutUserInput {
  where: LoopWhereUniqueInput;
  data: LoopUpdateWithoutUserDataInput;
}

export interface TransactionCreateWithoutUserInput {
  amount: Int;
  balance: Int;
  key: String;
  stripeID?: String;
  type: TransactionType;
  event?: EventCreateOneWithoutDonationsInput;
}

export interface LoopUpdateWithoutUserDataInput {
  count?: Int;
  event?: EventUpdateOneRequiredInput;
}

export interface EventCreateWithoutDonationsInput {
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeInput;
  charity?: CharityCreateOneWithoutEventsInput;
  specialFundraiser?: SpecialFundraiserCreateOneWithoutEventInput;
}

export interface EventUpdateOneRequiredInput {
  create?: EventCreateInput;
  update?: EventUpdateDataInput;
  upsert?: EventUpsertNestedInput;
  connect?: EventWhereUniqueInput;
}

export interface UserCreateWithoutCirclesOwnedInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface EventUpdateDataInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
  charity?: CharityUpdateOneWithoutEventsInput;
  specialFundraiser?: SpecialFundraiserUpdateOneWithoutEventInput;
  donations?: TransactionUpdateManyWithoutEventInput;
}

export interface EventUpdateManyWithoutCharityInput {
  create?: EventCreateWithoutCharityInput[] | EventCreateWithoutCharityInput;
  delete?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  set?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  disconnect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  update?:
    | EventUpdateWithWhereUniqueWithoutCharityInput[]
    | EventUpdateWithWhereUniqueWithoutCharityInput;
  upsert?:
    | EventUpsertWithWhereUniqueWithoutCharityInput[]
    | EventUpsertWithWhereUniqueWithoutCharityInput;
  deleteMany?: EventScalarWhereInput[] | EventScalarWhereInput;
  updateMany?:
    | EventUpdateManyWithWhereNestedInput[]
    | EventUpdateManyWithWhereNestedInput;
}

export interface CharityUpdateOneWithoutEventsInput {
  create?: CharityCreateWithoutEventsInput;
  update?: CharityUpdateWithoutEventsDataInput;
  upsert?: CharityUpsertWithoutEventsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: CharityWhereUniqueInput;
}

export interface EventUpdateWithoutCharityDataInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
  specialFundraiser?: SpecialFundraiserUpdateOneWithoutEventInput;
  donations?: TransactionUpdateManyWithoutEventInput;
}

export interface CharityUpdateWithoutEventsDataInput {
  acronym?: String;
  bannerCredit?: String;
  ein?: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location?: String;
  mission?: String;
  name?: String;
  phoneNumber?: String;
  website?: String;
  followers?: UserUpdateManyWithoutFollowedCharitiesInput;
}

export interface SpecialFundraiserUpdateWithoutEventDataInput {
  description?: String;
  name?: String;
}

export interface UserUpdateManyWithoutFollowedCharitiesInput {
  create?:
    | UserCreateWithoutFollowedCharitiesInput[]
    | UserCreateWithoutFollowedCharitiesInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput[]
    | UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput[]
    | UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransactionWhereInput;
  AND?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  OR?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  NOT?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
}

export interface UserUpdateWithWhereUniqueWithoutFollowedCharitiesInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutFollowedCharitiesDataInput;
}

export interface LoopSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: LoopWhereInput;
  AND?: LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput;
  OR?: LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput;
  NOT?: LoopSubscriptionWhereInput[] | LoopSubscriptionWhereInput;
}

export interface UserUpdateWithoutFollowedCharitiesDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  nameFirst?: String;
  nameFirst_not?: String;
  nameFirst_in?: String[] | String;
  nameFirst_not_in?: String[] | String;
  nameFirst_lt?: String;
  nameFirst_lte?: String;
  nameFirst_gt?: String;
  nameFirst_gte?: String;
  nameFirst_contains?: String;
  nameFirst_not_contains?: String;
  nameFirst_starts_with?: String;
  nameFirst_not_starts_with?: String;
  nameFirst_ends_with?: String;
  nameFirst_not_ends_with?: String;
  nameLast?: String;
  nameLast_not?: String;
  nameLast_in?: String[] | String;
  nameLast_not_in?: String[] | String;
  nameLast_lt?: String;
  nameLast_lte?: String;
  nameLast_gt?: String;
  nameLast_gte?: String;
  nameLast_contains?: String;
  nameLast_not_contains?: String;
  nameLast_starts_with?: String;
  nameLast_not_starts_with?: String;
  nameLast_ends_with?: String;
  nameLast_not_ends_with?: String;
  picture?: String;
  picture_not?: String;
  picture_in?: String[] | String;
  picture_not_in?: String[] | String;
  picture_lt?: String;
  picture_lte?: String;
  picture_gt?: String;
  picture_gte?: String;
  picture_contains?: String;
  picture_not_contains?: String;
  picture_starts_with?: String;
  picture_not_starts_with?: String;
  picture_ends_with?: String;
  picture_not_ends_with?: String;
  securityToken?: Int;
  securityToken_not?: Int;
  securityToken_in?: Int[] | Int;
  securityToken_not_in?: Int[] | Int;
  securityToken_lt?: Int;
  securityToken_lte?: Int;
  securityToken_gt?: Int;
  securityToken_gte?: Int;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  circleJoinRequests_every?: CircleJoinRequestWhereInput;
  circleJoinRequests_some?: CircleJoinRequestWhereInput;
  circleJoinRequests_none?: CircleJoinRequestWhereInput;
  circleInvites_every?: CircleInviteWhereInput;
  circleInvites_some?: CircleInviteWhereInput;
  circleInvites_none?: CircleInviteWhereInput;
  circles_every?: CircleWhereInput;
  circles_some?: CircleWhereInput;
  circles_none?: CircleWhereInput;
  circlesOwned_every?: CircleWhereInput;
  circlesOwned_some?: CircleWhereInput;
  circlesOwned_none?: CircleWhereInput;
  dots_every?: DotWhereInput;
  dots_some?: DotWhereInput;
  dots_none?: DotWhereInput;
  followedCharities_every?: CharityWhereInput;
  followedCharities_some?: CharityWhereInput;
  followedCharities_none?: CharityWhereInput;
  halos_every?: HaloWhereInput;
  halos_some?: HaloWhereInput;
  halos_none?: HaloWhereInput;
  identity?: IdentityWhereInput;
  loops_every?: LoopWhereInput;
  loops_some?: LoopWhereInput;
  loops_none?: LoopWhereInput;
  preferences?: PreferencesWhereInput;
  transactions_every?: TransactionWhereInput;
  transactions_some?: TransactionWhereInput;
  transactions_none?: TransactionWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface PreferencesUpdateOneRequiredWithoutUserInput {
  create?: PreferencesCreateWithoutUserInput;
  update?: PreferencesUpdateWithoutUserDataInput;
  upsert?: PreferencesUpsertWithoutUserInput;
  connect?: PreferencesWhereUniqueInput;
}

export interface DotSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: DotWhereInput;
  AND?: DotSubscriptionWhereInput[] | DotSubscriptionWhereInput;
  OR?: DotSubscriptionWhereInput[] | DotSubscriptionWhereInput;
  NOT?: DotSubscriptionWhereInput[] | DotSubscriptionWhereInput;
}

export interface PreferencesUpdateWithoutUserDataInput {
  allowDonationEmails?: Boolean;
  publicProfile?: Boolean;
}

export interface CircleSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CircleWhereInput;
  AND?: CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput;
  OR?: CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput;
  NOT?: CircleSubscriptionWhereInput[] | CircleSubscriptionWhereInput;
}

export interface PreferencesUpsertWithoutUserInput {
  update: PreferencesUpdateWithoutUserDataInput;
  create: PreferencesCreateWithoutUserInput;
}

export interface UserCreateInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  dots?: DotCreateManyWithoutUserInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface TransactionUpdateManyWithoutUserInput {
  create?:
    | TransactionCreateWithoutUserInput[]
    | TransactionCreateWithoutUserInput;
  delete?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  set?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  disconnect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  update?:
    | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    | TransactionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    | TransactionUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  updateMany?:
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput;
}

export interface TransactionCreateInput {
  amount: Int;
  balance: Int;
  key: String;
  stripeID?: String;
  type: TransactionType;
  event?: EventCreateOneWithoutDonationsInput;
  user?: UserCreateOneWithoutTransactionsInput;
}

export interface TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutUserDataInput;
}

export interface EventUpdateWithoutSpecialFundraiserDataInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
  charity?: CharityUpdateOneWithoutEventsInput;
  donations?: TransactionUpdateManyWithoutEventInput;
}

export interface TransactionUpdateWithoutUserDataInput {
  amount?: Int;
  balance?: Int;
  key?: String;
  stripeID?: String;
  type?: TransactionType;
  event?: EventUpdateOneWithoutDonationsInput;
}

export interface EventCreateWithoutSpecialFundraiserInput {
  endDate: DateTimeInput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeInput;
  charity?: CharityCreateOneWithoutEventsInput;
  donations?: TransactionCreateManyWithoutEventInput;
}

export interface EventUpdateOneWithoutDonationsInput {
  create?: EventCreateWithoutDonationsInput;
  update?: EventUpdateWithoutDonationsDataInput;
  upsert?: EventUpsertWithoutDonationsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EventWhereUniqueInput;
}

export interface PreferencesUpdateManyMutationInput {
  allowDonationEmails?: Boolean;
  publicProfile?: Boolean;
}

export interface EventUpdateWithoutDonationsDataInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
  charity?: CharityUpdateOneWithoutEventsInput;
  specialFundraiser?: SpecialFundraiserUpdateOneWithoutEventInput;
}

export interface UserUpdateOneRequiredWithoutPreferencesInput {
  create?: UserCreateWithoutPreferencesInput;
  update?: UserUpdateWithoutPreferencesDataInput;
  upsert?: UserUpsertWithoutPreferencesInput;
  connect?: UserWhereUniqueInput;
}

export interface EventUpsertWithoutDonationsInput {
  update: EventUpdateWithoutDonationsDataInput;
  create: EventCreateWithoutDonationsInput;
}

export interface UserCreateOneWithoutPreferencesInput {
  create?: UserCreateWithoutPreferencesInput;
  connect?: UserWhereUniqueInput;
}

export interface TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutUserDataInput;
  create: TransactionCreateWithoutUserInput;
}

export interface UserUpsertWithoutLoopsInput {
  update: UserUpdateWithoutLoopsDataInput;
  create: UserCreateWithoutLoopsInput;
}

export interface TransactionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  balance?: Int;
  balance_not?: Int;
  balance_in?: Int[] | Int;
  balance_not_in?: Int[] | Int;
  balance_lt?: Int;
  balance_lte?: Int;
  balance_gt?: Int;
  balance_gte?: Int;
  key?: String;
  key_not?: String;
  key_in?: String[] | String;
  key_not_in?: String[] | String;
  key_lt?: String;
  key_lte?: String;
  key_gt?: String;
  key_gte?: String;
  key_contains?: String;
  key_not_contains?: String;
  key_starts_with?: String;
  key_not_starts_with?: String;
  key_ends_with?: String;
  key_not_ends_with?: String;
  stripeID?: String;
  stripeID_not?: String;
  stripeID_in?: String[] | String;
  stripeID_not_in?: String[] | String;
  stripeID_lt?: String;
  stripeID_lte?: String;
  stripeID_gt?: String;
  stripeID_gte?: String;
  stripeID_contains?: String;
  stripeID_not_contains?: String;
  stripeID_starts_with?: String;
  stripeID_not_starts_with?: String;
  stripeID_ends_with?: String;
  stripeID_not_ends_with?: String;
  type?: TransactionType;
  type_not?: TransactionType;
  type_in?: TransactionType[] | TransactionType;
  type_not_in?: TransactionType[] | TransactionType;
  AND?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  OR?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  NOT?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
}

export interface LoopUpdateInput {
  count?: Int;
  event?: EventUpdateOneRequiredInput;
  user?: UserUpdateOneRequiredWithoutLoopsInput;
}

export interface TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput;
  data: TransactionUpdateManyDataInput;
}

export interface LoopCreateInput {
  count: Int;
  event: EventCreateOneInput;
  user: UserCreateOneWithoutLoopsInput;
}

export interface TransactionUpdateManyDataInput {
  amount?: Int;
  balance?: Int;
  key?: String;
  stripeID?: String;
  type?: TransactionType;
}

export interface UserUpdateWithoutIdentityDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface UserUpsertWithWhereUniqueWithoutFollowedCharitiesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutFollowedCharitiesDataInput;
  create: UserCreateWithoutFollowedCharitiesInput;
}

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  key?: String;
}>;

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  bio?: String;
  bio_not?: String;
  bio_in?: String[] | String;
  bio_not_in?: String[] | String;
  bio_lt?: String;
  bio_lte?: String;
  bio_gt?: String;
  bio_gte?: String;
  bio_contains?: String;
  bio_not_contains?: String;
  bio_starts_with?: String;
  bio_not_starts_with?: String;
  bio_ends_with?: String;
  bio_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  nameFirst?: String;
  nameFirst_not?: String;
  nameFirst_in?: String[] | String;
  nameFirst_not_in?: String[] | String;
  nameFirst_lt?: String;
  nameFirst_lte?: String;
  nameFirst_gt?: String;
  nameFirst_gte?: String;
  nameFirst_contains?: String;
  nameFirst_not_contains?: String;
  nameFirst_starts_with?: String;
  nameFirst_not_starts_with?: String;
  nameFirst_ends_with?: String;
  nameFirst_not_ends_with?: String;
  nameLast?: String;
  nameLast_not?: String;
  nameLast_in?: String[] | String;
  nameLast_not_in?: String[] | String;
  nameLast_lt?: String;
  nameLast_lte?: String;
  nameLast_gt?: String;
  nameLast_gte?: String;
  nameLast_contains?: String;
  nameLast_not_contains?: String;
  nameLast_starts_with?: String;
  nameLast_not_starts_with?: String;
  nameLast_ends_with?: String;
  nameLast_not_ends_with?: String;
  picture?: String;
  picture_not?: String;
  picture_in?: String[] | String;
  picture_not_in?: String[] | String;
  picture_lt?: String;
  picture_lte?: String;
  picture_gt?: String;
  picture_gte?: String;
  picture_contains?: String;
  picture_not_contains?: String;
  picture_starts_with?: String;
  picture_not_starts_with?: String;
  picture_ends_with?: String;
  picture_not_ends_with?: String;
  securityToken?: Int;
  securityToken_not?: Int;
  securityToken_in?: Int[] | Int;
  securityToken_not_in?: Int[] | Int;
  securityToken_lt?: Int;
  securityToken_lte?: Int;
  securityToken_gt?: Int;
  securityToken_gte?: Int;
  username?: String;
  username_not?: String;
  username_in?: String[] | String;
  username_not_in?: String[] | String;
  username_lt?: String;
  username_lte?: String;
  username_gt?: String;
  username_gte?: String;
  username_contains?: String;
  username_not_contains?: String;
  username_starts_with?: String;
  username_not_starts_with?: String;
  username_ends_with?: String;
  username_not_ends_with?: String;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  username?: String;
}>;

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface SpecialFundraiserCreateOneWithoutEventInput {
  create?: SpecialFundraiserCreateWithoutEventInput;
  connect?: SpecialFundraiserWhereUniqueInput;
}

export interface UserUpdateManyDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
}

export interface UserCreateOneWithoutTransactionsInput {
  create?: UserCreateWithoutTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface CharityUpsertWithoutEventsInput {
  update: CharityUpdateWithoutEventsDataInput;
  create: CharityCreateWithoutEventsInput;
}

export interface CircleCreateOneWithoutJoinRequestsInput {
  create?: CircleCreateWithoutJoinRequestsInput;
  connect?: CircleWhereUniqueInput;
}

export interface EventUpsertNestedInput {
  update: EventUpdateDataInput;
  create: EventCreateInput;
}

export interface UserCreateOneWithoutCircleInvitesInput {
  create?: UserCreateWithoutCircleInvitesInput;
  connect?: UserWhereUniqueInput;
}

export interface LoopUpsertWithWhereUniqueWithoutUserInput {
  where: LoopWhereUniqueInput;
  update: LoopUpdateWithoutUserDataInput;
  create: LoopCreateWithoutUserInput;
}

export interface CircleJoinRequestCreateManyWithoutCircleInput {
  create?:
    | CircleJoinRequestCreateWithoutCircleInput[]
    | CircleJoinRequestCreateWithoutCircleInput;
  connect?:
    | CircleJoinRequestWhereUniqueInput[]
    | CircleJoinRequestWhereUniqueInput;
}

export interface LoopScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  count?: Int;
  count_not?: Int;
  count_in?: Int[] | Int;
  count_not_in?: Int[] | Int;
  count_lt?: Int;
  count_lte?: Int;
  count_gt?: Int;
  count_gte?: Int;
  AND?: LoopScalarWhereInput[] | LoopScalarWhereInput;
  OR?: LoopScalarWhereInput[] | LoopScalarWhereInput;
  NOT?: LoopScalarWhereInput[] | LoopScalarWhereInput;
}

export interface CircleInviteCreateManyWithoutUserInput {
  create?:
    | CircleInviteCreateWithoutUserInput[]
    | CircleInviteCreateWithoutUserInput;
  connect?: CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput;
}

export interface LoopUpdateManyWithWhereNestedInput {
  where: LoopScalarWhereInput;
  data: LoopUpdateManyDataInput;
}

export interface UserCreateManyWithoutCirclesInput {
  create?: UserCreateWithoutCirclesInput[] | UserCreateWithoutCirclesInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface LoopUpdateManyDataInput {
  count?: Int;
}

export interface DotCreateManyWithoutUserInput {
  create?: DotCreateWithoutUserInput[] | DotCreateWithoutUserInput;
  connect?: DotWhereUniqueInput[] | DotWhereUniqueInput;
}

export interface UserUpsertWithWhereUniqueWithoutCirclesInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutCirclesDataInput;
  create: UserCreateWithoutCirclesInput;
}

export interface HaloCreateManyWithoutUserInput {
  create?: HaloCreateWithoutUserInput[] | HaloCreateWithoutUserInput;
  connect?: HaloWhereUniqueInput[] | HaloWhereUniqueInput;
}

export interface UserUpdateOneRequiredWithoutCirclesOwnedInput {
  create?: UserCreateWithoutCirclesOwnedInput;
  update?: UserUpdateWithoutCirclesOwnedDataInput;
  upsert?: UserUpsertWithoutCirclesOwnedInput;
  connect?: UserWhereUniqueInput;
}

export interface LoopCreateManyWithoutUserInput {
  create?: LoopCreateWithoutUserInput[] | LoopCreateWithoutUserInput;
  connect?: LoopWhereUniqueInput[] | LoopWhereUniqueInput;
}

export interface UserUpdateWithoutCirclesOwnedDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface CharityCreateOneWithoutEventsInput {
  create?: CharityCreateWithoutEventsInput;
  connect?: CharityWhereUniqueInput;
}

export interface UserUpsertWithoutCirclesOwnedInput {
  update: UserUpdateWithoutCirclesOwnedDataInput;
  create: UserCreateWithoutCirclesOwnedInput;
}

export interface PreferencesCreateOneWithoutUserInput {
  create?: PreferencesCreateWithoutUserInput;
  connect?: PreferencesWhereUniqueInput;
}

export interface CircleUpsertWithoutInvitesInput {
  update: CircleUpdateWithoutInvitesDataInput;
  create: CircleCreateWithoutInvitesInput;
}

export interface EventCreateOneWithoutDonationsInput {
  create?: EventCreateWithoutDonationsInput;
  connect?: EventWhereUniqueInput;
}

export interface CircleInviteUpsertWithWhereUniqueWithoutUserInput {
  where: CircleInviteWhereUniqueInput;
  update: CircleInviteUpdateWithoutUserDataInput;
  create: CircleInviteCreateWithoutUserInput;
}

export interface CharityUpdateInput {
  acronym?: String;
  bannerCredit?: String;
  ein?: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location?: String;
  mission?: String;
  name?: String;
  phoneNumber?: String;
  website?: String;
  events?: EventUpdateManyWithoutCharityInput;
  followers?: UserUpdateManyWithoutFollowedCharitiesInput;
}

export interface CircleInviteScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput;
  OR?: CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput;
  NOT?: CircleInviteScalarWhereInput[] | CircleInviteScalarWhereInput;
}

export interface SpecialFundraiserUpdateOneWithoutEventInput {
  create?: SpecialFundraiserCreateWithoutEventInput;
  update?: SpecialFundraiserUpdateWithoutEventDataInput;
  upsert?: SpecialFundraiserUpsertWithoutEventInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: SpecialFundraiserWhereUniqueInput;
}

export interface UserUpsertWithoutCircleJoinRequestsInput {
  update: UserUpdateWithoutCircleJoinRequestsDataInput;
  create: UserCreateWithoutCircleJoinRequestsInput;
}

export interface SpecialFundraiserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: SpecialFundraiserWhereInput;
  AND?:
    | SpecialFundraiserSubscriptionWhereInput[]
    | SpecialFundraiserSubscriptionWhereInput;
  OR?:
    | SpecialFundraiserSubscriptionWhereInput[]
    | SpecialFundraiserSubscriptionWhereInput;
  NOT?:
    | SpecialFundraiserSubscriptionWhereInput[]
    | SpecialFundraiserSubscriptionWhereInput;
}

export interface CircleJoinRequestUpsertWithWhereUniqueWithoutCircleInput {
  where: CircleJoinRequestWhereUniqueInput;
  update: CircleJoinRequestUpdateWithoutCircleDataInput;
  create: CircleJoinRequestCreateWithoutCircleInput;
}

export interface CharityWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  acronym?: String;
  acronym_not?: String;
  acronym_in?: String[] | String;
  acronym_not_in?: String[] | String;
  acronym_lt?: String;
  acronym_lte?: String;
  acronym_gt?: String;
  acronym_gte?: String;
  acronym_contains?: String;
  acronym_not_contains?: String;
  acronym_starts_with?: String;
  acronym_not_starts_with?: String;
  acronym_ends_with?: String;
  acronym_not_ends_with?: String;
  bannerCredit?: String;
  bannerCredit_not?: String;
  bannerCredit_in?: String[] | String;
  bannerCredit_not_in?: String[] | String;
  bannerCredit_lt?: String;
  bannerCredit_lte?: String;
  bannerCredit_gt?: String;
  bannerCredit_gte?: String;
  bannerCredit_contains?: String;
  bannerCredit_not_contains?: String;
  bannerCredit_starts_with?: String;
  bannerCredit_not_starts_with?: String;
  bannerCredit_ends_with?: String;
  bannerCredit_not_ends_with?: String;
  ein?: String;
  ein_not?: String;
  ein_in?: String[] | String;
  ein_not_in?: String[] | String;
  ein_lt?: String;
  ein_lte?: String;
  ein_gt?: String;
  ein_gte?: String;
  ein_contains?: String;
  ein_not_contains?: String;
  ein_starts_with?: String;
  ein_not_starts_with?: String;
  ein_ends_with?: String;
  ein_not_ends_with?: String;
  expensesAdministrative?: Float;
  expensesAdministrative_not?: Float;
  expensesAdministrative_in?: Float[] | Float;
  expensesAdministrative_not_in?: Float[] | Float;
  expensesAdministrative_lt?: Float;
  expensesAdministrative_lte?: Float;
  expensesAdministrative_gt?: Float;
  expensesAdministrative_gte?: Float;
  expensesFundraising?: Float;
  expensesFundraising_not?: Float;
  expensesFundraising_in?: Float[] | Float;
  expensesFundraising_not_in?: Float[] | Float;
  expensesFundraising_lt?: Float;
  expensesFundraising_lte?: Float;
  expensesFundraising_gt?: Float;
  expensesFundraising_gte?: Float;
  expensesOther?: Float;
  expensesOther_not?: Float;
  expensesOther_in?: Float[] | Float;
  expensesOther_not_in?: Float[] | Float;
  expensesOther_lt?: Float;
  expensesOther_lte?: Float;
  expensesOther_gt?: Float;
  expensesOther_gte?: Float;
  expensesProgram?: Float;
  expensesProgram_not?: Float;
  expensesProgram_in?: Float[] | Float;
  expensesProgram_not_in?: Float[] | Float;
  expensesProgram_lt?: Float;
  expensesProgram_lte?: Float;
  expensesProgram_gt?: Float;
  expensesProgram_gte?: Float;
  expensesUpdated?: String;
  expensesUpdated_not?: String;
  expensesUpdated_in?: String[] | String;
  expensesUpdated_not_in?: String[] | String;
  expensesUpdated_lt?: String;
  expensesUpdated_lte?: String;
  expensesUpdated_gt?: String;
  expensesUpdated_gte?: String;
  expensesUpdated_contains?: String;
  expensesUpdated_not_contains?: String;
  expensesUpdated_starts_with?: String;
  expensesUpdated_not_starts_with?: String;
  expensesUpdated_ends_with?: String;
  expensesUpdated_not_ends_with?: String;
  location?: String;
  location_not?: String;
  location_in?: String[] | String;
  location_not_in?: String[] | String;
  location_lt?: String;
  location_lte?: String;
  location_gt?: String;
  location_gte?: String;
  location_contains?: String;
  location_not_contains?: String;
  location_starts_with?: String;
  location_not_starts_with?: String;
  location_ends_with?: String;
  location_not_ends_with?: String;
  mission?: String;
  mission_not?: String;
  mission_in?: String[] | String;
  mission_not_in?: String[] | String;
  mission_lt?: String;
  mission_lte?: String;
  mission_gt?: String;
  mission_gte?: String;
  mission_contains?: String;
  mission_not_contains?: String;
  mission_starts_with?: String;
  mission_not_starts_with?: String;
  mission_ends_with?: String;
  mission_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  phoneNumber?: String;
  phoneNumber_not?: String;
  phoneNumber_in?: String[] | String;
  phoneNumber_not_in?: String[] | String;
  phoneNumber_lt?: String;
  phoneNumber_lte?: String;
  phoneNumber_gt?: String;
  phoneNumber_gte?: String;
  phoneNumber_contains?: String;
  phoneNumber_not_contains?: String;
  phoneNumber_starts_with?: String;
  phoneNumber_not_starts_with?: String;
  phoneNumber_ends_with?: String;
  phoneNumber_not_ends_with?: String;
  website?: String;
  website_not?: String;
  website_in?: String[] | String;
  website_not_in?: String[] | String;
  website_lt?: String;
  website_lte?: String;
  website_gt?: String;
  website_gte?: String;
  website_contains?: String;
  website_not_contains?: String;
  website_starts_with?: String;
  website_not_starts_with?: String;
  website_ends_with?: String;
  website_not_ends_with?: String;
  events_every?: EventWhereInput;
  events_some?: EventWhereInput;
  events_none?: EventWhereInput;
  followers_every?: UserWhereInput;
  followers_some?: UserWhereInput;
  followers_none?: UserWhereInput;
  AND?: CharityWhereInput[] | CharityWhereInput;
  OR?: CharityWhereInput[] | CharityWhereInput;
  NOT?: CharityWhereInput[] | CharityWhereInput;
}

export interface CircleJoinRequestScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  AND?: CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput;
  OR?: CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput;
  NOT?: CircleJoinRequestScalarWhereInput[] | CircleJoinRequestScalarWhereInput;
}

export interface UserUpdateManyMutationInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
}

export interface CircleUpsertWithWhereUniqueWithoutMembersInput {
  where: CircleWhereUniqueInput;
  update: CircleUpdateWithoutMembersDataInput;
  create: CircleCreateWithoutMembersInput;
}

export interface SpecialFundraiserUpdateManyMutationInput {
  description?: String;
  name?: String;
}

export interface UserUpsertWithoutCircleInvitesInput {
  update: UserUpdateWithoutCircleInvitesDataInput;
  create: UserCreateWithoutCircleInvitesInput;
}

export interface EventCreateOneWithoutSpecialFundraiserInput {
  create?: EventCreateWithoutSpecialFundraiserInput;
  connect?: EventWhereUniqueInput;
}

export interface CircleInviteUpsertWithWhereUniqueWithoutCircleInput {
  where: CircleInviteWhereUniqueInput;
  update: CircleInviteUpdateWithoutCircleDataInput;
  create: CircleInviteCreateWithoutCircleInput;
}

export interface PreferencesUpdateInput {
  allowDonationEmails?: Boolean;
  publicProfile?: Boolean;
  user?: UserUpdateOneRequiredWithoutPreferencesInput;
}

export interface CircleUpsertWithoutJoinRequestsInput {
  update: CircleUpdateWithoutJoinRequestsDataInput;
  create: CircleCreateWithoutJoinRequestsInput;
}

export type LoopWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CircleJoinRequestUpsertWithWhereUniqueWithoutUserInput {
  where: CircleJoinRequestWhereUniqueInput;
  update: CircleJoinRequestUpdateWithoutUserDataInput;
  create: CircleJoinRequestCreateWithoutUserInput;
}

export interface UserUpsertWithoutIdentityInput {
  update: UserUpdateWithoutIdentityDataInput;
  create: UserCreateWithoutIdentityInput;
}

export interface UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput;
  create: UserCreateWithoutTransactionsInput;
}

export interface IdentityCreateInput {
  provider: IdentityProvider;
  providerID: String;
  user: UserCreateOneWithoutIdentityInput;
}

export interface TransactionUpsertWithWhereUniqueWithoutEventInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutEventDataInput;
  create: TransactionCreateWithoutEventInput;
}

export interface EventCreateManyWithoutCharityInput {
  create?: EventCreateWithoutCharityInput[] | EventCreateWithoutCharityInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
}

export interface EventUpsertWithWhereUniqueWithoutCharityInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutCharityDataInput;
  create: EventCreateWithoutCharityInput;
}

export interface CircleJoinRequestCreateManyWithoutUserInput {
  create?:
    | CircleJoinRequestCreateWithoutUserInput[]
    | CircleJoinRequestCreateWithoutUserInput;
  connect?:
    | CircleJoinRequestWhereUniqueInput[]
    | CircleJoinRequestWhereUniqueInput;
}

export interface EventScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  goal?: Int;
  goal_not?: Int;
  goal_in?: Int[] | Int;
  goal_not_in?: Int[] | Int;
  goal_lt?: Int;
  goal_lte?: Int;
  goal_gt?: Int;
  goal_gte?: Int;
  multiplier?: Int;
  multiplier_not?: Int;
  multiplier_in?: Int[] | Int;
  multiplier_not_in?: Int[] | Int;
  multiplier_lt?: Int;
  multiplier_lte?: Int;
  multiplier_gt?: Int;
  multiplier_gte?: Int;
  sponsorName?: String;
  sponsorName_not?: String;
  sponsorName_in?: String[] | String;
  sponsorName_not_in?: String[] | String;
  sponsorName_lt?: String;
  sponsorName_lte?: String;
  sponsorName_gt?: String;
  sponsorName_gte?: String;
  sponsorName_contains?: String;
  sponsorName_not_contains?: String;
  sponsorName_starts_with?: String;
  sponsorName_not_starts_with?: String;
  sponsorName_ends_with?: String;
  sponsorName_not_ends_with?: String;
  sponsorWebsite?: String;
  sponsorWebsite_not?: String;
  sponsorWebsite_in?: String[] | String;
  sponsorWebsite_not_in?: String[] | String;
  sponsorWebsite_lt?: String;
  sponsorWebsite_lte?: String;
  sponsorWebsite_gt?: String;
  sponsorWebsite_gte?: String;
  sponsorWebsite_contains?: String;
  sponsorWebsite_not_contains?: String;
  sponsorWebsite_starts_with?: String;
  sponsorWebsite_not_starts_with?: String;
  sponsorWebsite_ends_with?: String;
  sponsorWebsite_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  AND?: EventScalarWhereInput[] | EventScalarWhereInput;
  OR?: EventScalarWhereInput[] | EventScalarWhereInput;
  NOT?: EventScalarWhereInput[] | EventScalarWhereInput;
}

export interface CircleCreateManyWithoutMembersInput {
  create?: CircleCreateWithoutMembersInput[] | CircleCreateWithoutMembersInput;
  connect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface CircleCreateOneWithoutInvitesInput {
  create?: CircleCreateWithoutInvitesInput;
  connect?: CircleWhereUniqueInput;
}

export interface EventUpdateManyDataInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
}

export interface CharityCreateManyWithoutFollowersInput {
  create?:
    | CharityCreateWithoutFollowersInput[]
    | CharityCreateWithoutFollowersInput;
  connect?: CharityWhereUniqueInput[] | CharityWhereUniqueInput;
}

export interface CharityUpdateManyMutationInput {
  acronym?: String;
  bannerCredit?: String;
  ein?: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location?: String;
  mission?: String;
  name?: String;
  phoneNumber?: String;
  website?: String;
}

export interface EventCreateOneInput {
  create?: EventCreateInput;
  connect?: EventWhereUniqueInput;
}

export interface UserCreateOneWithoutHalosInput {
  create?: UserCreateWithoutHalosInput;
  connect?: UserWhereUniqueInput;
}

export interface TransactionCreateManyWithoutUserInput {
  create?:
    | TransactionCreateWithoutUserInput[]
    | TransactionCreateWithoutUserInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
}

export interface HaloCreateInput {
  key: String;
  tier?: String;
  user: UserCreateOneWithoutHalosInput;
}

export interface EventUpdateWithWhereUniqueWithoutCharityInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutCharityDataInput;
}

export interface CircleCreateInput {
  description?: String;
  name: String;
  open?: Boolean;
  joinRequests?: CircleJoinRequestCreateManyWithoutCircleInput;
  invites?: CircleInviteCreateManyWithoutCircleInput;
  members?: UserCreateManyWithoutCirclesInput;
  owner: UserCreateOneWithoutCirclesOwnedInput;
}

export interface CircleWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  open?: Boolean;
  open_not?: Boolean;
  joinRequests_every?: CircleJoinRequestWhereInput;
  joinRequests_some?: CircleJoinRequestWhereInput;
  joinRequests_none?: CircleJoinRequestWhereInput;
  invites_every?: CircleInviteWhereInput;
  invites_some?: CircleInviteWhereInput;
  invites_none?: CircleInviteWhereInput;
  members_every?: UserWhereInput;
  members_some?: UserWhereInput;
  members_none?: UserWhereInput;
  owner?: UserWhereInput;
  AND?: CircleWhereInput[] | CircleWhereInput;
  OR?: CircleWhereInput[] | CircleWhereInput;
  NOT?: CircleWhereInput[] | CircleWhereInput;
}

export interface CircleUpdateInput {
  description?: String;
  name?: String;
  open?: Boolean;
  joinRequests?: CircleJoinRequestUpdateManyWithoutCircleInput;
  invites?: CircleInviteUpdateManyWithoutCircleInput;
  members?: UserUpdateManyWithoutCirclesInput;
  owner?: UserUpdateOneRequiredWithoutCirclesOwnedInput;
}

export interface TransactionUpdateManyMutationInput {
  amount?: Int;
  balance?: Int;
  key?: String;
  stripeID?: String;
  type?: TransactionType;
}

export interface CircleUpdateManyMutationInput {
  description?: String;
  name?: String;
  open?: Boolean;
}

export interface UserUpsertWithoutPreferencesInput {
  update: UserUpdateWithoutPreferencesDataInput;
  create: UserCreateWithoutPreferencesInput;
}

export interface CircleInviteCreateInput {
  circle: CircleCreateOneWithoutInvitesInput;
  user: UserCreateOneWithoutCircleInvitesInput;
}

export type PreferencesWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface CircleInviteUpdateInput {
  circle?: CircleUpdateOneRequiredWithoutInvitesInput;
  user?: UserUpdateOneRequiredWithoutCircleInvitesInput;
}

export interface UserUpdateWithoutHalosDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  dots?: DotUpdateManyWithoutUserInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface CircleJoinRequestCreateInput {
  circle: CircleCreateOneWithoutJoinRequestsInput;
  user: UserCreateOneWithoutCircleJoinRequestsInput;
}

export interface CircleInviteCreateManyWithoutCircleInput {
  create?:
    | CircleInviteCreateWithoutCircleInput[]
    | CircleInviteCreateWithoutCircleInput;
  connect?: CircleInviteWhereUniqueInput[] | CircleInviteWhereUniqueInput;
}

export interface CircleJoinRequestUpdateInput {
  circle?: CircleUpdateOneRequiredWithoutJoinRequestsInput;
  user?: UserUpdateOneRequiredWithoutCircleJoinRequestsInput;
}

export interface CircleCreateManyWithoutOwnerInput {
  create?: CircleCreateWithoutOwnerInput[] | CircleCreateWithoutOwnerInput;
  connect?: CircleWhereUniqueInput[] | CircleWhereUniqueInput;
}

export interface DotCreateInput {
  action: String;
  amount: Int;
  total: Int;
  user: UserCreateOneWithoutDotsInput;
}

export interface UserCreateManyWithoutFollowedCharitiesInput {
  create?:
    | UserCreateWithoutFollowedCharitiesInput[]
    | UserCreateWithoutFollowedCharitiesInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateOneWithoutDotsInput {
  create?: UserCreateWithoutDotsInput;
  connect?: UserWhereUniqueInput;
}

export interface DotWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  action?: String;
  action_not?: String;
  action_in?: String[] | String;
  action_not_in?: String[] | String;
  action_lt?: String;
  action_lte?: String;
  action_gt?: String;
  action_gte?: String;
  action_contains?: String;
  action_not_contains?: String;
  action_starts_with?: String;
  action_not_starts_with?: String;
  action_ends_with?: String;
  action_not_ends_with?: String;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  total?: Int;
  total_not?: Int;
  total_in?: Int[] | Int;
  total_not_in?: Int[] | Int;
  total_lt?: Int;
  total_lte?: Int;
  total_gt?: Int;
  total_gte?: Int;
  user?: UserWhereInput;
  AND?: DotWhereInput[] | DotWhereInput;
  OR?: DotWhereInput[] | DotWhereInput;
  NOT?: DotWhereInput[] | DotWhereInput;
}

export interface UserCreateWithoutDotsInput {
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
  circleJoinRequests?: CircleJoinRequestCreateManyWithoutUserInput;
  circleInvites?: CircleInviteCreateManyWithoutUserInput;
  circles?: CircleCreateManyWithoutMembersInput;
  circlesOwned?: CircleCreateManyWithoutOwnerInput;
  followedCharities?: CharityCreateManyWithoutFollowersInput;
  halos?: HaloCreateManyWithoutUserInput;
  identity: IdentityCreateOneWithoutUserInput;
  loops?: LoopCreateManyWithoutUserInput;
  preferences: PreferencesCreateOneWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
}

export interface EventUpdateOneRequiredWithoutSpecialFundraiserInput {
  create?: EventCreateWithoutSpecialFundraiserInput;
  update?: EventUpdateWithoutSpecialFundraiserDataInput;
  upsert?: EventUpsertWithoutSpecialFundraiserInput;
  connect?: EventWhereUniqueInput;
}

export interface DotUpdateInput {
  action?: String;
  amount?: Int;
  total?: Int;
  user?: UserUpdateOneRequiredWithoutDotsInput;
}

export interface IdentityUpdateInput {
  provider?: IdentityProvider;
  providerID?: String;
  user?: UserUpdateOneRequiredWithoutIdentityInput;
}

export interface UserUpdateOneRequiredWithoutDotsInput {
  create?: UserCreateWithoutDotsInput;
  update?: UserUpdateWithoutDotsDataInput;
  upsert?: UserUpsertWithoutDotsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateOneWithoutCircleJoinRequestsInput {
  create?: UserCreateWithoutCircleJoinRequestsInput;
  connect?: UserWhereUniqueInput;
}

export interface EventUpdateInput {
  endDate?: DateTimeInput;
  goal?: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate?: DateTimeInput;
  charity?: CharityUpdateOneWithoutEventsInput;
  specialFundraiser?: SpecialFundraiserUpdateOneWithoutEventInput;
  donations?: TransactionUpdateManyWithoutEventInput;
}

export interface DotUpdateManyMutationInput {
  action?: String;
  amount?: Int;
  total?: Int;
}

export interface UserUpsertWithoutDotsInput {
  update: UserUpdateWithoutDotsDataInput;
  create: UserCreateWithoutDotsInput;
}

export interface UserUpdateWithoutDotsDataInput {
  bio?: String;
  email?: String;
  nameFirst?: String;
  nameLast?: String;
  picture?: String;
  securityToken?: Int;
  username?: String;
  circleJoinRequests?: CircleJoinRequestUpdateManyWithoutUserInput;
  circleInvites?: CircleInviteUpdateManyWithoutUserInput;
  circles?: CircleUpdateManyWithoutMembersInput;
  circlesOwned?: CircleUpdateManyWithoutOwnerInput;
  followedCharities?: CharityUpdateManyWithoutFollowersInput;
  halos?: HaloUpdateManyWithoutUserInput;
  identity?: IdentityUpdateOneRequiredWithoutUserInput;
  loops?: LoopUpdateManyWithoutUserInput;
  preferences?: PreferencesUpdateOneRequiredWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
}

export interface IdentityCreateOneWithoutUserInput {
  create?: IdentityCreateWithoutUserInput;
  connect?: IdentityWhereUniqueInput;
}

export interface TransactionCreateManyWithoutEventInput {
  create?:
    | TransactionCreateWithoutEventInput[]
    | TransactionCreateWithoutEventInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
}

export interface PreferencesCreateInput {
  allowDonationEmails?: Boolean;
  publicProfile?: Boolean;
  user: UserCreateOneWithoutPreferencesInput;
}

export interface EventWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  updatedAt?: DateTimeInput;
  updatedAt_not?: DateTimeInput;
  updatedAt_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_not_in?: DateTimeInput[] | DateTimeInput;
  updatedAt_lt?: DateTimeInput;
  updatedAt_lte?: DateTimeInput;
  updatedAt_gt?: DateTimeInput;
  updatedAt_gte?: DateTimeInput;
  endDate?: DateTimeInput;
  endDate_not?: DateTimeInput;
  endDate_in?: DateTimeInput[] | DateTimeInput;
  endDate_not_in?: DateTimeInput[] | DateTimeInput;
  endDate_lt?: DateTimeInput;
  endDate_lte?: DateTimeInput;
  endDate_gt?: DateTimeInput;
  endDate_gte?: DateTimeInput;
  goal?: Int;
  goal_not?: Int;
  goal_in?: Int[] | Int;
  goal_not_in?: Int[] | Int;
  goal_lt?: Int;
  goal_lte?: Int;
  goal_gt?: Int;
  goal_gte?: Int;
  multiplier?: Int;
  multiplier_not?: Int;
  multiplier_in?: Int[] | Int;
  multiplier_not_in?: Int[] | Int;
  multiplier_lt?: Int;
  multiplier_lte?: Int;
  multiplier_gt?: Int;
  multiplier_gte?: Int;
  sponsorName?: String;
  sponsorName_not?: String;
  sponsorName_in?: String[] | String;
  sponsorName_not_in?: String[] | String;
  sponsorName_lt?: String;
  sponsorName_lte?: String;
  sponsorName_gt?: String;
  sponsorName_gte?: String;
  sponsorName_contains?: String;
  sponsorName_not_contains?: String;
  sponsorName_starts_with?: String;
  sponsorName_not_starts_with?: String;
  sponsorName_ends_with?: String;
  sponsorName_not_ends_with?: String;
  sponsorWebsite?: String;
  sponsorWebsite_not?: String;
  sponsorWebsite_in?: String[] | String;
  sponsorWebsite_not_in?: String[] | String;
  sponsorWebsite_lt?: String;
  sponsorWebsite_lte?: String;
  sponsorWebsite_gt?: String;
  sponsorWebsite_gte?: String;
  sponsorWebsite_contains?: String;
  sponsorWebsite_not_contains?: String;
  sponsorWebsite_starts_with?: String;
  sponsorWebsite_not_starts_with?: String;
  sponsorWebsite_ends_with?: String;
  sponsorWebsite_not_ends_with?: String;
  startDate?: DateTimeInput;
  startDate_not?: DateTimeInput;
  startDate_in?: DateTimeInput[] | DateTimeInput;
  startDate_not_in?: DateTimeInput[] | DateTimeInput;
  startDate_lt?: DateTimeInput;
  startDate_lte?: DateTimeInput;
  startDate_gt?: DateTimeInput;
  startDate_gte?: DateTimeInput;
  charity?: CharityWhereInput;
  specialFundraiser?: SpecialFundraiserWhereInput;
  donations_every?: TransactionWhereInput;
  donations_some?: TransactionWhereInput;
  donations_none?: TransactionWhereInput;
  AND?: EventWhereInput[] | EventWhereInput;
  OR?: EventWhereInput[] | EventWhereInput;
  NOT?: EventWhereInput[] | EventWhereInput;
}

export interface UserCreateOneWithoutCirclesOwnedInput {
  create?: UserCreateWithoutCirclesOwnedInput;
  connect?: UserWhereUniqueInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  email: () => Promise<String>;
  nameFirst: () => Promise<String>;
  nameLast: () => Promise<String>;
  picture: () => Promise<String>;
  securityToken: () => Promise<Int>;
  username: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bio: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameLast: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  securityToken: () => Promise<AsyncIterator<Int>>;
  username: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCharity {
  count: Int;
}

export interface AggregateCharityPromise
  extends Promise<AggregateCharity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCharitySubscription
  extends Promise<AsyncIterator<AggregateCharity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Event {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  endDate: DateTimeOutput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeOutput;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  goal: () => Promise<Int>;
  multiplier: () => Promise<Int>;
  sponsorName: () => Promise<String>;
  sponsorWebsite: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
  charity: <T = CharityPromise>() => T;
  specialFundraiser: <T = SpecialFundraiserPromise>() => T;
  donations: <T = FragmentableArray<Transaction>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  goal: () => Promise<AsyncIterator<Int>>;
  multiplier: () => Promise<AsyncIterator<Int>>;
  sponsorName: () => Promise<AsyncIterator<String>>;
  sponsorWebsite: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  charity: <T = CharitySubscription>() => T;
  specialFundraiser: <T = SpecialFundraiserSubscription>() => T;
  donations: <T = Promise<AsyncIterator<TransactionSubscription>>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CharityEdge {
  node: Charity;
  cursor: String;
}

export interface CharityEdgePromise extends Promise<CharityEdge>, Fragmentable {
  node: <T = CharityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CharityEdgeSubscription
  extends Promise<AsyncIterator<CharityEdge>>,
    Fragmentable {
  node: <T = CharitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface SpecialFundraiser {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  name: String;
}

export interface SpecialFundraiserPromise
  extends Promise<SpecialFundraiser>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  event: <T = EventPromise>() => T;
}

export interface SpecialFundraiserSubscription
  extends Promise<AsyncIterator<SpecialFundraiser>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  event: <T = EventSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CharityConnection {
  pageInfo: PageInfo;
  edges: CharityEdge[];
}

export interface CharityConnectionPromise
  extends Promise<CharityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CharityEdge>>() => T;
  aggregate: <T = AggregateCharityPromise>() => T;
}

export interface CharityConnectionSubscription
  extends Promise<AsyncIterator<CharityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CharityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCharitySubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface TransactionPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amount: Int;
  balance: Int;
  key: String;
  stripeID?: String;
  type: TransactionType;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  balance: () => Promise<Int>;
  key: () => Promise<String>;
  stripeID: () => Promise<String>;
  type: () => Promise<TransactionType>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  balance: () => Promise<AsyncIterator<Int>>;
  key: () => Promise<AsyncIterator<String>>;
  stripeID: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
}

export interface SpecialFundraiserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description: String;
  name: String;
}

export interface SpecialFundraiserPreviousValuesPromise
  extends Promise<SpecialFundraiserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
}

export interface SpecialFundraiserPreviousValuesSubscription
  extends Promise<AsyncIterator<SpecialFundraiserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SpecialFundraiserEdge {
  node: SpecialFundraiser;
  cursor: String;
}

export interface SpecialFundraiserEdgePromise
  extends Promise<SpecialFundraiserEdge>,
    Fragmentable {
  node: <T = SpecialFundraiserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SpecialFundraiserEdgeSubscription
  extends Promise<AsyncIterator<SpecialFundraiserEdge>>,
    Fragmentable {
  node: <T = SpecialFundraiserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface Charity {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  acronym?: String;
  bannerCredit?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
}

export interface CharityPromise extends Promise<Charity>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  acronym: () => Promise<String>;
  bannerCredit: () => Promise<String>;
  ein: () => Promise<String>;
  expensesAdministrative: () => Promise<Float>;
  expensesFundraising: () => Promise<Float>;
  expensesOther: () => Promise<Float>;
  expensesProgram: () => Promise<Float>;
  expensesUpdated: () => Promise<String>;
  location: () => Promise<String>;
  mission: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  website: () => Promise<String>;
  events: <T = FragmentableArray<Event>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  followers: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CharitySubscription
  extends Promise<AsyncIterator<Charity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  acronym: () => Promise<AsyncIterator<String>>;
  bannerCredit: () => Promise<AsyncIterator<String>>;
  ein: () => Promise<AsyncIterator<String>>;
  expensesAdministrative: () => Promise<AsyncIterator<Float>>;
  expensesFundraising: () => Promise<AsyncIterator<Float>>;
  expensesOther: () => Promise<AsyncIterator<Float>>;
  expensesProgram: () => Promise<AsyncIterator<Float>>;
  expensesUpdated: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  mission: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  events: <T = Promise<AsyncIterator<EventSubscription>>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  followers: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CharitySubscriptionPayload {
  mutation: MutationType;
  node: Charity;
  updatedFields: String[];
  previousValues: CharityPreviousValues;
}

export interface CharitySubscriptionPayloadPromise
  extends Promise<CharitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CharityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CharityPreviousValuesPromise>() => T;
}

export interface CharitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CharitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CharitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CharityPreviousValuesSubscription>() => T;
}

export interface PreferencesEdge {
  node: Preferences;
  cursor: String;
}

export interface PreferencesEdgePromise
  extends Promise<PreferencesEdge>,
    Fragmentable {
  node: <T = PreferencesPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PreferencesEdgeSubscription
  extends Promise<AsyncIterator<PreferencesEdge>>,
    Fragmentable {
  node: <T = PreferencesSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CharityPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  acronym?: String;
  bannerCredit?: String;
  ein: String;
  expensesAdministrative?: Float;
  expensesFundraising?: Float;
  expensesOther?: Float;
  expensesProgram?: Float;
  expensesUpdated?: String;
  location: String;
  mission: String;
  name: String;
  phoneNumber: String;
  website: String;
}

export interface CharityPreviousValuesPromise
  extends Promise<CharityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  acronym: () => Promise<String>;
  bannerCredit: () => Promise<String>;
  ein: () => Promise<String>;
  expensesAdministrative: () => Promise<Float>;
  expensesFundraising: () => Promise<Float>;
  expensesOther: () => Promise<Float>;
  expensesProgram: () => Promise<Float>;
  expensesUpdated: () => Promise<String>;
  location: () => Promise<String>;
  mission: () => Promise<String>;
  name: () => Promise<String>;
  phoneNumber: () => Promise<String>;
  website: () => Promise<String>;
}

export interface CharityPreviousValuesSubscription
  extends Promise<AsyncIterator<CharityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  acronym: () => Promise<AsyncIterator<String>>;
  bannerCredit: () => Promise<AsyncIterator<String>>;
  ein: () => Promise<AsyncIterator<String>>;
  expensesAdministrative: () => Promise<AsyncIterator<Float>>;
  expensesFundraising: () => Promise<AsyncIterator<Float>>;
  expensesOther: () => Promise<AsyncIterator<Float>>;
  expensesProgram: () => Promise<AsyncIterator<Float>>;
  expensesUpdated: () => Promise<AsyncIterator<String>>;
  location: () => Promise<AsyncIterator<String>>;
  mission: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  phoneNumber: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Preferences {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  allowDonationEmails: Boolean;
  publicProfile: Boolean;
}

export interface PreferencesPromise extends Promise<Preferences>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  allowDonationEmails: () => Promise<Boolean>;
  publicProfile: () => Promise<Boolean>;
  user: <T = UserPromise>() => T;
}

export interface PreferencesSubscription
  extends Promise<AsyncIterator<Preferences>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  allowDonationEmails: () => Promise<AsyncIterator<Boolean>>;
  publicProfile: () => Promise<AsyncIterator<Boolean>>;
  user: <T = UserSubscription>() => T;
}

export interface LoopEdge {
  node: Loop;
  cursor: String;
}

export interface LoopEdgePromise extends Promise<LoopEdge>, Fragmentable {
  node: <T = LoopPromise>() => T;
  cursor: () => Promise<String>;
}

export interface LoopEdgeSubscription
  extends Promise<AsyncIterator<LoopEdge>>,
    Fragmentable {
  node: <T = LoopSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface CircleSubscriptionPayload {
  mutation: MutationType;
  node: Circle;
  updatedFields: String[];
  previousValues: CirclePreviousValues;
}

export interface CircleSubscriptionPayloadPromise
  extends Promise<CircleSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CirclePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CirclePreviousValuesPromise>() => T;
}

export interface CircleSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CircleSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CircleSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CirclePreviousValuesSubscription>() => T;
}

export interface AggregateIdentity {
  count: Int;
}

export interface AggregateIdentityPromise
  extends Promise<AggregateIdentity>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateIdentitySubscription
  extends Promise<AsyncIterator<AggregateIdentity>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CirclePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  name: String;
  open: Boolean;
}

export interface CirclePreviousValuesPromise
  extends Promise<CirclePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  open: () => Promise<Boolean>;
}

export interface CirclePreviousValuesSubscription
  extends Promise<AsyncIterator<CirclePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
}

export interface IdentityConnection {
  pageInfo: PageInfo;
  edges: IdentityEdge[];
}

export interface IdentityConnectionPromise
  extends Promise<IdentityConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<IdentityEdge>>() => T;
  aggregate: <T = AggregateIdentityPromise>() => T;
}

export interface IdentityConnectionSubscription
  extends Promise<AsyncIterator<IdentityConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<IdentityEdgeSubscription>>>() => T;
  aggregate: <T = AggregateIdentitySubscription>() => T;
}

export interface Loop {
  id: ID_Output;
  createdAt: DateTimeOutput;
  count: Int;
}

export interface LoopPromise extends Promise<Loop>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  count: () => Promise<Int>;
  event: <T = EventPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface LoopSubscription
  extends Promise<AsyncIterator<Loop>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  count: () => Promise<AsyncIterator<Int>>;
  event: <T = EventSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface AggregateHalo {
  count: Int;
}

export interface AggregateHaloPromise
  extends Promise<AggregateHalo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateHaloSubscription
  extends Promise<AsyncIterator<AggregateHalo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CircleInviteSubscriptionPayload {
  mutation: MutationType;
  node: CircleInvite;
  updatedFields: String[];
  previousValues: CircleInvitePreviousValues;
}

export interface CircleInviteSubscriptionPayloadPromise
  extends Promise<CircleInviteSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CircleInvitePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CircleInvitePreviousValuesPromise>() => T;
}

export interface CircleInviteSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CircleInviteSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CircleInviteSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CircleInvitePreviousValuesSubscription>() => T;
}

export interface HaloConnection {
  pageInfo: PageInfo;
  edges: HaloEdge[];
}

export interface HaloConnectionPromise
  extends Promise<HaloConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<HaloEdge>>() => T;
  aggregate: <T = AggregateHaloPromise>() => T;
}

export interface HaloConnectionSubscription
  extends Promise<AsyncIterator<HaloConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<HaloEdgeSubscription>>>() => T;
  aggregate: <T = AggregateHaloSubscription>() => T;
}

export interface CircleInvitePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleInvitePreviousValuesPromise
  extends Promise<CircleInvitePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CircleInvitePreviousValuesSubscription
  extends Promise<AsyncIterator<CircleInvitePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Identity {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  provider: IdentityProvider;
  providerID: String;
}

export interface IdentityPromise extends Promise<Identity>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  provider: () => Promise<IdentityProvider>;
  providerID: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface IdentitySubscription
  extends Promise<AsyncIterator<Identity>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  provider: () => Promise<AsyncIterator<IdentityProvider>>;
  providerID: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface AggregateDot {
  count: Int;
}

export interface AggregateDotPromise
  extends Promise<AggregateDot>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateDotSubscription
  extends Promise<AsyncIterator<AggregateDot>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CircleJoinRequestSubscriptionPayload {
  mutation: MutationType;
  node: CircleJoinRequest;
  updatedFields: String[];
  previousValues: CircleJoinRequestPreviousValues;
}

export interface CircleJoinRequestSubscriptionPayloadPromise
  extends Promise<CircleJoinRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CircleJoinRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CircleJoinRequestPreviousValuesPromise>() => T;
}

export interface CircleJoinRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CircleJoinRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CircleJoinRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CircleJoinRequestPreviousValuesSubscription>() => T;
}

export interface DotConnection {
  pageInfo: PageInfo;
  edges: DotEdge[];
}

export interface DotConnectionPromise
  extends Promise<DotConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<DotEdge>>() => T;
  aggregate: <T = AggregateDotPromise>() => T;
}

export interface DotConnectionSubscription
  extends Promise<AsyncIterator<DotConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<DotEdgeSubscription>>>() => T;
  aggregate: <T = AggregateDotSubscription>() => T;
}

export interface CircleJoinRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleJoinRequestPreviousValuesPromise
  extends Promise<CircleJoinRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface CircleJoinRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<CircleJoinRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CircleJoinRequestEdge {
  node: CircleJoinRequest;
  cursor: String;
}

export interface CircleJoinRequestEdgePromise
  extends Promise<CircleJoinRequestEdge>,
    Fragmentable {
  node: <T = CircleJoinRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CircleJoinRequestEdgeSubscription
  extends Promise<AsyncIterator<CircleJoinRequestEdge>>,
    Fragmentable {
  node: <T = CircleJoinRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Halo {
  id: ID_Output;
  createdAt: DateTimeOutput;
  key: String;
  tier?: String;
}

export interface HaloPromise extends Promise<Halo>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  tier: () => Promise<String>;
  user: <T = UserPromise>() => T;
}

export interface HaloSubscription
  extends Promise<AsyncIterator<Halo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  tier: () => Promise<AsyncIterator<String>>;
  user: <T = UserSubscription>() => T;
}

export interface AggregateCircleInvite {
  count: Int;
}

export interface AggregateCircleInvitePromise
  extends Promise<AggregateCircleInvite>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCircleInviteSubscription
  extends Promise<AsyncIterator<AggregateCircleInvite>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface DotSubscriptionPayload {
  mutation: MutationType;
  node: Dot;
  updatedFields: String[];
  previousValues: DotPreviousValues;
}

export interface DotSubscriptionPayloadPromise
  extends Promise<DotSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = DotPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = DotPreviousValuesPromise>() => T;
}

export interface DotSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<DotSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = DotSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = DotPreviousValuesSubscription>() => T;
}

export interface CircleInviteConnection {
  pageInfo: PageInfo;
  edges: CircleInviteEdge[];
}

export interface CircleInviteConnectionPromise
  extends Promise<CircleInviteConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CircleInviteEdge>>() => T;
  aggregate: <T = AggregateCircleInvitePromise>() => T;
}

export interface CircleInviteConnectionSubscription
  extends Promise<AsyncIterator<CircleInviteConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CircleInviteEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCircleInviteSubscription>() => T;
}

export interface DotPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  action: String;
  amount: Int;
  total: Int;
}

export interface DotPreviousValuesPromise
  extends Promise<DotPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
  amount: () => Promise<Int>;
  total: () => Promise<Int>;
}

export interface DotPreviousValuesSubscription
  extends Promise<AsyncIterator<DotPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
}

export interface CircleEdge {
  node: Circle;
  cursor: String;
}

export interface CircleEdgePromise extends Promise<CircleEdge>, Fragmentable {
  node: <T = CirclePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CircleEdgeSubscription
  extends Promise<AsyncIterator<CircleEdge>>,
    Fragmentable {
  node: <T = CircleSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface SpecialFundraiserConnection {
  pageInfo: PageInfo;
  edges: SpecialFundraiserEdge[];
}

export interface SpecialFundraiserConnectionPromise
  extends Promise<SpecialFundraiserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SpecialFundraiserEdge>>() => T;
  aggregate: <T = AggregateSpecialFundraiserPromise>() => T;
}

export interface SpecialFundraiserConnectionSubscription
  extends Promise<AsyncIterator<SpecialFundraiserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpecialFundraiserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpecialFundraiserSubscription>() => T;
}

export interface EventPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  endDate: DateTimeOutput;
  goal: Int;
  multiplier?: Int;
  sponsorName?: String;
  sponsorWebsite?: String;
  startDate: DateTimeOutput;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  endDate: () => Promise<DateTimeOutput>;
  goal: () => Promise<Int>;
  multiplier: () => Promise<Int>;
  sponsorName: () => Promise<String>;
  sponsorWebsite: () => Promise<String>;
  startDate: () => Promise<DateTimeOutput>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  endDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  goal: () => Promise<AsyncIterator<Int>>;
  multiplier: () => Promise<AsyncIterator<Int>>;
  sponsorName: () => Promise<AsyncIterator<String>>;
  sponsorWebsite: () => Promise<AsyncIterator<String>>;
  startDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PreferencesConnection {
  pageInfo: PageInfo;
  edges: PreferencesEdge[];
}

export interface PreferencesConnectionPromise
  extends Promise<PreferencesConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PreferencesEdge>>() => T;
  aggregate: <T = AggregatePreferencesPromise>() => T;
}

export interface PreferencesConnectionSubscription
  extends Promise<AsyncIterator<PreferencesConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PreferencesEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePreferencesSubscription>() => T;
}

export interface Dot {
  id: ID_Output;
  createdAt: DateTimeOutput;
  action: String;
  amount: Int;
  total: Int;
}

export interface DotPromise extends Promise<Dot>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  action: () => Promise<String>;
  amount: () => Promise<Int>;
  total: () => Promise<Int>;
  user: <T = UserPromise>() => T;
}

export interface DotSubscription
  extends Promise<AsyncIterator<Dot>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  action: () => Promise<AsyncIterator<String>>;
  amount: () => Promise<AsyncIterator<Int>>;
  total: () => Promise<AsyncIterator<Int>>;
  user: <T = UserSubscription>() => T;
}

export interface LoopConnection {
  pageInfo: PageInfo;
  edges: LoopEdge[];
}

export interface LoopConnectionPromise
  extends Promise<LoopConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<LoopEdge>>() => T;
  aggregate: <T = AggregateLoopPromise>() => T;
}

export interface LoopConnectionSubscription
  extends Promise<AsyncIterator<LoopConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<LoopEdgeSubscription>>>() => T;
  aggregate: <T = AggregateLoopSubscription>() => T;
}

export interface HaloSubscriptionPayload {
  mutation: MutationType;
  node: Halo;
  updatedFields: String[];
  previousValues: HaloPreviousValues;
}

export interface HaloSubscriptionPayloadPromise
  extends Promise<HaloSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = HaloPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = HaloPreviousValuesPromise>() => T;
}

export interface HaloSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<HaloSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = HaloSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = HaloPreviousValuesSubscription>() => T;
}

export interface Transaction {
  id: ID_Output;
  createdAt: DateTimeOutput;
  amount: Int;
  balance: Int;
  key: String;
  stripeID?: String;
  type: TransactionType;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  amount: () => Promise<Int>;
  balance: () => Promise<Int>;
  key: () => Promise<String>;
  stripeID: () => Promise<String>;
  type: () => Promise<TransactionType>;
  event: <T = EventPromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  amount: () => Promise<AsyncIterator<Int>>;
  balance: () => Promise<AsyncIterator<Int>>;
  key: () => Promise<AsyncIterator<String>>;
  stripeID: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  event: <T = EventSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface HaloPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  key: String;
  tier?: String;
}

export interface HaloPreviousValuesPromise
  extends Promise<HaloPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  key: () => Promise<String>;
  tier: () => Promise<String>;
}

export interface HaloPreviousValuesSubscription
  extends Promise<AsyncIterator<HaloPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  key: () => Promise<AsyncIterator<String>>;
  tier: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CircleInvite {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleInvitePromise
  extends Promise<CircleInvite>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  circle: <T = CirclePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CircleInviteSubscription
  extends Promise<AsyncIterator<CircleInvite>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  circle: <T = CircleSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface DotEdge {
  node: Dot;
  cursor: String;
}

export interface DotEdgePromise extends Promise<DotEdge>, Fragmentable {
  node: <T = DotPromise>() => T;
  cursor: () => Promise<String>;
}

export interface DotEdgeSubscription
  extends Promise<AsyncIterator<DotEdge>>,
    Fragmentable {
  node: <T = DotSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface IdentitySubscriptionPayload {
  mutation: MutationType;
  node: Identity;
  updatedFields: String[];
  previousValues: IdentityPreviousValues;
}

export interface IdentitySubscriptionPayloadPromise
  extends Promise<IdentitySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = IdentityPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = IdentityPreviousValuesPromise>() => T;
}

export interface IdentitySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<IdentitySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = IdentitySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = IdentityPreviousValuesSubscription>() => T;
}

export interface CircleJoinRequestConnection {
  pageInfo: PageInfo;
  edges: CircleJoinRequestEdge[];
}

export interface CircleJoinRequestConnectionPromise
  extends Promise<CircleJoinRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CircleJoinRequestEdge>>() => T;
  aggregate: <T = AggregateCircleJoinRequestPromise>() => T;
}

export interface CircleJoinRequestConnectionSubscription
  extends Promise<AsyncIterator<CircleJoinRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CircleJoinRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCircleJoinRequestSubscription>() => T;
}

export interface IdentityPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  provider: IdentityProvider;
  providerID: String;
}

export interface IdentityPreviousValuesPromise
  extends Promise<IdentityPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  provider: () => Promise<IdentityProvider>;
  providerID: () => Promise<String>;
}

export interface IdentityPreviousValuesSubscription
  extends Promise<AsyncIterator<IdentityPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  provider: () => Promise<AsyncIterator<IdentityProvider>>;
  providerID: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCircle {
  count: Int;
}

export interface AggregateCirclePromise
  extends Promise<AggregateCircle>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCircleSubscription
  extends Promise<AsyncIterator<AggregateCircle>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  bio?: String;
  email: String;
  nameFirst: String;
  nameLast: String;
  picture?: String;
  securityToken: Int;
  username: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  bio: () => Promise<String>;
  email: () => Promise<String>;
  nameFirst: () => Promise<String>;
  nameLast: () => Promise<String>;
  picture: () => Promise<String>;
  securityToken: () => Promise<Int>;
  username: () => Promise<String>;
  circleJoinRequests: <T = FragmentableArray<CircleJoinRequest>>(
    args?: {
      where?: CircleJoinRequestWhereInput;
      orderBy?: CircleJoinRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  circleInvites: <T = FragmentableArray<CircleInvite>>(
    args?: {
      where?: CircleInviteWhereInput;
      orderBy?: CircleInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  circles: <T = FragmentableArray<Circle>>(
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  circlesOwned: <T = FragmentableArray<Circle>>(
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  dots: <T = FragmentableArray<Dot>>(
    args?: {
      where?: DotWhereInput;
      orderBy?: DotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  followedCharities: <T = FragmentableArray<Charity>>(
    args?: {
      where?: CharityWhereInput;
      orderBy?: CharityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  halos: <T = FragmentableArray<Halo>>(
    args?: {
      where?: HaloWhereInput;
      orderBy?: HaloOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  identity: <T = IdentityPromise>() => T;
  loops: <T = FragmentableArray<Loop>>(
    args?: {
      where?: LoopWhereInput;
      orderBy?: LoopOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  preferences: <T = PreferencesPromise>() => T;
  transactions: <T = FragmentableArray<Transaction>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bio: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  nameFirst: () => Promise<AsyncIterator<String>>;
  nameLast: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  securityToken: () => Promise<AsyncIterator<Int>>;
  username: () => Promise<AsyncIterator<String>>;
  circleJoinRequests: <
    T = Promise<AsyncIterator<CircleJoinRequestSubscription>>
  >(
    args?: {
      where?: CircleJoinRequestWhereInput;
      orderBy?: CircleJoinRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  circleInvites: <T = Promise<AsyncIterator<CircleInviteSubscription>>>(
    args?: {
      where?: CircleInviteWhereInput;
      orderBy?: CircleInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  circles: <T = Promise<AsyncIterator<CircleSubscription>>>(
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  circlesOwned: <T = Promise<AsyncIterator<CircleSubscription>>>(
    args?: {
      where?: CircleWhereInput;
      orderBy?: CircleOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  dots: <T = Promise<AsyncIterator<DotSubscription>>>(
    args?: {
      where?: DotWhereInput;
      orderBy?: DotOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  followedCharities: <T = Promise<AsyncIterator<CharitySubscription>>>(
    args?: {
      where?: CharityWhereInput;
      orderBy?: CharityOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  halos: <T = Promise<AsyncIterator<HaloSubscription>>>(
    args?: {
      where?: HaloWhereInput;
      orderBy?: HaloOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  identity: <T = IdentitySubscription>() => T;
  loops: <T = Promise<AsyncIterator<LoopSubscription>>>(
    args?: {
      where?: LoopWhereInput;
      orderBy?: LoopOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  preferences: <T = PreferencesSubscription>() => T;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface AggregateSpecialFundraiser {
  count: Int;
}

export interface AggregateSpecialFundraiserPromise
  extends Promise<AggregateSpecialFundraiser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpecialFundraiserSubscription
  extends Promise<AsyncIterator<AggregateSpecialFundraiser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoopSubscriptionPayload {
  mutation: MutationType;
  node: Loop;
  updatedFields: String[];
  previousValues: LoopPreviousValues;
}

export interface LoopSubscriptionPayloadPromise
  extends Promise<LoopSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = LoopPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = LoopPreviousValuesPromise>() => T;
}

export interface LoopSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<LoopSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = LoopSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = LoopPreviousValuesSubscription>() => T;
}

export interface AggregateLoop {
  count: Int;
}

export interface AggregateLoopPromise
  extends Promise<AggregateLoop>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateLoopSubscription
  extends Promise<AsyncIterator<AggregateLoop>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface LoopPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  count: Int;
}

export interface LoopPreviousValuesPromise
  extends Promise<LoopPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  count: () => Promise<Int>;
}

export interface LoopPreviousValuesSubscription
  extends Promise<AsyncIterator<LoopPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  count: () => Promise<AsyncIterator<Int>>;
}

export interface HaloEdge {
  node: Halo;
  cursor: String;
}

export interface HaloEdgePromise extends Promise<HaloEdge>, Fragmentable {
  node: <T = HaloPromise>() => T;
  cursor: () => Promise<String>;
}

export interface HaloEdgeSubscription
  extends Promise<AsyncIterator<HaloEdge>>,
    Fragmentable {
  node: <T = HaloSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Circle {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  description?: String;
  name: String;
  open: Boolean;
}

export interface CirclePromise extends Promise<Circle>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  open: () => Promise<Boolean>;
  joinRequests: <T = FragmentableArray<CircleJoinRequest>>(
    args?: {
      where?: CircleJoinRequestWhereInput;
      orderBy?: CircleJoinRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invites: <T = FragmentableArray<CircleInvite>>(
    args?: {
      where?: CircleInviteWhereInput;
      orderBy?: CircleInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  members: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserPromise>() => T;
}

export interface CircleSubscription
  extends Promise<AsyncIterator<Circle>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  open: () => Promise<AsyncIterator<Boolean>>;
  joinRequests: <T = Promise<AsyncIterator<CircleJoinRequestSubscription>>>(
    args?: {
      where?: CircleJoinRequestWhereInput;
      orderBy?: CircleJoinRequestOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invites: <T = Promise<AsyncIterator<CircleInviteSubscription>>>(
    args?: {
      where?: CircleInviteWhereInput;
      orderBy?: CircleInviteOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserSubscription>() => T;
}

export interface AggregateCircleJoinRequest {
  count: Int;
}

export interface AggregateCircleJoinRequestPromise
  extends Promise<AggregateCircleJoinRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCircleJoinRequestSubscription
  extends Promise<AsyncIterator<AggregateCircleJoinRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CircleConnection {
  pageInfo: PageInfo;
  edges: CircleEdge[];
}

export interface CircleConnectionPromise
  extends Promise<CircleConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CircleEdge>>() => T;
  aggregate: <T = AggregateCirclePromise>() => T;
}

export interface CircleConnectionSubscription
  extends Promise<AsyncIterator<CircleConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CircleEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCircleSubscription>() => T;
}

export interface SpecialFundraiserSubscriptionPayload {
  mutation: MutationType;
  node: SpecialFundraiser;
  updatedFields: String[];
  previousValues: SpecialFundraiserPreviousValues;
}

export interface SpecialFundraiserSubscriptionPayloadPromise
  extends Promise<SpecialFundraiserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpecialFundraiserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpecialFundraiserPreviousValuesPromise>() => T;
}

export interface SpecialFundraiserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpecialFundraiserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpecialFundraiserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpecialFundraiserPreviousValuesSubscription>() => T;
}

export interface CircleJoinRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface CircleJoinRequestPromise
  extends Promise<CircleJoinRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  circle: <T = CirclePromise>() => T;
  user: <T = UserPromise>() => T;
}

export interface CircleJoinRequestSubscription
  extends Promise<AsyncIterator<CircleJoinRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  circle: <T = CircleSubscription>() => T;
  user: <T = UserSubscription>() => T;
}

export interface PreferencesPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  allowDonationEmails: Boolean;
  publicProfile: Boolean;
}

export interface PreferencesPreviousValuesPromise
  extends Promise<PreferencesPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  allowDonationEmails: () => Promise<Boolean>;
  publicProfile: () => Promise<Boolean>;
}

export interface PreferencesPreviousValuesSubscription
  extends Promise<AsyncIterator<PreferencesPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  allowDonationEmails: () => Promise<AsyncIterator<Boolean>>;
  publicProfile: () => Promise<AsyncIterator<Boolean>>;
}

export interface PreferencesSubscriptionPayload {
  mutation: MutationType;
  node: Preferences;
  updatedFields: String[];
  previousValues: PreferencesPreviousValues;
}

export interface PreferencesSubscriptionPayloadPromise
  extends Promise<PreferencesSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PreferencesPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PreferencesPreviousValuesPromise>() => T;
}

export interface PreferencesSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PreferencesSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PreferencesSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PreferencesPreviousValuesSubscription>() => T;
}

export interface AggregatePreferences {
  count: Int;
}

export interface AggregatePreferencesPromise
  extends Promise<AggregatePreferences>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePreferencesSubscription
  extends Promise<AsyncIterator<AggregatePreferences>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CircleInviteEdge {
  node: CircleInvite;
  cursor: String;
}

export interface CircleInviteEdgePromise
  extends Promise<CircleInviteEdge>,
    Fragmentable {
  node: <T = CircleInvitePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CircleInviteEdgeSubscription
  extends Promise<AsyncIterator<CircleInviteEdge>>,
    Fragmentable {
  node: <T = CircleInviteSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface IdentityEdge {
  node: Identity;
  cursor: String;
}

export interface IdentityEdgePromise
  extends Promise<IdentityEdge>,
    Fragmentable {
  node: <T = IdentityPromise>() => T;
  cursor: () => Promise<String>;
}

export interface IdentityEdgeSubscription
  extends Promise<AsyncIterator<IdentityEdge>>,
    Fragmentable {
  node: <T = IdentitySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Dot",
    embedded: false
  },
  {
    name: "Halo",
    embedded: false
  },
  {
    name: "Identity",
    embedded: false
  },
  {
    name: "Loop",
    embedded: false
  },
  {
    name: "Preferences",
    embedded: false
  },
  {
    name: "Circle",
    embedded: false
  },
  {
    name: "CircleJoinRequest",
    embedded: false
  },
  {
    name: "CircleInvite",
    embedded: false
  },
  {
    name: "Charity",
    embedded: false
  },
  {
    name: "SpecialFundraiser",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  },
  {
    name: "IdentityProvider",
    embedded: false
  },
  {
    name: "TransactionType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
